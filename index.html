<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NAVgator · Dashboard</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=DM+Serif+Display&family=JetBrains+Mono:wght@300;400;500&display=swap');
  :root {
    --bg: #0d0d0d; --bg2: #131313; --bg3: #1a1a1a;
    --border: #222228; --border2: #2a2a32;
    --dim: #555560; --muted: #77778a; --text: #a0a0b0; --bright: #d0d0dd; --white: #eeeef2;
    --green: #00e5a0; --green-dim: rgba(0,229,160,0.10);
    --red: #e84057; --orange: #f59e42; --blue: #5b8def; --purple: #9f8cfc;
    --card-bg: #0a0a0a; --card-border: #1a1a1a;
  }
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: 'Inter', -apple-system, system-ui, sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; -webkit-font-smoothing: antialiased; }
  ::selection { background: rgba(0,229,160,0.25); }

  .wrap { max-width: 1200px; margin: 0 auto; padding: 40px 32px 64px; }

  /* Nav bar */
  .nav { display: flex; align-items: center; gap: 16px; margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid rgba(255,255,255,0.06); flex-wrap: wrap; }
  .nav-brand { font-family: 'Inter', sans-serif; font-size: 22px; font-weight: 700; color: var(--white); text-decoration: none; letter-spacing: -0.5px; display: inline; }
  .nav-brand span { color: #008a45; font-weight: 700; }
  .nav-brand-icon { display: inline-flex; align-items: center; justify-content: center; width: 26px; height: 26px; border-radius: 6px; background: linear-gradient(135deg, var(--green), #00b880); font-family: 'DM Serif Display', serif; font-size: 13px; font-weight: 400; color: #0c0c10; flex-shrink: 0; }
  .nav-sep { color: var(--dim); }
  .nav-tokens { display: flex; gap: 6px; flex-wrap: wrap; }
  .nav-tok { font-family: 'Inter', sans-serif; font-size: 10px; font-weight: 500; letter-spacing: 0.8px; text-transform: uppercase; padding: 5px 12px; border-radius: 6px; border: 1px solid var(--border2); color: var(--muted); text-decoration: none; transition: all 0.2s; }
  .nav-tok:hover { border-color: var(--green); color: var(--white); background: rgba(255,255,255,0.03); }
  .nav-tok.active { border-color: var(--green); color: var(--green); background: var(--green-dim); }

  /* Subheader line */
  .sub { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 500; color: var(--muted); letter-spacing: 1.5px; text-transform: uppercase; margin-bottom: 10px; }
  .sub .data-tag { color: var(--green); }

  /* Title */
  h1 { font-family: 'DM Serif Display', serif; font-size: 42px; font-weight: 400; color: var(--white); margin-bottom: 12px; line-height: 1.1; letter-spacing: -0.5px; }

  /* Description */
  .desc { font-family: 'Inter', sans-serif; font-size: 14px; font-weight: 400; color: var(--muted); line-height: 1.7; max-width: 740px; margin-bottom: 32px; }
  .desc b { color: var(--white); font-weight: 600; }
  .desc .hl-orange { color: var(--orange); font-weight: 600; }
  .desc .hl-green { color: var(--green); font-weight: 600; }

  /* Price + metrics row */
  .price-metrics-row { display: flex; align-items: center; gap: 24px; padding: 8px 0 20px; }
  .price-hero { flex-shrink: 0; }
  .price-hero-value { font-family: 'Inter', sans-serif; font-size: 42px; font-weight: 700; color: var(--white); letter-spacing: -1px; }
  .price-hero-change { font-family: 'Inter', sans-serif; font-size: 14px; font-weight: 600; margin-top: 2px; }
  .price-hero-change.up { color: var(--green); }
  .price-hero-change.down { color: var(--red); }

  /* Metric cards — compact inline next to price */
  .cards { display: flex; gap: 10px; flex-wrap: wrap; flex: 1; justify-content: flex-end; margin-bottom: 0; }
  .card { border: 1px solid var(--card-border); border-radius: 10px; padding: 10px 14px; background: var(--card-bg); }
  .card-label { font-family: 'Inter', sans-serif; font-size: 10px; font-weight: 500; color: var(--muted); margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px; }
  .card-value { font-family: 'Inter', sans-serif; font-size: 24px; font-weight: 700; line-height: 1.1; color: var(--white); }
  .card-sub { font-family: 'Inter', sans-serif; font-size: 10px; font-weight: 400; color: var(--dim); margin-top: 3px; }
  @media (max-width: 800px) { .price-metrics-row { flex-wrap: wrap; } .cards { justify-content: flex-start; } }
  @media (max-width: 500px) { .price-hero-value { font-size: 30px; } .price-metrics-row { flex-direction: column; align-items: flex-start; } }

  /* Params bar */
  .params { display: flex; flex-wrap: wrap; gap: 6px 24px; font-family: 'Inter', sans-serif; font-size: 12px; font-weight: 400; color: var(--dim); padding: 14px 0; border-top: 1px solid var(--border); border-bottom: 1px solid var(--border); margin-bottom: 28px; }
  .params b { color: var(--text); font-weight: 600; }
  .params .hl { color: var(--green); font-weight: 600; }
  .params .spot { color: var(--red); font-weight: 600; }

  /* Token header */
  .token-header { display: flex; align-items: center; justify-content: space-between; padding: 12px 0 4px; }
  .token-header-left { display: flex; align-items: center; gap: 12px; }
  .token-header-icon { width: 36px; height: 36px; border-radius: 50%; overflow: hidden; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
  .token-header-icon img { width: 100%; height: 100%; object-fit: cover; }
  .token-header-name { display: flex; align-items: baseline; gap: 10px; }
  .token-header-title { font-family: 'Inter', sans-serif; font-size: 20px; font-weight: 600; color: var(--white); }
  .token-header-ticker { font-family: 'Inter', sans-serif; font-size: 14px; font-weight: 500; color: var(--dim); }

  /* Chart section — clean, no box */
  .chart-section { background: transparent; border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 32px 28px; margin-bottom: 28px; position: relative; }
  .chart-title { display: none; }
  .chart-controls { display: flex; gap: 6px; margin-bottom: 12px; z-index: 2; align-items: center; }
  .chart-btn-group { display: flex; gap: 4px; }
  .chart-btn-group + .chart-btn-group { margin-left: 8px; padding-left: 10px; border-left: 1px solid var(--border2); }
  .chart-btn { font-family: 'Inter', sans-serif; font-size: 10px; font-weight: 500; padding: 5px 12px; border-radius: 6px; border: 1px solid var(--border2); color: var(--muted); background: transparent; cursor: pointer; transition: all 0.2s; }
  .chart-btn:hover { border-color: var(--green); color: var(--white); }
  .chart-btn.active { border-color: var(--green); color: var(--green); background: var(--green-dim); }
  #chart-container { width: 100%; min-height: 500px; position: relative; }
  .chart-loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); font-size: 12px; color: var(--dim); }

  /* Tooltip */
  .chart-tooltip { position: absolute; display: none; pointer-events: none; background: rgba(12,12,16,0.96); border: 1px solid var(--card-border); border-radius: 10px; padding: 12px 16px; z-index: 10; backdrop-filter: blur(8px); }
  .tt-price { font-family: 'DM Serif Display', serif; font-size: 22px; font-weight: 400; color: var(--white); margin-bottom: 4px; }
  .tt-line { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 400; margin-top: 3px; }
  .tt-date { font-family: 'Inter', sans-serif; font-size: 10px; color: var(--dim); margin-top: 6px; }

  /* Legend */
  .legend { display: flex; flex-wrap: wrap; gap: 18px; padding: 12px 4px 0; font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 400; color: var(--muted); }
  .legend-item { display: flex; align-items: center; gap: 6px; }
  .legend-line { display: inline-block; width: 18px; height: 2.5px; border-radius: 2px; }
  .legend-fill { display: inline-block; width: 12px; height: 12px; border-radius: 2px; }
  .legend-dash { display: inline-block; width: 20px; height: 8px; position: relative; }
  .legend-dash::before { content: ''; position: absolute; top: 50%; left: 0; width: 100%; height: 0; background: none; border: none; }
  .legend-dash svg { width: 20px; height: 8px; }

  /* Address section */
  .nav-stats-bar { display: flex; gap: 0; margin-top: 12px; border-radius: 10px; overflow: hidden; font-family: 'Inter', sans-serif; font-size: 12px; }
  .nav-stats-bar .ns-item { flex: 1; padding: 12px 16px; display: flex; flex-direction: column; gap: 4px; }
  .nav-stats-bar .ns-label { font-size: 10px; font-weight: 600; letter-spacing: 1px; text-transform: uppercase; opacity: 0.7; }
  .nav-stats-bar .ns-value { font-size: 16px; font-weight: 600; }
  .nav-stats-bar .ns-sub { font-size: 10px; opacity: 0.6; }
  .nav-stats-bar .ns-above { background: rgba(0,229,160,0.08); color: #00e5a0; }
  .nav-stats-bar .ns-below { background: rgba(232,64,87,0.08); color: #e84057; }
  .nav-stats-bar .ns-neutral { background: rgba(255,255,255,0.04); color: var(--muted); }
  .nav-stats-bar .ns-progress { height: 4px; border-radius: 2px; margin-top: 6px; background: rgba(255,255,255,0.06); overflow: hidden; }
  .nav-stats-bar .ns-progress-fill { height: 100%; border-radius: 2px; }

  .addr-section { background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 14px; padding: 14px 18px; margin-bottom: 28px; }
  .addr-title { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 600; color: var(--muted); letter-spacing: 1.5px; text-transform: uppercase; margin-bottom: 12px; }
  .addr-row { display: flex; align-items: center; padding: 5px 0; border-bottom: 1px solid var(--border); font-family: 'Inter', sans-serif; font-size: 12px; gap: 12px; flex-wrap: wrap; }
  .addr-row:last-child { border-bottom: none; }
  .addr-label { color: var(--muted); font-weight: 500; min-width: 100px; font-size: 11px; }
  .addr-val { display: flex; align-items: center; gap: 6px; }
  .addr-val a { color: var(--green); text-decoration: none; font-family: 'JetBrains Mono', monospace; font-size: 11px; }
  .addr-val a:hover { text-decoration: underline; }
  .addr-copy { background: none; border: 1px solid var(--border2); border-radius: 4px; color: var(--dim); font-size: 9px; padding: 2px 5px; cursor: pointer; transition: all 0.2s; font-family: 'Inter', sans-serif; }
  .addr-copy:hover { border-color: var(--green); color: var(--green); }
  .addr-copy.copied { border-color: var(--green); color: var(--green); }
  .addr-bals { margin-left: auto; display: flex; align-items: center; gap: 6px; font-family: 'JetBrains Mono', monospace; font-size: 11px; }
  .bal-usdc { color: var(--dim); }
  .bal-sep { color: var(--border2); }
  .bal-token { color: var(--dim); }
  .bal-loading { color: var(--dim); }
  .allowance-section { background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 14px; padding: 20px 22px; margin-bottom: 28px; }
  .allowance-card { background: var(--bg2); border: 1px solid var(--border); border-radius: 10px; padding: 12px 14px; }
  .allowance-card .ac-label { font-size: 9px; color: var(--dim); text-transform: uppercase; letter-spacing: 0.5px; font-family: Inter, sans-serif; margin-bottom: 4px; }
  .allowance-card .ac-value { font-size: 16px; font-weight: 600; color: var(--bright); font-family: 'JetBrains Mono', monospace; }
  .allowance-card .ac-sub { font-size: 9px; color: var(--muted); font-family: Inter, sans-serif; margin-top: 3px; }
  .util-bar { height: 6px; border-radius: 3px; background: var(--border); margin-top: 6px; overflow: hidden; }
  .util-fill { height: 100%; border-radius: 3px; transition: width 0.3s ease; }
  .allowance-month { display: inline-flex; align-items: center; gap: 6px; padding: 4px 0; margin-right: 16px; }
  .allowance-month .am-label { color: var(--muted); }
  .allowance-month .am-bar { width: 60px; height: 4px; border-radius: 2px; background: var(--border); display: inline-block; position: relative; }
  .allowance-month .am-fill { height: 100%; border-radius: 2px; position: absolute; left: 0; top: 0; }
  .allowance-month .am-pct { color: var(--text); min-width: 32px; text-align: right; }
  .addr-title { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 600; color: var(--muted); letter-spacing: 1.5px; text-transform: uppercase; margin-bottom: 14px; }
  .addr-row { display: flex; align-items: center; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid var(--border); font-family: 'Inter', sans-serif; font-size: 12px; }
  .addr-row:last-child { border-bottom: none; }
  .addr-label { color: var(--muted); font-weight: 500; min-width: 100px; }
  .addr-val { display: flex; align-items: center; gap: 8px; }
  .addr-val a { color: var(--green); text-decoration: none; font-family: 'JetBrains Mono', monospace; font-size: 11px; }
  .addr-val a:hover { text-decoration: underline; }
  .addr-copy { background: none; border: 1px solid var(--border2); border-radius: 4px; color: var(--dim); font-size: 10px; padding: 2px 6px; cursor: pointer; transition: all 0.2s; font-family: 'Inter', sans-serif; }
  .addr-copy:hover { border-color: var(--green); color: var(--green); }
  .addr-copy.copied { border-color: var(--green); color: var(--green); }

  .footer { font-family: 'Inter', sans-serif; font-size: 10px; font-weight: 400; color: var(--dim); text-align: center; padding: 24px 0; border-top: 1px solid var(--border); }
  .footer a { color: var(--muted); text-decoration: underline; }

  /* ── Landing page styles ── */
  .landing { display: none; }
  .landing.active { display: block; }
  .dashboard { display: none; }
  .dashboard.active { display: block; }
  .hero { padding: 0; text-align: left; }
  .landing-nav { display: flex; align-items: center; justify-content: space-between; padding: 16px 0; border-bottom: 1px solid var(--border); margin-bottom: 0; }
  .landing-nav-left { display: flex; align-items: center; gap: 12px; }
  .landing-nav-left .brand { display: flex; align-items: center; gap: 10px; text-decoration: none; }
  .landing-nav-left .brand-logo { display: flex; align-items: center; }
  .landing-nav-left .brand-text { font-family: 'Inter', sans-serif; font-size: 24px; font-weight: 700; color: var(--white); letter-spacing: -0.5px; }
  .landing-nav-left .brand-text span { color: #008a45; font-weight: 700; }
  .landing-nav-left .brand-stat { font-family: 'Inter', sans-serif; font-size: 12px; color: var(--muted); margin-left: 8px; padding-left: 12px; border-left: 1px solid var(--border2); }
  .landing-nav-left .brand-stat b { color: var(--white); font-weight: 600; }
  .landing-nav-left .brand-stat .up { color: var(--green); }
  .landing-nav-left .brand-stat .down { color: var(--red); }
  .landing-nav-right { display: flex; align-items: center; gap: 12px; }
  .landing-nav-right a { font-family: 'Inter', sans-serif; font-size: 13px; font-weight: 500; color: var(--muted); text-decoration: none; padding: 6px 12px; border-radius: 8px; transition: all 0.15s; }
  .landing-nav-right a:hover { color: var(--white); background: rgba(255,255,255,0.04); }
  .landing-nav-right .submit-btn { border: 1px solid var(--green); color: var(--green); font-size: 12px; font-weight: 600; padding: 7px 16px; border-radius: 8px; }
  .landing-nav-right .submit-btn:hover { background: var(--green); color: #0c0c10; }
  .landing-filter-row { display: flex; align-items: center; justify-content: space-between; padding: 14px 0; }
  .landing-filter-left { display: flex; align-items: center; gap: 8px; }
  .landing-filter-left .filter-tab { font-family: 'Inter', sans-serif; font-size: 13px; font-weight: 500; color: var(--muted); padding: 6px 14px; border-radius: 8px; cursor: pointer; transition: all 0.15s; border: 1px solid transparent; }
  .landing-filter-left .filter-tab:hover { color: var(--white); }
  .landing-filter-left .filter-tab.active { color: var(--white); background: rgba(255,255,255,0.06); border-color: var(--border2); }
  .landing-filter-right { display: flex; align-items: center; gap: 4px; }
  .landing-filter-right .tf-btn { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 500; color: var(--dim); padding: 5px 10px; border-radius: 6px; cursor: pointer; transition: all 0.15s; border: 1px solid transparent; }
  .landing-filter-right .tf-btn:hover { color: var(--white); }
  .landing-filter-right .tf-btn.active { color: var(--white); background: rgba(255,255,255,0.08); border-color: var(--border2); }
  @media (max-width: 600px) { .landing-nav-left .brand-stat { display: none; } .landing-nav-right a:not(.submit-btn) { display: none; } }

  /* Table layout */
  .token-table-wrap { margin: 0 0 40px; border: none; border-radius: 0; overflow: hidden; background: transparent; }
  .token-table { width: 100%; border-collapse: collapse; font-family: 'Inter', sans-serif; }
  .token-table thead th { font-size: 10px; font-weight: 600; color: var(--dim); text-transform: uppercase; letter-spacing: 0.5px; padding: 12px 18px; text-align: right; border-bottom: 1px solid rgba(255,255,255,0.06); cursor: pointer; white-space: nowrap; user-select: none; }
  .token-table thead th:nth-child(1) { width: 36px; text-align: center; }
  .token-table thead th:nth-child(2) { text-align: left; }
  .token-table thead th:hover { color: var(--green); }
  .token-table thead th.sorted { color: var(--green); }
  .token-table tbody tr { border-bottom: 1px solid rgba(255,255,255,0.06); cursor: pointer; transition: background 0.15s; }
  .token-table tbody tr:last-child { border-bottom: none; }
  .token-table tbody tr:hover { background: rgba(255,255,255,0.02); }
  .token-table td { padding: 18px 18px; font-size: 14px; color: var(--text); text-align: right; white-space: nowrap; }
  .token-table td:nth-child(1) { text-align: center; color: var(--dim); font-size: 13px; font-weight: 500; width: 36px; }
  .token-table td:nth-child(2) { text-align: left; }
  .tt-name-cell { display: flex; align-items: center; gap: 14px; }
  .tt-icon { width: 36px; height: 36px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-family: 'DM Serif Display', serif; font-size: 15px; font-weight: 400; color: #0c0c10; flex-shrink: 0; overflow: hidden; }
  .tt-icon img { width: 100%; height: 100%; object-fit: cover; }
  .tt-name { font-weight: 600; color: var(--white); font-size: 15px; }
  .tt-ticker { color: var(--dim); font-size: 11px; margin-top: 1px; }
  .tt-price { font-weight: 600; color: var(--white); font-family: 'JetBrains Mono', monospace; font-size: 14px; }
  .tt-change { font-size: 11px; font-weight: 500; margin-top: 2px; }
  .tt-change.up { color: var(--green); }
  .tt-change.down { color: #e84057; }
  .tt-sparkline { width: 200px; height: 50px; }
  .tt-coming { font-size: 10px; font-weight: 600; color: var(--muted); letter-spacing: 1px; text-transform: uppercase; opacity: 0.6; }

  @media (max-width: 768px) {
    .token-table td:nth-child(6), .token-table th:nth-child(6),
    .token-table td:nth-child(7), .token-table th:nth-child(7) { display: none; }
    .tt-sparkline { width: 120px; }
  }
  @media (max-width: 500px) {
    .token-table td:nth-child(4), .token-table th:nth-child(4),
    .token-table td:nth-child(5), .token-table th:nth-child(5) { display: none; }
    .hero h1 { font-size: 32px; }
  }

  .how { padding: 36px 0 48px; border-top: 1px solid var(--border); }
  .how h2 { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 600; letter-spacing: 2px; text-transform: uppercase; color: var(--dim); margin-bottom: 24px; }
  .how-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; }
  @media (max-width: 600px) { .how-grid { grid-template-columns: 1fr; } }
</style>
</head>
<body>

<div class="wrap">

  <!-- ══ LANDING PAGE ══ -->
  <div class="landing" id="landing-view">
    <div class="hero">
      <div class="landing-nav">
        <div class="landing-nav-left">
          <a href="index.html" class="brand">
            <div class="brand-text">NAV<span>gator</span></div>
          </a>
          <div class="brand-stat" id="landing-total-treasury">NAV: <b id="landing-nav-total">—</b></div>
        </div>
        <div class="landing-nav-right">
          <a href="https://metadao.fi" target="_blank">MetaDAO</a>
          <a href="submit.html" class="submit-btn">+ Submit Token</a>
        </div>
      </div>
    </div>

    <div class="token-table-wrap">
      <table class="token-table" id="token-table">
        <thead>
          <tr>
            <th>#</th>
            <th style="text-align:left">Name</th>
            <th>Price</th>
            <th>NAV</th>
            <th>vs NAV</th>
            <th>Treasury</th>
            <th>MCap</th>
            <th>30D Trend</th>
          </tr>
        </thead>
        <tbody id="token-tbody"></tbody>
      </table>
    </div>

    <div class="how">
      <h2>How Treasury Backing Works</h2>
      <div class="how-grid">
        <div class="how-item"><div class="how-num" style="font-size:12px;font-weight:600;color:var(--green);margin-bottom:6px">01</div><div style="font-size:13px;color:var(--white);font-weight:600;margin-bottom:5px">Treasury-backed tokens</div><div style="font-size:12px;color:var(--muted);line-height:1.6">MetaDAO ICOs deposit all raised USDC into an on-chain treasury. The team draws a fixed monthly budget — every dollar is governed by futarchy.</div></div>
        <div class="how-item"><div class="how-num" style="font-size:12px;font-weight:600;color:var(--green);margin-bottom:6px">02</div><div style="font-size:13px;color:var(--white);font-weight:600;margin-bottom:5px">Backing = Treasury ÷ Supply</div><div style="font-size:12px;color:var(--muted);line-height:1.6">Each token has a claim on treasury USDC. When spot trades below backing, you're buying below the treasury floor — dissolution returns more than market price.</div></div>
        <div class="how-item"><div class="how-num" style="font-size:12px;font-weight:600;color:var(--green);margin-bottom:6px">03</div><div style="font-size:13px;color:var(--white);font-weight:600;margin-bottom:5px">Dissolution right</div><div style="font-size:12px;color:var(--muted);line-height:1.6">Any holder can propose dissolution via futarchy. If passed, treasury distributes pro-rata. This creates a soft price floor enforced by rational arbitrage.</div></div>
      </div>
    </div>
    <div class="footer">NAVgator · Treasury analytics for ownership tokens · <a href="https://metadao.fi" target="_blank">MetaDAO</a> · <a href="submit.html">Submit a Token</a> · Data via NAVgator API + Solana RPC · Not financial advice</div>
  </div>

  <!-- ══ DASHBOARD VIEW ══ -->
  <div class="dashboard" id="dashboard-view">

  <!-- Nav -->
  <nav class="nav" id="nav"></nav>

  <!-- Token header like checkprice: icon + name left, stats right -->
  <div class="token-header">
    <div class="token-header-left">
      <div class="token-header-icon" id="token-icon"></div>
      <div class="token-header-name">
        <span class="token-header-title" id="token-title-name"></span>
        <span class="token-header-ticker" id="token-title-ticker"></span>
      </div>
    </div>
  </div>

  <!-- Price + metrics row -->
  <div class="price-metrics-row">
    <div class="price-hero">
      <div class="price-hero-value" id="price-hero-val"></div>
      <div class="price-hero-change" id="price-hero-change"></div>
    </div>
    <div class="cards" id="cards"></div>
  </div>

  <!-- Chart section — dominates the page -->
  <div class="chart-section">
    <div class="chart-controls" id="chart-controls" style="justify-content:flex-end">
      <div class="chart-btn-group">
        <button class="chart-btn" data-tf="1H">1H</button>
        <button class="chart-btn" data-tf="12H">12H</button>
        <button class="chart-btn active" data-tf="1D">1D</button>
        <button class="chart-btn" data-tf="1W">1W</button>
        <button class="chart-btn" data-tf="1M">1M</button>
      </div>
      <div class="chart-btn-group" style="margin-left:12px">
        <button class="chart-btn active" id="btn-lin">LINE</button>
      </div>
      <div class="chart-btn-group" style="margin-left:12px">
        <button class="chart-btn" id="btn-nav-focus" onclick="toggleNavFocus()">NAV</button>
      </div>
    </div>
    <div id="chart-container" style="position:relative;cursor:crosshair">
      <canvas id="chart-canvas"></canvas>
      <div class="chart-tooltip" id="chart-tooltip"></div>
      <div class="chart-loading" id="chart-loading">Loading chart…</div>
    </div>
    <div class="legend">
      <span class="legend-item"><span class="legend-line" style="background:#e8e6e3"></span> <span id="leg-spot-label">Price</span></span>
      <span class="legend-item"><span class="legend-line" style="background:#e8e6e3"></span> NAV <span id="leg-strike">…</span></span>
      <span class="legend-item"><span class="legend-fill" style="background:rgba(0,229,160,0.2)"></span> Above NAV</span>
      <span class="legend-item"><span class="legend-fill" style="background:rgba(232,64,87,0.2)"></span> Below NAV</span>
      <span class="legend-item"><span class="legend-dash"><svg viewBox="0 0 20 8"><polyline points="0,4 3,1 6,7 9,1 12,7 15,1 18,4 20,4" fill="none" stroke="#e84057" stroke-width="1.5"/></svg></span> Withdrawal</span>
    </div>
  </div>

  <!-- Params below chart -->
  <div class="params" id="params" style="display:none"></div>
  <div class="params" id="treasury-flow" style="display:none"></div>

  <!-- Hidden elements for compat -->
  <div class="sub" id="sub-line" style="display:none"></div>
  <h1 id="title" style="display:none"></h1>
  <div class="desc" id="desc" style="display:none"></div>
  <div class="chart-title" id="chart-label" style="display:none"></div>

  <!-- Address section -->
  <div class="addr-section" id="addr-section"></div>

  <!-- Allowance section -->
  <div class="allowance-section" id="allowance-section" style="display:none">
    <div class="section-title" style="font-size:13px;font-weight:600;color:var(--bright);margin-bottom:12px;font-family:Inter,sans-serif">Allowance Schedule</div>
    <div class="allowance-cards" id="allowance-cards" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:10px;margin-bottom:14px"></div>
    <div class="allowance-history" id="allowance-history" style="font-size:10px;color:var(--dim);font-family:'JetBrains Mono',monospace"></div>
  </div>

  <div class="footer">
    <a href="index.html">← NAVgator Home</a> · <a href="submit.html">Submit a Token</a> · Treasury analytics for ownership tokens · Not financial advice
  </div>

  </div><!-- /dashboard-view -->
</div><!-- /wrap -->

<script>
// ═══════════════════════════════════════════════════════════════════════
// VIEW ROUTING — landing page vs dashboard
// ═══════════════════════════════════════════════════════════════════════
const _params = new URLSearchParams(window.location.search);
const _hasToken = _params.has('token');

if (_hasToken) {
  document.getElementById('dashboard-view').classList.add('active');
  document.title = 'NAVgator · Dashboard';
} else {
  document.getElementById('landing-view').classList.add('active');
  document.title = 'NAVgator — Treasury Analytics for Ownership Tokens';
}

// ═══════════════════════════════════════════════════════════════════════
// TOKEN CONFIGS
// ═══════════════════════════════════════════════════════════════════════
const TOKENS = {
  solo: { live: true,
    name: 'Solomon', ticker: 'SOLO', pair: 'SOLO/USDC',
    color: '#00e5a0', logo: 'logos/solo.jpg',
    mint: 'SoLo9oxzLDpcq1dpqAgMwgce5WqkRDtNXK7EPnbmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: '98SPcyUZ2rqM2dgjCqqSXS4gJrNTLSNUAAVCF38xYj9u',
    ammWallet: 'DzYtzoNvPbyFCzwZA6cSm9eDEEmxEB9f8AGkJXUXgnSA',
    ammWallet2: '2zsbECzM7roqnDcuv2TNGpfv5PAnuqGmMo5YPtqmUz5p',
    lockWallet: 'Bo24B7DDVtpa9VxZ4LN8FrAT7TM3cgkri41a5GjFg5Dk',
    gtPool: 'o5rJFXSKTsuws58rBMNPG8jdKdnY4Z7ouU29dyohE4g',
    raise: 8_000_000, supply: 10_000_000, icoPrice: 0.80, ath: 1.09,
    monthlyBurn: 100_000, monthlyAllowance: 100_000, realizedVol: 99, tradingDays: 85,
    genesisStrike: 0.62, genesisPut: 0.300,
    spot: 0.55, treasuryUSDC: 7_420_000, ammUSDCFixed: null,
    tge: '2025-11-18',
    draws: [
      { date: '2025-11-20', amount: 30_000, label: 'Draw #1a' },
      { date: '2025-12-17', amount: 70_000, label: 'Draw #1b' },
      { date: '2025-12-24', amount: 100_000, label: 'Draw #2' },
      { date: '2026-01-26', amount: 100_000, label: 'Draw #3' },
    ],
  },
  zkfg: { live: true,
    name: 'ZKLSOL', ticker: 'ZKFG', pair: 'ZKFG/USDC',
    color: '#9f8cfc',
    mint: 'ZKFHiLAfAFMTcDAuCtjNW54VzpERvoe7PBF9mYgmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: 'BNvDfXYG2FAyBDYD71Xr9GhKE18MbmhtjsLKsCuXho6z',
    ammWallet: '5FPGRzY9ArJFwY2Hp2y2eqMzVewyWCBox7esmpuZfCvE',
    gtPool: 'JDuK4Wp3MQM6d9QKDNDNgoELHkfAMSqbbqzbmkz19vis',
    raise: 970_000, supply: 10_000_000, icoPrice: 0.097, ath: 0.145,
    monthlyBurn: 50_000, realizedVol: 120, tradingDays: 107,
    genesisStrike: 0.097, genesisPut: 0.055,
    spot: 0.0654, treasuryUSDC: 820_000, ammUSDCFixed: null,
    tge: '2025-10-24',
    draws: [
      { date: '2025-11-24', amount: 50_000, label: 'Draw #1' },
      { date: '2025-12-24', amount: 50_000, label: 'Draw #2' },
      { date: '2026-01-24', amount: 50_000, label: 'Draw #3' },
    ],
  },
  umbra: { live: true,
    name: 'Umbra', ticker: 'UMBRA', pair: 'UMBRA/USDC',
    color: '#00c2ff', logo: 'logos/umbra.jpg',
    mint: 'PRVT6TB7uss3FrUd2D9xs2zqDBsa3GbMJMwCQsgmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: '6VsC8PuKkXm5xo54c2vbrAaSfQipkpGHqNuKTxXFySx6',
    ammWallet: 'BLkBSE96kQys7SrMioKxeMiVbeo4Ckk2Y4n1JphKxYnv',
    ammWallet2: '7dVri3qjYD3uobSZL3Zth8vSCgU6r6R2nvFsh7uVfDte',
    lockWallet: '3kX3EWm9iPB6oxFS2NJ71L6v5wzFZ8rQMEG6HC8QHJtF',
    gtPool: '7dVri3qjYD3uobSZL3Zth8vSCgU6r6R2nvFsh7uVfDte',
    gtPoolLegacy: 'BLkBSE96kQys7SrMioKxeMiVbeo4Ckk2Y4n1JphKxYnv',
    raise: 3_000_000, supply: 10_000_000, icoPrice: 0.30, ath: 2.43,
    monthlyBurn: 34_000, monthlyAllowance: 100_000, realizedVol: 110, tradingDays: 122,
    genesisStrike: 0.24, genesisPut: 0.12,
    spot: 0.76, treasuryUSDC: 3_360_000, ammUSDCFixed: null,
    tge: '2025-10-10',
    draws: [
      { date: '2025-11-10', amount: 34_000, label: 'Draw #1' },
      { date: '2025-12-10', amount: 34_000, label: 'Draw #2' },
      { date: '2026-01-10', amount: 34_000, label: 'Draw #3' },
      { date: '2026-02-10', amount: 34_000, label: 'Draw #4' },
    ],
  },
  avici: { live: true,
    name: 'Avici', ticker: 'AVICI', pair: 'AVICI/USDC',
    color: '#ff6b9d', logo: 'logos/avici.jpg',
    mint: 'BANKJmvhT8tiJRsBSS1n2HryMBPvT5Ze4HU95DUAmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: 'DGgYoUcu1aDZt4GEL5NQiducwHRGbkMWsUzsXh2j622G',
    ammWallet: '3D854kknnQhu9xVaRNV154oZ9oN2WF3tXsq3LDu7fFMn',
    ammWallet2: '5gB4NPgFB3MHFHSeKN4sbaY6t9MB8ikCe9HyiKYid4Td',
    gtPool: '5gB4NPgFB3MHFHSeKN4sbaY6t9MB8ikCe9HyiKYid4Td',
    gtPoolLegacy: '3D854kknnQhu9xVaRNV154oZ9oN2WF3tXsq3LDu7fFMn',
    raise: 3_500_000, supply: 12_900_000, icoPrice: 0.35, ath: 7.57,
    monthlyBurn: 45_000, monthlyAllowance: 100_000, realizedVol: 130, tradingDays: 114,
    genesisStrike: 0.22, genesisPut: 0.11,
    spot: 1.08, treasuryUSDC: 3_300_000, ammUSDCFixed: null,
    tge: '2025-10-18',
    draws: [
      { date: '2025-11-18', amount: 45_000, label: 'Draw #1' },
      { date: '2025-12-18', amount: 45_000, label: 'Draw #2' },
      { date: '2026-01-18', amount: 45_000, label: 'Draw #3' },
    ],
  },
  loyal: { live: true,
    name: 'Loyal', ticker: 'LOYAL', pair: 'LOYAL/USDC',
    color: '#ffd700',
    mint: 'LoyALuiy1mRSpjRBRw3iCp88T7xSD4kxTL6uYdpAmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: 'AQyyTwCKemeeMu8ZPZFxrXMbVwAYTSbBhi1w4PBrhvYE',
    ammWallet: 'GxpJkPEsPmuRCCTNnfZaDKg4X3gf4ZPgmqgFqtibaPtK',
    ammWallet2: 'BGg7WsK98rhqtTp2uSKMa2yETqgwShFAjyf1RmYqCF7n',
    buybackWallet: 'AfGAjj7TQByC2WQtCNRhsyq1WeZqmQ7oNRoGb2JbgoQg',
    gtPool: 'BGg7WsK98rhqtTp2uSKMa2yETqgwShFAjyf1RmYqCF7n',
    gtPoolLegacy: 'GxpJkPEsPmuRCCTNnfZaDKg4X3gf4ZPgmqgFqtibaPtK',
    raise: 500_000, supply: 10_000_000, icoPrice: 0.05, ath: 0.37,
    monthlyBurn: 45_000, realizedVol: 140, tradingDays: 114,
    genesisStrike: 0.038, genesisPut: 0.02,
    spot: 0.13, treasuryUSDC: 420_000, ammUSDCFixed: null,
    tge: '2025-10-23',
    draws: [
      { date: '2025-11-23', amount: 45_000, label: 'Draw #1' },
      { date: '2025-12-23', amount: 45_000, label: 'Draw #2' },
      { date: '2026-01-23', amount: 45_000, label: 'Draw #3' },
    ],
  },
  paystream: { live: false,
    name: 'Paystream', ticker: 'PAY', pair: 'PAY/USDC',
    color: '#44ddaa',
    mint: '',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: 'BpXtB2ASf2Tft97ewTd8PayXCqFQ6Wqod33qrwwfK9Vz',
    ammWallet: '6FRXzTe3HajL8Fwmmkupp8g3y3wn3g3QEjj8sABndre3',
    ammWallet2: '6F88Y6iukU9GuL8CMWnx6YT832vBymNPicJBikQWeYe4',
    buybackWallet: '3BAUsXfhhK2H1KH18GYNhUvLUsPrKWcePEA5N2UKP6VL',
    gtPool: '6F88Y6iukU9GuL8CMWnx6YT832vBymNPicJBikQWeYe4',
    gtPoolLegacy: '6FRXzTe3HajL8Fwmmkupp8g3y3wn3g3QEjj8sABndre3',
    raise: 300_000, supply: 10_000_000, icoPrice: 0.03, ath: 0.04,
    monthlyBurn: 15_000, realizedVol: 100, tradingDays: 100,
    genesisStrike: 0.024, genesisPut: 0.012,
    spot: 0.021, treasuryUSDC: 255_000, ammUSDCFixed: null,
    tge: '2025-10-27',
    draws: [
      { date: '2025-11-27', amount: 15_000, label: 'Draw #1' },
      { date: '2025-12-27', amount: 15_000, label: 'Draw #2' },
      { date: '2026-01-27', amount: 15_000, label: 'Draw #3' },
    ],
  },
  omfg: { live: true,
    name: 'Omnipair', ticker: 'OMFG', pair: 'OMFG/USDC',
    color: '#ff8855', logo: 'logos/omfg.png',
    mint: 'omfgRBnxHsNJh6YeGbGAmWenNkenzsXyBXm3WDhmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: '34rned2SLUcYjUrM9meQkuyJY4QDBcKhkcUPXCgGuXD9',
    ammWallet: '2WNhaB6TPyZ3ynJjAUM4ZZ1Hdeep8FJ3A76FjGjTVjjS',
    ammWallet2: 'BiNnErm2VDkbKGiABj9ZRUjybz879NhH2heeWE7m5M6d',
    gtPool: 'BiNnErm2VDkbKGiABj9ZRUjybz879NhH2heeWE7m5M6d',
    gtPoolLegacy: '2WNhaB6TPyZ3ynJjAUM4ZZ1Hdeep8FJ3A76FjGjTVjjS',
    raise: 500_000, supply: 10_000_000, icoPrice: 0.05, ath: 0.83,
    monthlyBurn: 25_000, monthlyAllowance: 50_000, realizedVol: 120, tradingDays: 130,
    genesisStrike: 0.04, genesisPut: 0.02,
    spot: 0.32, treasuryUSDC: 400_000, ammUSDCFixed: null,
    tge: '2025-07-28',
    draws: [
      { date: '2025-11-02', amount: 25_000, label: 'Draw #1' },
      { date: '2025-12-02', amount: 25_000, label: 'Draw #2' },
      { date: '2026-01-02', amount: 25_000, label: 'Draw #3' },
      { date: '2026-02-02', amount: 25_000, label: 'Draw #4' },
    ],
  },
  meta: { live: false,
    name: 'MetaDAO', ticker: 'META', pair: 'META/USDC',
    color: '#ff5533',
    mint: 'METAwkXcqyXKy1AtsSgJ8JiUHwGCafnZL38n3vYmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: 'BfzJzFUeE54zv6Q2QdAZR4yx7UXuYRsfkeeirrRcxDvk',
    ammWallet: 'CUPoiqkK4hxyCiJcLC4yE9AtJP1MoV1vFV2vx3jqwWeS',
    ammWallet2: 'EXpXkwcWDhjEYyC5pfNfxsu8fUtK4CDCYTZR4ApQNRzo',
    gtPool: 'EXpXkwcWDhjEYyC5pfNfxsu8fUtK4CDCYTZR4ApQNRzo',
    gtPoolLegacy: 'CUPoiqkK4hxyCiJcLC4yE9AtJP1MoV1vFV2vx3jqwWeS',
    raise: 0, supply: 22_080_000, icoPrice: 0.17, ath: 10.69,
    monthlyBurn: 0, realizedVol: 95, tradingDays: 300,
    genesisStrike: 0, genesisPut: 0,
    spot: 3.78, treasuryUSDC: 0, ammUSDCFixed: null,
    tge: '2025-04-09',
    draws: [],
    note: 'Platform token — no ICO treasury structure. Treasury analytics are approximate.',
  },
  rngr: { live: true,
    name: 'Ranger', ticker: 'RNGR', pair: 'RNGR/USDC',
    color: '#22dd88', logo: 'logos/rngr.jpg',
    mint: 'RNGRtJMbCveqCp7AC6U95KmrdKecFckaJZiWbPGmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: '55H1Q1YrHJQ93uhG4jqrBBHx3a8H7TCM8kvf2UM2g5q3',
    ammWallet: '1PAwyDkWNFCcR96GhEReXHJBv3YEFVazCaQgNicVuKv',
    ammWallet2: '59WuweKV7DAg8aUgRhNytScQxioaFYNJdWnox5FxAXFq',
    lockWallet: 'F35JE1HZMtZXXWdy3koSPRe1gGFQyqd5kpbPw2xNcjR8',
    gtPool: '59WuweKV7DAg8aUgRhNytScQxioaFYNJdWnox5FxAXFq',
    gtPoolLegacy: '1PAwyDkWNFCcR96GhEReXHJBv3YEFVazCaQgNicVuKv',
    raise: 8_000_000, supply: 10_000_000, icoPrice: 0.80, ath: 0.865,
    monthlyBurn: 250_000, monthlyAllowance: 250_000, realizedVol: 90, tradingDays: 32,
    genesisStrike: 0.47, genesisPut: 0.18,
    spot: 0.54, treasuryUSDC: 5_750_000, ammUSDCFixed: null,
    tge: '2026-01-10',
    draws: [
      { date: '2026-02-10', amount: 250_000, label: 'Draw #1' },
    ],
  },
};
// ═══════════════════════════════════════════════════════════════════════
// LANDING PAGE LOGIC
// ═══════════════════════════════════════════════════════════════════════
if (!_hasToken) {
  const landingTokens = Object.entries(TOKENS).map(([key, t]) => ({
    key, ticker: t.ticker, name: t.name, color: t.color, logo: t.logo || null,
    spot: t.spot, strike: t.raise > 0 ? t.treasuryUSDC / t.supply : 0,
    treasury: t.treasuryUSDC, mcap: t.spot * t.supply, live: t.live,
    supply: t.supply, effectiveSupply: t.supply,
    monthlyAllowance: t.monthlyAllowance || 0,
  }));

  const lfmt$ = (n) => n >= 1 ? '$' + n.toFixed(2) : n >= 0.01 ? '$' + n.toFixed(4) : '$' + n.toFixed(6);
  const lfmtK = n => n >= 1e6 ? '$' + (n / 1e6).toFixed(2) + 'M' : n >= 1e3 ? '$' + (n / 1e3).toFixed(0) + 'K' : '$' + n.toFixed(0);
  const iconHtml = (t) => t.logo ? '<div class="tt-icon"><img src="' + t.logo + '" alt="' + t.ticker + '"></div>' : '<div class="tt-icon" style="background:' + t.color + '">' + t.ticker[0] + '</div>';

  function drawSparkline(canvas, priceData, navData) {
    if ((!priceData || priceData.length < 2) && (!navData || navData.length < 2)) return;
    var ctx = canvas.getContext('2d');
    var w = canvas.width = canvas.offsetWidth * 2;
    var h = canvas.height = canvas.offsetHeight * 2;
    ctx.clearRect(0, 0, w, h);

    var pad = 4; // padding top/bottom in pixels

    // Scale Y-axis to PRICE data only so price movement is visible
    // NAV gets its own separate scaling
    var mainData = priceData && priceData.length >= 2 ? priceData : navData;
    var pMin = Math.min(...mainData), pMax = Math.max(...mainData);
    var pRange = pMax - pMin || pMax * 0.01 || 1;
    // Add 5% padding to range so lines don't touch edges
    pMin -= pRange * 0.05;
    pMax += pRange * 0.05;
    pRange = pMax - pMin;

    var first = mainData[0], last = mainData[mainData.length - 1];
    var isUp = last >= first;
    var lineColor = isUp ? '#00e5a0' : '#e84057';

    function priceToY(val) {
      return h - pad - ((val - pMin) / pRange) * (h - pad * 2);
    }

    function getPath(data, yFn) {
      var pts = [];
      for (var i = 0; i < data.length; i++) {
        var x = (i / (data.length - 1)) * w;
        pts.push([x, yFn(data[i])]);
      }
      return pts;
    }

    function strokePath(pts, color, width, dash) {
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      if (dash) ctx.setLineDash(dash);
      else ctx.setLineDash([]);
      for (var i = 0; i < pts.length; i++) {
        i === 0 ? ctx.moveTo(pts[i][0], pts[i][1]) : ctx.lineTo(pts[i][0], pts[i][1]);
      }
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // NAV line — blue staircase, behind price, using price Y-scale
    // so you can see relative position (above/below price)
    if (navData && navData.length >= 2 && priceData && priceData.length >= 2) {
      // Build staircase path (horizontal steps)
      var navStairPts = [];
      for (var i = 0; i < navData.length; i++) {
        var x = (i / (navData.length - 1)) * w;
        var y = priceToY(navData[i]);
        // Clamp Y to canvas bounds
        y = Math.max(0, Math.min(h, y));
        if (i > 0) navStairPts.push([x, navStairPts[navStairPts.length - 1][1]]); // horizontal
        navStairPts.push([x, y]); // vertical step
      }
      // Draw zigzag NAV staircase
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(255,255,255,0.5)';
      ctx.lineWidth = 1;
      ctx.lineJoin = 'round';
      // Walk along staircase segments and draw zigzag
      for (var si = 1; si < navStairPts.length; si++) {
        var sx1 = navStairPts[si - 1][0], sy1 = navStairPts[si - 1][1];
        var sx2 = navStairPts[si][0], sy2 = navStairPts[si][1];
        var sdx = sx2 - sx1, sdy = sy2 - sy1;
        var sLen = Math.sqrt(sdx * sdx + sdy * sdy);
        if (sLen < 1) continue;
        var sux = sdx / sLen, suy = sdy / sLen;
        var spx = -suy, spy = sux;
        var zStep = 3, zAmp = 1.5;
        var zSteps = Math.max(1, Math.floor(sLen / zStep));
        if (si === 1) ctx.moveTo(sx1, sy1);
        for (var zi = 1; zi <= zSteps; zi++) {
          var zt = zi / zSteps;
          var zbx = sx1 + sdx * zt, zby = sy1 + sdy * zt;
          var zdir = (zi % 2 === 1) ? 1 : -1;
          if (zi === zSteps) ctx.lineTo(sx2, sy2);
          else ctx.lineTo(zbx + spx * zAmp * zdir, zby + spy * zAmp * zdir);
        }
      }
      ctx.stroke();
    }

    // Price line
    if (priceData && priceData.length >= 2) {
      var pricePts = getPath(priceData, priceToY);

      // Glow effect
      ctx.save();
      ctx.shadowColor = lineColor;
      ctx.shadowBlur = 8;
      ctx.globalAlpha = 0.5;
      strokePath(pricePts, lineColor, 2.5, null);
      ctx.restore();

      // Crisp line
      strokePath(pricePts, lineColor, 2, null);
    } else if (navData && navData.length >= 2) {
      var navPts2 = getPath(navData, priceToY);
      var navFirst = navData[0], navLast = navData[navData.length - 1];
      var navColor = navLast >= navFirst ? '#00e5a0' : '#e84057';
      strokePath(navPts2, navColor, 2, null);
    }
  }

  let currentSort = 'treasury';
  let sortDir = 'desc'; // 'asc' or 'desc'

  const sortKeys = ['', 'name', 'price', 'nav', 'vsNav', 'treasury', 'mcap', ''];
  // Column index: 0=#, 1=Name, 2=Price, 3=NAV, 4=vsNAV, 5=Treasury, 6=MCap, 7=Trend

  function renderTable() {
    const sorted = [...landingTokens].sort((a, b) => {
      let va, vb;
      if (currentSort === 'treasury') { va = a.treasury; vb = b.treasury; }
      else if (currentSort === 'price') { va = a.spot; vb = b.spot; }
      else if (currentSort === 'nav') { va = a.strike; vb = b.strike; }
      else if (currentSort === 'vsNav') {
        va = a.strike > 0 ? (a.spot - a.strike) / a.strike : -999;
        vb = b.strike > 0 ? (b.spot - b.strike) / b.strike : -999;
      }
      else if (currentSort === 'mcap') { va = a.mcap; vb = b.mcap; }
      else if (currentSort === 'name') { return sortDir === 'asc' ? a.name.localeCompare(b.name) : b.name.localeCompare(a.name); }
      else { va = a.mcap; vb = b.mcap; }
      return sortDir === 'asc' ? va - vb : vb - va;
    });

    const tbody = document.getElementById('token-tbody');
    tbody.innerHTML = sorted.map((t, i) => {
      if (!t.live) {
        return '<tr onclick="location.href=\'index.html?token=' + t.key + '\'" style="opacity:0.4">' +
          '<td>' + (i + 1) + '</td>' +
          '<td><div class="tt-name-cell">' + iconHtml(t) + '<div><div class="tt-name">' + t.name + '</div><div class="tt-ticker">' + t.ticker + '</div></div></div></td>' +
          '<td colspan="6"><span class="tt-coming">Coming Soon</span></td></tr>';
      }
      var discPct = t.strike > 0 ? ((t.spot - t.strike) / t.strike * 100) : 0;
      var isDiscount = discPct < 0;
      var discLabel = t.strike === 0 ? '—' : (isDiscount ? '-' + Math.abs(discPct).toFixed(1) + '%' : '+' + discPct.toFixed(1) + '%');
      var discColor = t.strike === 0 ? 'var(--dim)' : (isDiscount ? '#e84057' : 'var(--green)');
      var allowLabel = t.monthlyAllowance > 0 ? lfmtK(t.monthlyAllowance) + '/mo' : '—';

      return '<tr onclick="location.href=\'index.html?token=' + t.key + '\'">' +
        '<td>' + (i + 1) + '</td>' +
        '<td><div class="tt-name-cell">' + iconHtml(t) + '<div><div class="tt-name">' + t.name + '</div><div class="tt-ticker">' + t.ticker + '</div></div></div></td>' +
        '<td><div class="tt-price">' + lfmt$(t.spot) + '</div></td>' +
        '<td style="color:var(--text)">' + (t.strike > 0 ? lfmt$(t.strike) : '—') + '</td>' +
        '<td style="color:' + discColor + ';font-weight:500">' + discLabel + '</td>' +
        '<td style="color:var(--text)">' + lfmtK(t.treasury) + '</td>' +
        '<td style="color:var(--text)">' + lfmtK(t.mcap) + '</td>' +
        '<td><canvas class="tt-sparkline" data-token="' + t.key + '"></canvas></td>' +
        '</tr>';
    }).join('');

    // Sort header highlights and arrows
    document.querySelectorAll('.token-table thead th').forEach((th, idx) => {
      th.classList.remove('sorted');
      var key = sortKeys[idx];
      // Remove old arrow
      var oldArrow = th.querySelector('.sort-arrow');
      if (oldArrow) oldArrow.remove();
      if (key === currentSort) {
        th.classList.add('sorted');
        var arrow = document.createElement('span');
        arrow.className = 'sort-arrow';
        arrow.textContent = sortDir === 'desc' ? ' ▼' : ' ▲';
        arrow.style.cssText = 'font-size:8px;opacity:0.8';
        th.appendChild(arrow);
      }
    });
  }

  renderTable();

  // Column sort click handlers
  document.querySelectorAll('.token-table thead th').forEach((th, idx) => {
    th.addEventListener('click', function() {
      var key = sortKeys[idx];
      if (!key) return; // skip # and Trend columns
      if (currentSort === key) {
        sortDir = sortDir === 'desc' ? 'asc' : 'desc';
      } else {
        currentSort = key;
        sortDir = 'desc';
      }
      renderTable();
      loadSparklines();
    });
  });

  // Fetch live data from backend API
  const API_BASE = 'https://navgator-api.vercel.app';

  async function fetchLandingData() {
    try {
      const res = await fetch(API_BASE + '/api/current');
      const data = await res.json();
      if (!data.tokens) return;
      for (const t of data.tokens) {
        if (t.error) continue;
        const lt = landingTokens.find(x => x.key === t.token);
        if (!lt) continue;
        if (t.spot > 0) { lt.spot = t.spot; lt.mcap = t.spot * (t.effectiveSupply || TOKENS[t.token].supply); }
        if (t.treasuryUSDC > 0 && t.effectiveSupply > 0) { lt.treasury = t.treasuryUSDC; lt.strike = t.treasuryUSDC / t.effectiveSupply; lt.effectiveSupply = t.effectiveSupply; }
      }
      renderTable();
      loadSparklines();
      // Update header stats
      var totalTreasury = landingTokens.filter(function(t) { return t.live; }).reduce(function(sum, t) { return sum + (t.treasury || 0); }, 0);
      var el = document.getElementById('landing-nav-total');
      if (el) el.textContent = totalTreasury >= 1e6 ? '$' + (totalTreasury / 1e6).toFixed(2) + 'M' : '$' + Math.round(totalTreasury).toLocaleString();
      console.log('NAVgator landing: live data loaded from API');
    } catch (e) { console.warn('API fetch failed:', e.message); }
  }

  // Load sparklines from NAV history (shows both price + NAV)
  async function loadSparklines() {
    for (const t of landingTokens) {
      if (!t.live) continue;
      try {
        // Fetch OHLCV 12H candles for granular price data (30 days = ~60 candles)
        var ohlcvRes = await fetch(API_BASE + '/api/ohlcv?token=' + t.key + '&tf=12H');
        var ohlcvData = await ohlcvRes.json();
        var prices = [];
        if (ohlcvData && ohlcvData.data && ohlcvData.data.items && ohlcvData.data.items.length > 1) {
          // Take last 60 candles (~30 days of 12H data)
          var items = ohlcvData.data.items.slice(-60);
          prices = items.map(function(c) { return c.c; }).filter(function(p) { return p > 0; });
        }
        // Also fetch NAV history for the NAV line
        var navs = [];
        try {
          var histRes = await fetch(API_BASE + '/api/history?token=' + t.key + '&days=30');
          var histData = await histRes.json();
          if (histData.history && histData.history.length > 1) {
            navs = histData.history.map(function(h) { return h.nav; }).filter(function(n) { return n > 0; });
          }
        } catch (e2) {}
        // Fallback: if OHLCV failed, use history spot prices
        if (prices.length < 2) {
          try {
            var histRes2 = await fetch(API_BASE + '/api/history?token=' + t.key + '&days=30');
            var histData2 = await histRes2.json();
            if (histData2.history && histData2.history.length > 1) {
              prices = histData2.history.map(function(h) { return h.spot; }).filter(function(s) { return s > 0; });
            }
          } catch (e3) {}
        }
        var canvas = document.querySelector('canvas[data-token="' + t.key + '"]');
        if (canvas && (prices.length >= 2 || navs.length >= 2)) drawSparkline(canvas, prices, navs);
      } catch (e) {}
    }
  }

  fetchLandingData();
  setTimeout(loadSparklines, 500);
}

// ═══════════════════════════════════════════════════════════════════════
// DASHBOARD LOGIC (only when ?token= is present)
// ═══════════════════════════════════════════════════════════════════════
if (_hasToken) {
const params = new URLSearchParams(window.location.search);
const tokenKey = (params.get('token') || 'solo').toLowerCase();
const CFG = TOKENS[tokenKey] || TOKENS.solo;
const API_BASE_DASH = 'https://navgator-api.vercel.app';

document.title = `NAVgator · ${CFG.ticker}/USDC — Treasury Analytics`;

// Build nav — dim non-live tokens
const navEl = document.getElementById('nav');
const LIVE_KEYS = new Set(Object.entries(TOKENS).filter(([k,v]) => v.live).map(([k]) => k));
let navHTML = '<a href="index.html" class="nav-brand">NAV<span>gator</span></a><span class="nav-sep">·</span><div class="nav-tokens">';
for (const [key, tok] of Object.entries(TOKENS)) {
  const isLive = LIVE_KEYS.has(key);
  const dimStyle = !isLive ? 'opacity:0.35;pointer-events:none;' : '';
  navHTML += `<a class="nav-tok${key===tokenKey?' active':''}" href="index.html?token=${key}" style="${dimStyle}${key===tokenKey?'border-color:'+tok.color+';color:'+tok.color:''}">${tok.ticker}</a>`;
}
navHTML += '</div>';
navEl.innerHTML = navHTML;

// If token is not live, show coming soon overlay and stop
if (!CFG.live) {
  document.getElementById('sub-line').textContent = 'COMING SOON';
  document.getElementById('title').textContent = CFG.name + ' — Coming Soon';
  document.getElementById('desc').innerHTML = `<b>${CFG.ticker}</b> dashboard is under development. Treasury tracking, price charts, and analytics will be available soon.`;
  document.getElementById('cards').innerHTML = '';
  document.getElementById('params').innerHTML = '';
  document.getElementById('chart-loading').textContent = 'Coming Soon';
  const scs = document.getElementById('strike-chart-section');
  if (scs) scs.style.display = 'none';
}

// ═══════════════════════════════════════════════════════════════════════
// MATH
// ═══════════════════════════════════════════════════════════════════════
const pDec = (v) => v >= 1 ? 2 : v >= 0.01 ? 4 : 6;
const fmt$ = (n,d) => '$'+n.toFixed(d !== undefined ? d : pDec(n));
const fmtM = n => n>=1e6?'$'+(n/1e6).toFixed(1)+'M':n>=1e3?'$'+(n/1e3).toFixed(0)+'K':fmt$(n,2);
const fmtBurn = n => n>=1e6?'$'+(n/1e6).toFixed(1)+'M':n>=1e3?'$'+(n/1e3).toFixed(0)+'K':'$'+n;

// ═══════════════════════════════════════════════════════════════════════
// LIVE DATA FETCHERS
// ═══════════════════════════════════════════════════════════════════════
async function fetchOHLCV() {
  var candles = await fetchCandlesForTF('1D');
  return candles.length > 0 ? candles : null;
}

async function fetchFromAPI() {
  try {
    const res = await fetch(API_BASE_DASH + '/api/current?token=' + tokenKey);
    const data = await res.json();
    if (data.error) return false;
    if (data.spot > 0) CFG.spot = data.spot;
    if (data.treasuryUSDC > 0) CFG.treasuryUSDC = data.treasuryUSDC;
    if (data.effectiveSupply > 0) CFG.effectiveSupply = data.effectiveSupply;
    if (data.onChainSupply > 0) CFG.onChainSupply = data.onChainSupply;
    if (data.lockedTokens > 0) CFG.lockTokenBalance = data.lockedTokens;
    if (data.ammTokens > 0) CFG.ammTokens = data.ammTokens;
    if (data.daoTokens > 0) CFG.daoTokenBalance = data.daoTokens;
    if (data.buybackTokens > 0) CFG.buybackTokenBalance = data.buybackTokens;
    if (data.futAmmTokens >= 0) CFG.futAmmTokens = data.futAmmTokens;
    if (data.metAmmTokens >= 0) CFG.metAmmTokens = data.metAmmTokens;
    if (data.meteoraPoolUSDC >= 0) CFG.metAmmUSDC = data.meteoraPoolUSDC;
    if (data.futAmmUSDC >= 0) CFG.futAmmUSDC = data.futAmmUSDC;
    if (data.daoUSDC >= 0) CFG.daoUSDC = data.daoUSDC;
    console.log('API data:', data);
    return true;
  } catch (e) { console.warn('API fetch failed:', e.message); return false; }
}

// ═══════════════════════════════════════════════════════════════════════
// FALLBACK SIMULATED DATA
// ═══════════════════════════════════════════════════════════════════════


// ═══════════════════════════════════════════════════════════════════════
// CHART — Custom Canvas
// ═══════════════════════════════════════════════════════════════════════
var _allCandles = {};
var _navPerToken = 0;
var _navHistory = [];
var _chartTF = '1D';
var _allowancePayments = [];
var _chartScale = 'linear'; // 'linear' or 'log'
var _premFmt = 'pct'; // 'pct' or 'x'
var _navFocus = false;

function setChartScale(scale) {
  _chartScale = scale;
  document.getElementById('btn-lin').classList.toggle('active', scale === 'linear');
  document.getElementById('btn-log').classList.toggle('active', scale === 'log');
  drawChart();
}

function toggleNavFocus() {
  _navFocus = !_navFocus;
  document.getElementById('btn-nav-focus').classList.toggle('active', _navFocus);
  drawChart();
}

function togglePremiumFormat() {
  _premFmt = _premFmt === 'pct' ? 'x' : 'pct';
  var el = document.getElementById('prem-val');
  var sub = document.getElementById('prem-sub');
  if (!el || !CFG) return;
  var supplyForNAV = CFG.effectiveSupply || CFG.supply;
  var strike = CFG.treasuryUSDC / supplyForNAV;
  var ratio = strike > 0 ? CFG.spot / strike : 0;
  var discPct = strike > 0 ? ((CFG.spot - strike) / strike * 100) : 0;
  var isDiscount = discPct < 0;
  if (_premFmt === 'x') {
    el.textContent = ratio.toFixed(2) + 'x';
    sub.textContent = (isDiscount ? 'of treasury floor' : 'of treasury floor') + ' · tap to toggle';
  } else {
    el.textContent = isDiscount ? Math.abs(discPct).toFixed(1) + '%' : '+' + discPct.toFixed(0) + '%';
    sub.textContent = (isDiscount ? 'below treasury floor' : 'above treasury floor') + ' · tap to toggle';
  }
}

// Chart state
var _chart = {
  canvas: null, ctx: null, tooltip: null,
  priceData: [], navData: [],
  viewStart: 0, viewEnd: 1, // 0-1 range for zoom/pan
  isDragging: false, dragStartX: 0, dragStartView: 0,
  isYDragging: false, yDragStartY: 0, yDragStartZoom: 1, yDragStartOffset: 0,
  yZoom: 1, yOffset: 0, // Y-axis zoom (1=auto) and vertical offset
  width: 0, height: 420,
  padding: { top: 20, right: 70, bottom: 30, left: 10 },
};

// Fetch historical NAV data from backend
async function fetchNAVHistory() {
  try {
    var res = await fetch(API_BASE_DASH + '/api/history?token=' + tokenKey + '&days=365');
    var json = await res.json();
    if (json.history && json.history.length > 0) {
      _navHistory = json.history.map(function(h) {
        return {
          time: Math.floor(new Date(h.date).getTime() / 1000),
          value: h.nav,
          treasury: h.treasury,
          supply: h.supply,
        };
      });
      var seen = {};
      _navHistory = _navHistory.filter(function(h) {
        if (seen[h.time]) return false;
        seen[h.time] = true;
        return true;
      });
      _navHistory.sort(function(a, b) { return a.time - b.time; });
    }
  } catch (e) { console.error('NAV history fetch error:', e); }
}

async function fetchCandlesForTF(tf) {
  if (_allCandles[tf]) return _allCandles[tf];
  if (!CFG.mint) return [];
  try {
    var tge = new Date(CFG.tge || '2025-01-01');
    var now = new Date();
    var birdeyeTF = { '12H': '12H', '1D': '1D', '1W': '1W', '1M': '1M' }[tf] || '1D';
    var url = API_BASE_DASH + '/api/ohlcv?token=' + tokenKey + '&tf=' + birdeyeTF + '&time_from=' + Math.floor(tge.getTime() / 1000) + '&time_to=' + Math.floor(now.getTime() / 1000);
    var resp = await fetch(url);
    var json = await resp.json();
    if (!json.data || !json.data.items) return [];
    var candles = json.data.items.map(function(c) {
      return { date: new Date(c.unixTime * 1000), time: c.unixTime, open: c.o, high: c.h, low: c.l, close: c.c, price: c.c };
    });
    _allCandles[tf] = candles;
    return candles;
  } catch (e) { return []; }
}

function buildChart(candles, navPerToken) {
  var container = document.getElementById('chart-container');
  var canvas = document.getElementById('chart-canvas');
  var tooltip = document.getElementById('chart-tooltip');
  if (!canvas || !container) { console.error('Chart: no canvas or container'); return; }

  var dpr = window.devicePixelRatio || 1;
  var w = container.clientWidth || 800;
  var h = _chart.height;

  canvas.width = w * dpr;
  canvas.height = h * dpr;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';

  _chart.canvas = canvas;
  _chart.ctx = canvas.getContext('2d');
  _chart.ctx.scale(dpr, dpr);
  _chart.tooltip = tooltip;
  _chart.width = w;

  // Build price data array with TGE start
  var priceData = [];
  if (candles && candles.length > 0) {
    priceData = candles.map(function(c) {
      return { time: c.time || Math.floor(c.date.getTime() / 1000), value: c.close || c.price };
    });
  }

  // Inject TGE point
  if (CFG.tge && CFG.icoPrice > 0) {
    var tgeTs = Math.floor(new Date(CFG.tge + 'T00:00:00Z').getTime() / 1000);
    if (priceData.length > 0 && tgeTs <= priceData[0].time) {
      priceData.unshift({ time: tgeTs, value: CFG.icoPrice });
    } else if (priceData.length === 0) {
      priceData.push({ time: tgeTs, value: CFG.icoPrice });
    }
  }

  _chart.priceData = priceData;

  // Append live spot price so price line extends to current time
  if (CFG.spot > 0 && priceData.length > 0) {
    var nowTs = Math.floor(Date.now() / 1000);
    var lastCandle = priceData[priceData.length - 1];
    if (nowTs > lastCandle.time) {
      priceData.push({ time: nowTs, value: CFG.spot });
    }
  }

  // Cap NAV history with current live NAV
  var navData = _navHistory.slice();
  if (navPerToken > 0 && navData.length > 0) {
    var nowTs = Math.floor(Date.now() / 1000);
    navData.push({ time: nowTs, value: navPerToken, treasury: CFG.treasuryUSDC, supply: CFG.effectiveSupply || CFG.supply });
  }

  // Split into estimated (pre-accurate) and accurate data
  // Accurate data starts Feb 15 2026 when cron snapshots became reliable
  var accurateCutoff = Math.floor(new Date('2026-02-15T00:00:00Z').getTime() / 1000);
  var estimatedNav = []; // TGE → first accurate point (diagonal)
  var accurateNav = []; // real cron snapshots (staircase)

  for (var i = 0; i < navData.length; i++) {
    if (navData[i].time < accurateCutoff) {
      // Skip pre-accurate points, we'll use TGE as start
    } else {
      accurateNav.push(navData[i]);
    }
  }
  // Build simulated NAV from TGE to first accurate point
  // Uses constant-product AMM model: as price changes, USDC in AMM rebalances
  if (CFG.tge && CFG.icoPrice > 0 && accurateNav.length > 0) {
    var tgeTs = Math.floor(new Date(CFG.tge + 'T00:00:00Z').getTime() / 1000);
    var firstAccTs = accurateNav[0].time;

    // AMM setup: 20% of raise paired with tokens
    var ammPct = 0.20;
    var initialAmmUsdc = CFG.raise * ammPct;
    var initialAmmTokens = 2_900_000; // SOLO-specific for now
    var ammK = initialAmmUsdc * initialAmmTokens; // constant product k
    var idleUsdc = CFG.raise * (1 - ammPct);
    var holderSupply = CFG.supply || 10_000_000;
    var monthlyBurn = CFG.monthlyBurn || 0;

    // Only use AMM simulation for tokens that have AMM data
    if (CFG.raise && _chart.priceData.length > 0) {
      // Build draw schedule as timestamps
      var drawEvents = [];
      if (CFG.draws) {
        for (var di = 0; di < CFG.draws.length; di++) {
          var drawTs = Math.floor(new Date(CFG.draws[di].date + 'T00:00:00Z').getTime() / 1000);
          if (drawTs > tgeTs && drawTs < firstAccTs) {
            drawEvents.push({ time: drawTs, amount: CFG.draws[di].amount });
          }
        }
        drawEvents.sort(function(a, b) { return a.time - b.time; });
      }

      // Walk through price data points between TGE and first accurate NAV
      var simPoints = [];
      var cumulativeDraws = 0;
      var drawIdx = 0;

      // Add TGE point
      var tgeAmmUsdc = initialAmmUsdc;
      var tgeNav = (idleUsdc + tgeAmmUsdc) / holderSupply;
      simPoints.push({ time: tgeTs, value: tgeNav });

      for (var pi = 0; pi < _chart.priceData.length; pi++) {
        var pt = _chart.priceData[pi];
        if (pt.time <= tgeTs || pt.time >= firstAccTs) continue;

        // Apply any draws that occurred before this price point
        while (drawIdx < drawEvents.length && drawEvents[drawIdx].time <= pt.time) {
          cumulativeDraws += drawEvents[drawIdx].amount;
          drawIdx++;
          // Insert a NAV drop point at the draw time
          var drawTime = drawEvents[drawIdx - 1].time;
          var prevPrice = pt.value; // approximate with current price
          // Find closest price before draw
          for (var pj = pi - 1; pj >= 0; pj--) {
            if (_chart.priceData[pj].time <= drawTime) { prevPrice = _chart.priceData[pj].value; break; }
          }
          var drawIdle = Math.max(0, idleUsdc - cumulativeDraws);
          var drawAmm = Math.sqrt(ammK * prevPrice);
          drawAmm = Math.min(drawAmm, CFG.raise * 0.8);
          drawAmm = Math.max(drawAmm, initialAmmUsdc * 0.1);
          simPoints.push({ time: drawTime, value: (drawIdle + drawAmm) / holderSupply });
        }

        var currentIdle = Math.max(0, idleUsdc - cumulativeDraws);

        // AMM rebalance: at price P, USDC in pool = sqrt(k * P)
        var price = pt.value;
        var ammUsdc = Math.sqrt(ammK * price);
        ammUsdc = Math.min(ammUsdc, CFG.raise * 0.8);
        ammUsdc = Math.max(ammUsdc, initialAmmUsdc * 0.1);

        var nav = (currentIdle + ammUsdc) / holderSupply;
        simPoints.push({ time: pt.time, value: nav });
      }

      // Connect to first accurate point
      if (simPoints.length > 0) {
        simPoints.push(accurateNav[0]);
      }
      estimatedNav = simPoints;
    } else {
      // Fallback: straight line
      estimatedNav.push({ time: tgeTs, value: CFG.icoPrice });
      estimatedNav.push(accurateNav[0]);
    }
  }

  // Deduplicate accurate NAV to only keep points where value changes (clean staircase)
  var cleanNav = [];
  for (var i = 0; i < accurateNav.length; i++) {
    if (i === 0) { cleanNav.push(accurateNav[i]); continue; }
    if (Math.abs(accurateNav[i].value - accurateNav[i - 1].value) > 0.000001) {
      if (cleanNav[cleanNav.length - 1].time !== accurateNav[i - 1].time) {
        cleanNav.push(accurateNav[i - 1]);
      }
      cleanNav.push(accurateNav[i]);
    }
  }
  // Always include the last point
  if (accurateNav.length > 0 && (cleanNav.length === 0 || cleanNav[cleanNav.length - 1].time !== accurateNav[accurateNav.length - 1].time)) {
    cleanNav.push(accurateNav[accurateNav.length - 1]);
  }

  // Store event markers — use actual USDC transfers from allowance API, not snapshot diffs
  // _allowancePayments contains real DAO wallet withdrawals from the usdc_transfers table
  _chart.navEvents = [];
  if (_allowancePayments && _allowancePayments.length > 0) {
    for (var i = 0; i < _allowancePayments.length; i++) {
      var pay = _allowancePayments[i];
      var payTs = Math.floor(new Date(pay.date + 'T12:00:00Z').getTime() / 1000);
      // Find the NAV value closest to this payment date
      var navAtTime = navPerToken;
      for (var ni = accurateNav.length - 1; ni >= 0; ni--) {
        if (accurateNav[ni].time <= payTs) {
          navAtTime = accurateNav[ni].value;
          break;
        }
      }
      _chart.navEvents.push({
        time: payTs,
        value: navAtTime,
        treasury: 0,
        supply: 0,
        outflow: pay.amount
      });
    }
  }
  _chart.navEvents.sort(function(a, b) { return a.time - b.time; });

  _chart.estimatedNav = estimatedNav;
  _chart.navData = cleanNav;
  _chart.viewStart = 0;
  _chart.viewEnd = 1;

  drawChart();
  attachChartEvents(container);
}

function getVisibleData(data) {
  if (data.length === 0) return [];
  var start = Math.floor(_chart.viewStart * data.length);
  var end = Math.ceil(_chart.viewEnd * data.length);
  return data.slice(Math.max(0, start), Math.min(data.length, end));
}

function getTimeRange() {
  var allTimes = [];
  _chart.priceData.forEach(function(d) { allTimes.push(d.time); });
  _chart.navData.forEach(function(d) { allTimes.push(d.time); });
  if (allTimes.length === 0) return { min: 0, max: 1 };
  allTimes.sort(function(a, b) { return a - b; });
  var tMin = allTimes[0];
  var tMax = allTimes[allTimes.length - 1];
  var range = tMax - tMin || 1;
  return {
    min: tMin + range * _chart.viewStart,
    max: tMin + range * _chart.viewEnd,
    fullMin: tMin,
    fullMax: tMax,
  };
}

function drawChart() {
  var ctx = _chart.ctx;
  var w = _chart.width;
  var h = _chart.height;
  var pad = _chart.padding;
  if (!ctx) return;

  ctx.clearRect(0, 0, w, h);

  var tr = getTimeRange();
  var tMin = tr.min, tMax = tr.max;
  var tRange = tMax - tMin || 1;

  // Collect visible values for Y range
  var allVals = [];
  _chart.priceData.forEach(function(d) {
    if (d.time >= tMin && d.time <= tMax) allVals.push(d.value);
  });
  // For NAV, include interpolated value at visible boundaries (staircase has few points)
  _chart.navData.forEach(function(d) {
    if (d.time >= tMin && d.time <= tMax) allVals.push(d.value);
  });
  // Also include the NAV value that's active at the start of the visible range
  for (var ni = _chart.navData.length - 1; ni >= 0; ni--) {
    if (_chart.navData[ni].time <= tMin) { allVals.push(_chart.navData[ni].value); break; }
  }
  // And the NAV value active at the end
  for (var ni = _chart.navData.length - 1; ni >= 0; ni--) {
    if (_chart.navData[ni].time <= tMax) { allVals.push(_chart.navData[ni].value); break; }
  }
  if (allVals.length === 0) {
    ctx.fillStyle = '#555560';
    ctx.font = '12px Inter, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Chart data unavailable', w / 2, h / 2);
    return;
  }

  var vMin = Math.min.apply(null, allVals);
  var vMax = Math.max.apply(null, allVals);

  // NAV Focus mode: constrain Y range around NAV values
  if (_navFocus) {
    var navVals = [];
    // Collect visible accurate NAV values
    for (var ni = 0; ni < _chart.navData.length; ni++) {
      if (_chart.navData[ni].time >= tMin && _chart.navData[ni].time <= tMax) {
        navVals.push(_chart.navData[ni].value);
      }
    }
    // Include simulated NAV values in visible range
    var estData = _chart.estimatedNav || [];
    for (var ei = 0; ei < estData.length; ei++) {
      if (estData[ei].time >= tMin && estData[ei].time <= tMax) {
        navVals.push(estData[ei].value);
      }
    }
    // Also include last NAV before visible range
    for (var ni = _chart.navData.length - 1; ni >= 0; ni--) {
      if (_chart.navData[ni].time <= tMin) { navVals.push(_chart.navData[ni].value); break; }
    }
    if (navVals.length > 0) {
      var navMin = Math.min.apply(null, navVals);
      var navMax = Math.max.apply(null, navVals);
      var navMid = (navMin + navMax) / 2;
      var navSpread = (navMax - navMin) || navMid * 0.1;
      // Show 3x the NAV spread centered on NAV midpoint
      vMin = navMid - navSpread * 1.5;
      vMax = navMid + navSpread * 1.5;
      if (vMin < 0) vMin = 0;
    }
  }

  var vPad = (vMax - vMin) * 0.1 || 0.01;
  vMin -= vPad;
  vMax += vPad;

  // Store base range before zoom for drag limits
  _chart._vBaseRange = vMax - vMin;

  // Apply Y-axis manual zoom/offset (from dragging the price scale)
  if (_chart.yZoom !== 1 || _chart.yOffset !== 0) {
    var vMid = (vMin + vMax) / 2 + _chart.yOffset;
    var vHalf = ((vMax - vMin) / 2) / _chart.yZoom;
    vMin = vMid - vHalf;
    vMax = vMid + vHalf;
  }

  // Ensure vMin > 0 for log scale
  if (_chartScale === 'log' && vMin <= 0) vMin = 0.001;
  var vRange = vMax - vMin || 1;

  var plotW = w - pad.left - pad.right;
  var plotH = h - pad.top - pad.bottom;

  var tx = function(t) { return pad.left + ((t - tMin) / tRange) * plotW; };
  var ty;
  if (_chartScale === 'log') {
    var logMin = Math.log(vMin);
    var logMax = Math.log(vMax);
    var logRange = logMax - logMin || 1;
    ty = function(v) {
      var logV = Math.log(Math.max(v, vMin));
      return pad.top + (1 - (logV - logMin) / logRange) * plotH;
    };
  } else {
    ty = function(v) { return pad.top + (1 - (v - vMin) / vRange) * plotH; };
  }

  // Grid lines
  ctx.strokeStyle = 'rgba(34,34,40,0.8)';
  ctx.lineWidth = 1;
  var gridSteps = 10;
  for (var i = 0; i <= gridSteps; i++) {
    var gy = pad.top + (i / gridSteps) * plotH;
    ctx.beginPath(); ctx.moveTo(pad.left, gy); ctx.lineTo(w - pad.right, gy); ctx.stroke();
    // Y labels — use log-spaced values if in log mode
    var gVal;
    if (_chartScale === 'log') {
      var logVal = logMax - (i / gridSteps) * logRange;
      gVal = Math.exp(logVal);
    } else {
      gVal = vMax - (i / gridSteps) * vRange;
    }
    ctx.fillStyle = '#555560';
    ctx.font = '10px Inter, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('$' + gVal.toFixed(gVal >= 1 ? 2 : 4), w - pad.right + 8, gy + 3);
  }

  // Time labels
  ctx.fillStyle = '#555560';
  ctx.font = '10px Inter, sans-serif';
  ctx.textAlign = 'center';
  var tSteps = Math.max(1, Math.min(6, Math.floor(plotW / 100)));
  for (var i = 0; i <= tSteps; i++) {
    var tVal = tMin + (i / tSteps) * tRange;
    var date = new Date(tVal * 1000);
    var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    var label = months[date.getUTCMonth()] + ' ' + date.getUTCDate();
    ctx.fillText(label, tx(tVal), h - 6);
  }

  // Helper: filter data to visible range and convert to pixel coords
  // Includes boundary interpolation so fills/lines work at any zoom level
  function toPixels(data) {
    var pts = [];
    var lastBefore = null;
    var firstAfter = null;
    for (var i = 0; i < data.length; i++) {
      if (data[i].time < tMin) {
        lastBefore = data[i];
      } else if (data[i].time <= tMax) {
        pts.push({ x: tx(data[i].time), y: ty(data[i].value), value: data[i].value, time: data[i].time });
      } else if (!firstAfter) {
        firstAfter = data[i];
      }
    }
    // Inject interpolated point at left edge
    if (lastBefore) {
      var nextPt = pts.length > 0 ? pts[0] : firstAfter;
      if (nextPt) {
        var frac = (tMin - lastBefore.time) / (nextPt.time - lastBefore.time);
        var interpVal = lastBefore.value + frac * (nextPt.value - lastBefore.value);
        pts.unshift({ x: tx(tMin), y: ty(interpVal), value: interpVal, time: tMin });
      } else {
        pts.unshift({ x: tx(tMin), y: ty(lastBefore.value), value: lastBefore.value, time: tMin });
      }
    }
    // Inject interpolated point at right edge
    if (pts.length > 0) {
      var lastPt = pts[pts.length - 1];
      if (lastPt.time < tMax && firstAfter) {
        var frac2 = (tMax - lastPt.time) / (firstAfter.time - lastPt.time);
        var interpVal2 = lastPt.value + frac2 * (firstAfter.value - lastPt.value);
        pts.push({ x: tx(tMax), y: ty(interpVal2), value: interpVal2, time: tMax });
      }
    }
    return pts;
  }

  // For NAV staircase: include the last point before visible range so the line extends in
  function toPixelsNav(data) {
    var pts = [];
    var lastBefore = null;
    for (var i = 0; i < data.length; i++) {
      if (data[i].time < tMin) {
        lastBefore = data[i];
      } else if (data[i].time <= tMax) {
        pts.push({ x: tx(data[i].time), y: ty(data[i].value), value: data[i].value, time: data[i].time });
      }
    }
    // Inject the last point before visible range at the left edge
    if (lastBefore) {
      pts.unshift({ x: tx(tMin), y: ty(lastBefore.value), value: lastBefore.value, time: tMin });
    }
    // Extend the last visible point to the last price data point (not chart edge)
    if (pts.length > 0 && _chart.priceData && _chart.priceData.length > 0) {
      var lastPriceTime = _chart.priceData[_chart.priceData.length - 1].time;
      var last = pts[pts.length - 1];
      var extendTo = Math.min(tMax, lastPriceTime);
      if (last.time < extendTo) {
        pts.push({ x: tx(extendTo), y: last.y, value: last.value, time: extendTo });
      }
    }
    return pts;
  }

  var pricePts = toPixels(_chart.priceData);
  var navPts = toPixelsNav(_chart.navData);
  var estPts = toPixels(_chart.estimatedNav || []);

  // Draw fill between price and NAV lines (gradient: strong at price, fading toward NAV)
  // Combine estimated diagonal + accurate staircase into one NAV lookup function
  var hasNav = (navPts.length > 0 || estPts.length >= 2);
  if (pricePts.length > 1 && hasNav) {

    // NAV Y at any X position — checks accurate staircase first, then simulated NAV
    function navYAtX(xPos) {
      // Check accurate staircase first
      if (navPts.length > 0 && xPos >= navPts[0].x) {
        for (var ni = navPts.length - 1; ni >= 0; ni--) {
          if (xPos >= navPts[ni].x) return navPts[ni].y;
        }
        return navPts[0].y;
      }
      // Fall back to simulated NAV (walk through points, interpolate between them)
      if (estPts.length >= 2) {
        if (xPos <= estPts[0].x) return estPts[0].y;
        if (xPos >= estPts[estPts.length - 1].x) return estPts[estPts.length - 1].y;
        for (var ei = 1; ei < estPts.length; ei++) {
          if (xPos <= estPts[ei].x) {
            var t = (xPos - estPts[ei - 1].x) / (estPts[ei].x - estPts[ei - 1].x);
            return estPts[ei - 1].y + t * (estPts[ei].y - estPts[ei - 1].y);
          }
        }
        return estPts[estPts.length - 1].y;
      }
      // Fallback
      if (navPts.length > 0) return navPts[0].y;
      return pad.top + plotH / 2;
    }

    // Collect all NAV Y values for gradient bounds
    var allNavYVals = [];
    for (var i = 0; i < pricePts.length; i++) {
      allNavYVals.push(navYAtX(pricePts[i].x));
    }
    var allPriceY = pricePts.map(function(p) { return p.y; });
    var minPriceY = Math.min.apply(null, allPriceY);
    var maxNavY = Math.max.apply(null, allNavYVals);
    var maxPriceY = Math.max.apply(null, allPriceY);
    var minNavY = Math.min.apply(null, allNavYVals);

    ctx.save();

    // Gradient fills — stronger at price line, fading toward NAV line
    var aboveGrad = ctx.createLinearGradient(0, Math.min.apply(null, allPriceY), 0, minNavY);
    aboveGrad.addColorStop(0, 'rgba(0,229,160,0.25)');
    aboveGrad.addColorStop(1, 'rgba(0,229,160,0.02)');

    var belowGrad = ctx.createLinearGradient(0, Math.max.apply(null, allPriceY), 0, maxNavY);
    belowGrad.addColorStop(0, 'rgba(232,64,87,0.25)');
    belowGrad.addColorStop(1, 'rgba(232,64,87,0.02)');

    // Draw above-NAV fill
    ctx.beginPath();
    for (var i = 0; i < pricePts.length; i++) {
      var navY = navYAtX(pricePts[i].x);
      var clippedY = Math.min(pricePts[i].y, navY);
      if (i === 0) ctx.moveTo(pricePts[i].x, clippedY);
      else ctx.lineTo(pricePts[i].x, clippedY);
    }
    for (var i = pricePts.length - 1; i >= 0; i--) {
      ctx.lineTo(pricePts[i].x, navYAtX(pricePts[i].x));
    }
    ctx.closePath();
    ctx.fillStyle = aboveGrad;
    ctx.fill();

    // Draw below-NAV fill
    ctx.beginPath();
    for (var i = 0; i < pricePts.length; i++) {
      var navY = navYAtX(pricePts[i].x);
      var clippedY = Math.max(pricePts[i].y, navY);
      if (i === 0) ctx.moveTo(pricePts[i].x, clippedY);
      else ctx.lineTo(pricePts[i].x, clippedY);
    }
    for (var i = pricePts.length - 1; i >= 0; i--) {
      ctx.lineTo(pricePts[i].x, navYAtX(pricePts[i].x));
    }
    ctx.closePath();
    ctx.fillStyle = belowGrad;
    ctx.fill();

    ctx.restore();
  }

  // Draw price line (white)
  if (pricePts.length > 1) {
    ctx.beginPath();
    ctx.strokeStyle = '#e8e6e3';
    ctx.lineWidth = 2;
    ctx.moveTo(pricePts[0].x, pricePts[0].y);
    for (var i = 1; i < pricePts.length; i++) {
      ctx.lineTo(pricePts[i].x, pricePts[i].y);
    }
    ctx.stroke();
  }

  // Draw fill between NAV and bottom of chart (subtle)
  if (navPts.length > 1) {
    var bottomY = pad.top + plotH;
    ctx.beginPath();
    ctx.moveTo(navPts[0].x, navPts[0].y);
    for (var i = 1; i < navPts.length; i++) {
      ctx.lineTo(navPts[i].x, navPts[i - 1].y);
      ctx.lineTo(navPts[i].x, navPts[i].y);
    }
    ctx.lineTo(navPts[navPts.length - 1].x, bottomY);
    ctx.lineTo(navPts[0].x, bottomY);
    ctx.closePath();
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    ctx.fill();
  }

  // Draw simulated NAV line from TGE to first accurate point
  var estData = _chart.estimatedNav || [];
  if (estData.length >= 2) {
    var estPtsVis = toPixels(estData);
    if (estPtsVis.length >= 2) {
      ctx.beginPath();
      ctx.strokeStyle = '#e8e6e3';
      ctx.lineWidth = 1;
      ctx.moveTo(estPtsVis[0].x, estPtsVis[0].y);
      for (var i = 1; i < estPtsVis.length; i++) {
        ctx.lineTo(estPtsVis[i].x, estPtsVis[i].y);
      }
      ctx.stroke();
    }
  }

  // Draw NAV line — zigzag white staircase, same weight as price line
  // Dashes turn red near withdrawal events
  if (navPts.length > 1) {
    var lastPriceX = (pricePts.length > 0) ? pricePts[pricePts.length - 1].x : (pad.left + plotW);

    // Build list of withdrawal X positions for coloring
    var withdrawXs = [];
    if (_chart.navEvents) {
      for (var ei = 0; ei < _chart.navEvents.length; ei++) {
        var evt = _chart.navEvents[ei];
        if (evt.time >= tMin && evt.time <= tMax) {
          withdrawXs.push(tx(evt.time));
        }
      }
    }

    // Check if an X position is near a withdrawal (within 15px)
    function isNearWithdraw(x) {
      for (var wi = 0; wi < withdrawXs.length; wi++) {
        if (Math.abs(x - withdrawXs[wi]) < 15) return true;
      }
      return false;
    }

    // Draw staircase segment by segment with dashed style
    // Each segment: horizontal from prev to next X, then vertical step
    var allSegments = [];
    // First point
    allSegments.push({ x1: navPts[0].x, y1: navPts[0].y, x2: navPts[0].x, y2: navPts[0].y });
    for (var i = 1; i < navPts.length; i++) {
      // Horizontal segment at previous Y
      allSegments.push({ x1: navPts[i - 1].x, y1: navPts[i - 1].y, x2: navPts[i].x, y2: navPts[i - 1].y });
      // Vertical step to new Y
      allSegments.push({ x1: navPts[i].x, y1: navPts[i - 1].y, x2: navPts[i].x, y2: navPts[i].y });
    }
    // Extend to last price candle
    var lastNav = navPts[navPts.length - 1];
    var lastPriceX = (pricePts.length > 0) ? pricePts[pricePts.length - 1].x : lastNav.x;
    if (lastNav.x < lastPriceX) {
      allSegments.push({ x1: lastNav.x, y1: lastNav.y, x2: lastPriceX, y2: lastNav.y });
    }

    // Draw each segment — same style as price line (solid white, thinner)
    for (var si = 0; si < allSegments.length; si++) {
      var seg = allSegments[si];
      ctx.beginPath();
      ctx.strokeStyle = '#e8e6e3';
      ctx.lineWidth = 1;
      ctx.moveTo(seg.x1, seg.y1);
      ctx.lineTo(seg.x2, seg.y2);
      ctx.stroke();
    }
  }

  // TGE circle
  if (CFG.tge && CFG.icoPrice > 0) {
    var tgeTs = Math.floor(new Date(CFG.tge + 'T00:00:00Z').getTime() / 1000);
    if (tgeTs >= tMin && tgeTs <= tMax) {
      var cx = tx(tgeTs), cy = ty(CFG.icoPrice);
      ctx.beginPath();
      ctx.arc(cx, cy, 5, 0, Math.PI * 2);
      ctx.fillStyle = '#ffffff';
      ctx.fill();
      // Label below
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 10px Inter, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('TGE $' + CFG.icoPrice, cx, cy + 18);
    }
  }

  // Treasury event markers — store positions for tooltip hover (dots replaced by red dashes on NAV line)
  if (_chart.navEvents && _chart.navEvents.length > 0) {
    var eventPts = [];
    for (var i = 0; i < _chart.navEvents.length; i++) {
      var evt = _chart.navEvents[i];
      if (evt.time >= tMin && evt.time <= tMax) {
        var ex = tx(evt.time);
        var eyNav = navYAtX ? navYAtX(ex) : ty(evt.value);
        eventPts.push({ x: ex, y: eyNav, time: evt.time, value: evt.value, treasury: evt.treasury, supply: evt.supply, outflow: evt.outflow, color: '#e84057' });
      }
    }
    _chart._eventPts = eventPts;
  }

  // ── Live price badge on right edge (checkprice style) ──
  if (pricePts.length > 0) {
    var lastPt = pricePts[pricePts.length - 1];
    var lastY = lastPt.y;
    var lastVal = CFG.spot;
    var badgeColor = '#e84057'; // default red
    if (_chart.navData && _chart.navData.length > 0) {
      var lastNavVal = _chart.navData[_chart.navData.length - 1].value;
      badgeColor = lastVal >= lastNavVal ? '#00e5a0' : '#e84057';
    }

    // Price badge on right edge
    var badgeText = '$' + lastVal.toFixed(lastVal >= 1 ? 2 : 4);
    ctx.font = 'bold 10px Inter, sans-serif';
    var badgeW = ctx.measureText(badgeText).width + 12;
    var badgeH = 18;
    var badgeX = w - pad.right + 2;
    var badgeY = lastY - badgeH / 2;

    // Badge background
    ctx.fillStyle = badgeColor;
    ctx.beginPath();
    ctx.roundRect(badgeX, badgeY, badgeW, badgeH, 3);
    ctx.fill();

    // Badge text
    ctx.fillStyle = '#000';
    ctx.textAlign = 'left';
    ctx.fillText(badgeText, badgeX + 6, lastY + 3.5);
  }

  // ── NAV badge on right edge ──
  if (navPts.length > 0) {
    var lastNavPt = navPts[navPts.length - 1];
    var navY = lastNavPt.y;
    var navVal = _chart.navData[_chart.navData.length - 1].value;

    // Only draw if NAV badge won't overlap price badge (>20px apart)
    var priceY = pricePts.length > 0 ? pricePts[pricePts.length - 1].y : -100;
    if (Math.abs(navY - priceY) > 22) {
      // Badge
      var navText = '$' + navVal.toFixed(navVal >= 1 ? 2 : 4);
      ctx.font = 'bold 10px Inter, sans-serif';
      var navBadgeW = ctx.measureText(navText).width + 12;
      var navBadgeH = 18;
      var navBadgeX = w - pad.right + 2;
      var navBadgeY = navY - navBadgeH / 2;

      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.beginPath();
      ctx.roundRect(navBadgeX, navBadgeY, navBadgeW, navBadgeH, 3);
      ctx.fill();

      ctx.fillStyle = '#000';
      ctx.textAlign = 'left';
      ctx.fillText(navText, navBadgeX + 6, navY + 3.5);
    }
  }

  // Store pixel data for crosshair
  _chart._pricePts = pricePts;
  _chart._navPts = navPts;
  _chart._tx = tx;
  _chart._ty = ty;
  _chart._tMin = tMin;
  _chart._tMax = tMax;
  _chart._vMin = vMin;
  _chart._vMax = vMax;
}

function interpolateNav(navPts, px) {
  if (navPts.length === 0) return null;
  if (px <= navPts[0].x) return navPts[0].y;
  if (px >= navPts[navPts.length - 1].x) return navPts[navPts.length - 1].y;
  for (var i = 0; i < navPts.length - 1; i++) {
    if (px >= navPts[i].x && px <= navPts[i + 1].x) {
      // Step interpolation: use left value
      return navPts[i].y;
    }
  }
  return navPts[navPts.length - 1].y;
}

function attachChartEvents(container) {
  if (container._eventsAttached) return;
  container._eventsAttached = true;
  var canvas = _chart.canvas;

  // Crosshair on mouse move (only when not dragging)
  canvas.addEventListener('mousemove', function(e) {
    if (_chart.isDragging || _chart.isYDragging) return;
    var rect = canvas.getBoundingClientRect();
    var mx = e.clientX - rect.left;
    var my = e.clientY - rect.top;
    var mxScaled = mx * (_chart.width / rect.width);
    var w = _chart.width;
    var cpad = _chart.padding;
    // Change cursor on price scale zone
    if (mxScaled > w - cpad.right - 30) {
      canvas.style.cursor = 'ns-resize';
    } else {
      canvas.style.cursor = 'crosshair';
    }
    drawChart();
    drawCrosshair(mx, my);
  });

  canvas.addEventListener('mouseleave', function() {
    if (!_chart.isDragging) drawChart();
    if (_chart.tooltip) _chart.tooltip.style.display = 'none';
  });

  // Zoom with scroll — anchored to right edge (most recent data stays pinned right)
  // Y-axis zoom if on price scale zone
  canvas.addEventListener('wheel', function(e) {
    e.preventDefault();
    var rect = canvas.getBoundingClientRect();
    var mx = (e.clientX - rect.left) * (_chart.width / rect.width);
    var w = _chart.width;
    var cpad = _chart.padding;

    // If scrolling on the right price scale zone, zoom Y-axis
    if (mx > w - cpad.right - 30) {
      var zoomFactor = e.deltaY > 0 ? 0.97 : 1.03;
      _chart.yZoom = Math.max(0.2, Math.min(10, _chart.yZoom * zoomFactor));
      drawChart();
      return;
    }

    // X-axis zoom — centered on mouse position
    var mxNorm = (e.clientX - rect.left) / rect.width;
    var zoomFactor = e.deltaY > 0 ? 1.03 : 0.97;
    var range = _chart.viewEnd - _chart.viewStart;
    var newRange = Math.min(1, Math.max(0.2, range * zoomFactor));
    var center = _chart.viewStart + mxNorm * range;
    var newStart = center - mxNorm * newRange;
    var newEnd = newStart + newRange;
    // Clamp: small left overscroll allowed, no right overscroll
    var leftPad = newRange * 0.05;
    if (newStart < -leftPad) { newStart = -leftPad; newEnd = newStart + newRange; }
    if (newEnd > 1) { newEnd = 1; newStart = newEnd - newRange; }
    _chart.viewStart = newStart;
    _chart.viewEnd = newEnd;
    drawChart();
  }, { passive: false });

  // Pan with click-drag — Y-axis on price scale, X-axis elsewhere
  canvas.addEventListener('mousedown', function(e) {
    var rect = canvas.getBoundingClientRect();
    var mx = (e.clientX - rect.left) * (_chart.width / rect.width);
    var w = _chart.width;
    var cpad = _chart.padding;

    // Right price scale zone — Y-axis drag
    if (mx > w - cpad.right - 30) {
      _chart.isYDragging = true;
      _chart.yDragStartY = e.clientY;
      _chart.yDragStartZoom = _chart.yZoom;
      canvas.style.cursor = 'ns-resize';
      if (_chart.tooltip) _chart.tooltip.style.display = 'none';
      e.preventDefault();
      return;
    }

    // Chart area — X+Y axis drag (2D pan)
    _chart.isDragging = true;
    _chart.dragStartX = e.clientX;
    _chart.dragStartY = e.clientY;
    _chart.dragStartViewStart = _chart.viewStart;
    _chart.dragStartViewEnd = _chart.viewEnd;
    _chart.dragRange = _chart.viewEnd - _chart.viewStart;
    _chart.dragStartYOffset = _chart.yOffset;
    _chart.dragYSensitivity = (_chart._vBaseRange || (_chart._vMax - _chart._vMin)) || 1;
    canvas.style.cursor = 'grabbing';
    if (_chart.tooltip) _chart.tooltip.style.display = 'none';
    e.preventDefault();
  });

  window.addEventListener('mousemove', function(e) {
    // Y-axis dragging on price scale — controls zoom
    if (_chart.isYDragging) {
      var dy = e.clientY - _chart.yDragStartY;
      var rect = _chart.canvas.getBoundingClientRect();
      var zoomDelta = 1 + (dy / rect.height) * 2;
      _chart.yZoom = Math.max(0.1, Math.min(20, _chart.yDragStartZoom / Math.max(0.1, zoomDelta)));
      drawChart();
      return;
    }

    // Chart area 2D panning
    if (!_chart.isDragging) return;
    var rect = _chart.canvas.getBoundingClientRect();
    var canvasW = rect.width;
    var dx = e.clientX - _chart.dragStartX;
    var dy = e.clientY - _chart.dragStartY;

    // X-axis pan — small overscroll on left, none on right
    var shift = -(dx / canvasW) * _chart.dragRange;
    var newStart = _chart.dragStartViewStart + shift;
    var leftPad = _chart.dragRange * 0.05;
    if (newStart < -leftPad) newStart = -leftPad;
    if (newStart + _chart.dragRange > 1) newStart = 1 - _chart.dragRange;
    _chart.viewStart = newStart;
    _chart.viewEnd = newStart + _chart.dragRange;

    // Y-axis pan — use sensitivity captured at drag start, limited to 30%
    var rawOffset = _chart.dragStartYOffset + (dy / rect.height) * _chart.dragYSensitivity;
    var maxOffset = _chart.dragYSensitivity * 0.3;
    _chart.yOffset = Math.max(-maxOffset, Math.min(maxOffset, rawOffset));

    drawChart();
  });

  window.addEventListener('mouseup', function() {
    if (_chart.isDragging) {
      _chart.isDragging = false;
      _chart.canvas.style.cursor = 'crosshair';
    }
    if (_chart.isYDragging) {
      _chart.isYDragging = false;
      _chart.canvas.style.cursor = 'crosshair';
    }
  });

  // Double click to reset zoom (both axes)
  canvas.addEventListener('dblclick', function() {
    _chart.viewStart = 0;
    _chart.viewEnd = 1;
    _chart.yZoom = 1;
    _chart.yOffset = 0;
    drawChart();
  });

  // Resize
  if (!container._resizeObserver) {
    container._resizeObserver = new ResizeObserver(function() {
      var dpr = window.devicePixelRatio || 1;
      var w = container.clientWidth;
      canvas.width = w * dpr;
      canvas.style.width = w + 'px';
      _chart.width = w;
      _chart.ctx = canvas.getContext('2d');
      _chart.ctx.scale(dpr, dpr);
      drawChart();
    });
    container._resizeObserver.observe(container);
  }
}

function drawCrosshair(mx, my) {
  var ctx = _chart.ctx;
  var w = _chart.width, h = _chart.height;
  var pad = _chart.padding;
  if (!ctx || mx < pad.left || mx > w - pad.right || my < pad.top || my > h - pad.bottom) {
    if (_chart.tooltip) _chart.tooltip.style.display = 'none';
    return;
  }

  // Vertical crosshair
  ctx.beginPath();
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1;
  ctx.setLineDash([4, 4]);
  ctx.moveTo(mx, pad.top);
  ctx.lineTo(mx, h - pad.bottom);
  ctx.stroke();
  // Horizontal
  ctx.beginPath();
  ctx.moveTo(pad.left, my);
  ctx.lineTo(w - pad.right, my);
  ctx.stroke();
  ctx.setLineDash([]);

  // Find closest NAV point
  var closest = null, closestDist = Infinity;
  var navPts = _chart._navPts || [];
  for (var i = 0; i < navPts.length; i++) {
    var d = Math.abs(navPts[i].x - mx);
    if (d < closestDist) { closestDist = d; closest = navPts[i]; }
  }

  // For step-style, use the interpolated NAV value at cursor position
  var navY = interpolateNav(_chart._navPts || [], mx);
  var navVal = null;
  if (navY !== null && _chart._vMin !== undefined) {
    var plotH = h - pad.top - pad.bottom;
    if (_chartScale === 'log') {
      var logMin = Math.log(_chart._vMin);
      var logMax = Math.log(_chart._vMax);
      var logRange = logMax - logMin;
      var logVal = logMax - ((navY - pad.top) / plotH) * logRange;
      navVal = Math.exp(logVal);
    } else {
      var vRange = _chart._vMax - _chart._vMin;
      navVal = _chart._vMax - ((navY - pad.top) / plotH) * vRange;
    }
  }

  if (closest && closestDist < 50 && navVal !== null) {
    // Dot on NAV line
    ctx.beginPath();
    ctx.arc(mx, navY, 4, 0, Math.PI * 2);
    ctx.fillStyle = '#ffffff';
    ctx.fill();

    // Find closest price point too
    var pricePts = _chart._pricePts || [];
    var closestPrice = null, closestPriceDist = Infinity;
    for (var i = 0; i < pricePts.length; i++) {
      var d = Math.abs(pricePts[i].x - mx);
      if (d < closestPriceDist) { closestPriceDist = d; closestPrice = pricePts[i]; }
    }

    // Dot on price line
    if (closestPrice && closestPriceDist < 50) {
      ctx.beginPath();
      ctx.arc(mx, closestPrice.y, 4, 0, Math.PI * 2);
      ctx.fillStyle = '#e8e6e3';
      ctx.fill();
    }

    // Check if cursor is near a treasury event marker
    var nearEvent = null;
    var eventPts = _chart._eventPts || [];
    for (var i = 0; i < eventPts.length; i++) {
      if (Math.abs(eventPts[i].x - mx) < 20) {
        nearEvent = eventPts[i];
        break;
      }
    }

    // Tooltip — only show when near an event marker
    var tooltip = _chart.tooltip;
    if (tooltip) {
      if (nearEvent) {
        var tRange = _chart._tMax - _chart._tMin || 1;
        var plotW = w - pad.left - pad.right;
        var cursorTime = _chart._tMin + ((mx - pad.left) / plotW) * tRange;
        var evtDate = new Date(nearEvent.time * 1000);
        var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        var dateStr = months[evtDate.getUTCMonth()] + ' ' + evtDate.getUTCDate() + ', ' + evtDate.getUTCFullYear();
        var fmt = function(v) { return '$' + (v >= 1 ? v.toFixed(2) : v.toFixed(4)); };
        var fmtM = function(v) { return v >= 1000000 ? '$' + (v / 1000000).toFixed(2) + 'M' : '$' + Math.round(v).toLocaleString(); };
        var fmtK = function(v) { return v >= 1000000 ? (v / 1000000).toFixed(2) + 'M' : Math.round(v).toLocaleString(); };

        var html = '<div class="tt-date">' + dateStr + '</div>';
        html += '<div class="tt-line" style="color:#e84057;font-weight:600">Withdraw: -' + fmtM(nearEvent.outflow) + '</div>';

        tooltip.innerHTML = html;
        tooltip.style.display = 'block';
        var ttLeft = nearEvent.x + 16;
        if (ttLeft + 200 > w) ttLeft = nearEvent.x - 200;
        tooltip.style.left = ttLeft + 'px';
        tooltip.style.top = (nearEvent.y - 50) + 'px';
      } else {
        tooltip.style.display = 'none';
      }
    }
  } else {
    if (_chart.tooltip) _chart.tooltip.style.display = 'none';
  }
}

function initChart(rawCandles, navPerToken) {
  _allCandles['1D'] = rawCandles;
  _navPerToken = navPerToken;
  _chartTF = '1D';

  buildChart(rawCandles, navPerToken);

  var controls = document.getElementById('chart-controls');
  if (controls) {
    controls.addEventListener('click', async function(e) {
      var btn = e.target.closest('.chart-btn');
      if (!btn || !btn.dataset.tf) return;

      controls.querySelectorAll('[data-tf]').forEach(function(b) { b.classList.remove('active'); });
      btn.classList.add('active');
      _chartTF = btn.dataset.tf;
      var candles = await fetchCandlesForTF(_chartTF);
      if (candles.length === 0) candles = rawCandles;
      buildChart(candles, _navPerToken);
      renderNAVStats(candles, _navPerToken);
    });
  }
}

// ═══════════════════════════════════════════════════════════════════════
// RENDER UI
// ═══════════════════════════════════════════════════════════════════════
function renderUI(isLive) {
  const supplyForNAV = CFG.effectiveSupply || CFG.supply;
  const strike = CFG.treasuryUSDC / supplyForNAV;
  const itm = CFG.spot < strike;
  const monthsLeft = CFG.monthlyBurn > 0 ? Math.floor(CFG.treasuryUSDC / CFG.monthlyBurn) : '\u221e';
  const discPct = strike > 0 ? ((CFG.spot - strike) / strike * 100) : 0;
  const isDiscount = discPct < 0;

  // Token header — icon + name + ticker
  var iconEl = document.getElementById('token-icon');
  if (iconEl) {
    if (CFG.logo) {
      iconEl.innerHTML = '<img src="' + CFG.logo + '" alt="' + CFG.ticker + '">';
    } else {
      iconEl.innerHTML = '<div style="width:36px;height:36px;border-radius:50%;background:' + (CFG.color || '#333') + ';display:flex;align-items:center;justify-content:center;font-family:Inter,sans-serif;font-size:14px;font-weight:700;color:#fff">' + CFG.ticker.charAt(0) + '</div>';
    }
  }
  var titleEl = document.getElementById('token-title-name');
  if (titleEl) titleEl.textContent = CFG.name;
  var tickerEl = document.getElementById('token-title-ticker');
  if (tickerEl) tickerEl.textContent = CFG.ticker;

  // Big price hero
  var priceVal = document.getElementById('price-hero-val');
  if (priceVal) priceVal.textContent = fmt$(CFG.spot);
  var priceChange = document.getElementById('price-hero-change');
  if (priceChange) {
    var changePct = discPct;
    priceChange.textContent = (isDiscount ? '' : '+') + changePct.toFixed(2) + '% vs NAV (' + fmt$(strike) + ')';
    priceChange.className = 'price-hero-change ' + (isDiscount ? 'down' : 'up');
  }

  // Hidden compat elements
  document.getElementById('sub-line').innerHTML = CFG.pair + ' \u00b7 FUTARCHY CPMM \u00b7 <span class="data-tag">' + (isLive ? 'LIVE' : 'SNAPSHOT') + '</span>';
  document.getElementById('title').textContent = CFG.ticker + ' \u2014 ' + (itm ? 'Trading Below Treasury Floor' : 'Trading Above Treasury Floor');
  document.getElementById('desc').innerHTML = '';

  document.getElementById('cards').innerHTML =
    '<div class="card"><div class="card-label">Treasury</div><div class="card-value" style="color:var(--green)">' + fmtM(CFG.treasuryUSDC) + '</div><div class="card-sub">' + fmtM(CFG.monthlyBurn) + '/mo burn</div></div>' +
    '<div class="card"><div class="card-label">NAV / Token</div><div class="card-value" style="color:var(--white)">' + fmt$(strike) + '</div><div class="card-sub">treasury \u00f7 holder supply</div></div>' +
    '<div class="card" onclick="togglePremiumFormat()" style="cursor:pointer"><div class="card-label">' + (isDiscount ? 'Discount' : 'Premium') + '</div><div class="card-value" id="prem-val" style="color:' + (isDiscount ? 'var(--red)' : 'var(--green)') + '">' + (isDiscount ? Math.abs(discPct).toFixed(1) + '%' : '+' + discPct.toFixed(0) + '%') + '</div><div class="card-sub" id="prem-sub">' + (isDiscount ? 'below NAV' : 'above NAV') + '</div></div>' +
    '<div class="card"><div class="card-label">Runway</div><div class="card-value" style="color:var(--orange)">' + monthsLeft + ' mo</div><div class="card-sub">at current burn rate</div></div>' +
    '<div class="card"><div class="card-label">MCap</div><div class="card-value" style="color:var(--white)">' + fmtM(CFG.spot * supplyForNAV) + '</div><div class="card-sub">' + (supplyForNAV / 1e6).toFixed(1) + 'M supply</div></div>';

  document.getElementById('params').innerHTML =
    '<span>Raise <b>' + fmtM(CFG.raise) + '</b></span>' +
    '<span>S\u2080 <b>' + fmt$(CFG.icoPrice) + '</b></span>' +
    '<span>NAV <span class="hl">' + fmt$(strike) + '</span></span>' +
    '<span>Spot <span class="spot">' + fmt$(CFG.spot) + '</span></span>' +
    '<span>ATH <b>' + fmt$(CFG.ath) + '</b></span>' +
    '<span>Burn <b>' + fmtBurn(CFG.monthlyBurn) + '/mo</b></span>';

  var daoBalance = CFG.daoUSDC || 0;
  document.getElementById('treasury-flow').innerHTML =
    '<span>Raised <b style="color:var(--green)">' + fmtM(CFG.raise) + '</b></span>' +
    '<span>DAO Balance <b style="color:var(--white)">' + fmtM(daoBalance) + '</b></span>' +
    '<span>Total Treasury <b style="color:var(--green)">' + fmtM(CFG.treasuryUSDC) + '</b></span>';

  document.getElementById('chart-label').innerHTML = CFG.ticker + ' Price vs NAV';
  document.getElementById('leg-spot-label').textContent = CFG.ticker + ' Price';
  document.getElementById('leg-strike').textContent = fmt$(strike);

  return strike;
}

// ═══════════════════════════════════════════════════════════════════════
// NAV STATS BAR
// ═══════════════════════════════════════════════════════════════════════
function renderNAVStats(candles, navPerToken) {
  var bar = document.getElementById('nav-stats-bar');
  if (!bar || !candles || candles.length === 0 || !navPerToken) { if (bar) bar.innerHTML = ''; return; }

  var aboveDays = 0, belowDays = 0;
  var currentStreak = 0, currentAbove = false;
  var maxAboveStreak = 0, maxBelowStreak = 0;
  var tempAbove = 0, tempBelow = 0;
  var avgAbovePct = 0, avgBelowPct = 0;
  var abovePctSum = 0, belowPctSum = 0;

  for (var i = 0; i < candles.length; i++) {
    var p = candles[i].close || candles[i].price;
    var pct = (p - navPerToken) / navPerToken * 100;
    if (p >= navPerToken) {
      aboveDays++;
      abovePctSum += pct;
      tempAbove++;
      if (tempAbove > maxAboveStreak) maxAboveStreak = tempAbove;
      tempBelow = 0;
    } else {
      belowDays++;
      belowPctSum += Math.abs(pct);
      tempBelow++;
      if (tempBelow > maxBelowStreak) maxBelowStreak = tempBelow;
      tempAbove = 0;
    }
  }

  var total = aboveDays + belowDays;
  var abovePct = total > 0 ? (aboveDays / total * 100) : 0;
  var belowPct = total > 0 ? (belowDays / total * 100) : 0;
  var avgAbove = aboveDays > 0 ? (abovePctSum / aboveDays) : 0;
  var avgBelow = belowDays > 0 ? (belowPctSum / belowDays) : 0;

  // Current streak
  var lastP = candles[candles.length - 1].close || candles[candles.length - 1].price;
  var isAboveNow = lastP >= navPerToken;
  currentStreak = 0;
  for (var j = candles.length - 1; j >= 0; j--) {
    var jp = candles[j].close || candles[j].price;
    if ((jp >= navPerToken) === isAboveNow) currentStreak++;
    else break;
  }

  bar.innerHTML =
    '<div class="ns-item ns-above">' +
      '<div class="ns-label">Time Above NAV</div>' +
      '<div class="ns-value">' + abovePct.toFixed(1) + '%</div>' +
      '<div class="ns-sub">' + aboveDays + ' of ' + total + ' periods · avg +' + avgAbove.toFixed(1) + '%</div>' +
      '<div class="ns-progress"><div class="ns-progress-fill" style="width:' + abovePct + '%;background:#00e5a0"></div></div>' +
    '</div>' +
    '<div class="ns-item ns-below">' +
      '<div class="ns-label">Time Below NAV</div>' +
      '<div class="ns-value">' + belowPct.toFixed(1) + '%</div>' +
      '<div class="ns-sub">' + belowDays + ' of ' + total + ' periods · avg -' + avgBelow.toFixed(1) + '%</div>' +
      '<div class="ns-progress"><div class="ns-progress-fill" style="width:' + belowPct + '%;background:#e84057"></div></div>' +
    '</div>' +
    '<div class="ns-item ns-neutral">' +
      '<div class="ns-label">Current Streak</div>' +
      '<div class="ns-value" style="color:' + (isAboveNow ? '#00e5a0' : '#e84057') + '">' + currentStreak + ' periods</div>' +
      '<div class="ns-sub">' + (isAboveNow ? 'above' : 'below') + ' NAV · longest ' + (isAboveNow ? maxAboveStreak + ' above' : maxBelowStreak + ' below') + '</div>' +
    '</div>';
}

// ═══════════════════════════════════════════════════════════════════════
// ADDRESS SECTION
// ═══════════════════════════════════════════════════════════════════════
function renderAddresses() {
  const section = document.getElementById('addr-section');
  if (!section) return;
  const truncAddr = a => a.slice(0, 6) + '…' + a.slice(-4);
  const solscanUrl = (addr, type) => 'https://solscan.io/' + type + '/' + addr;
  const copyBtn = (addr) => '<button class="addr-copy" onclick="navigator.clipboard.writeText(\'' + addr + '\');this.textContent=\'Copied!\';this.classList.add(\'copied\');setTimeout(function(){this.textContent=\'Copy\';this.classList.remove(\'copied\')}.bind(this),1500)">Copy</button>';

  const addrs = [];
  if (CFG.mint) addrs.push({ label: 'Token CA', addr: CFG.mint, type: 'token', balKey: null });
  if (CFG.daoWallet) addrs.push({ label: 'DAO Treasury', addr: CFG.daoWallet, type: 'account', balKey: 'dao' });
  if (CFG.ammWallet) addrs.push({ label: 'Fut AMM', addr: CFG.ammWallet, type: 'account', balKey: 'futamm' });
  if (CFG.ammWallet2) addrs.push({ label: 'Met AMM', addr: CFG.ammWallet2, type: 'account', balKey: 'metamm' });
  if (CFG.lockWallet) addrs.push({ label: 'Team Locked', addr: CFG.lockWallet, type: 'account', balKey: 'lock' });
  if (CFG.buybackWallet) addrs.push({ label: 'Buyback Wallet', addr: CFG.buybackWallet, type: 'account', balKey: 'buyback' });

  section.innerHTML = '<div class="addr-title">Relevant Wallets</div>' +
    '<div id="addr-table">' +
    addrs.map(function(a) {
      return '<div class="addr-row">' +
        '<span class="addr-label">' + a.label + '</span>' +
        '<div class="addr-val">' +
          '<a href="' + solscanUrl(a.addr, a.type) + '" target="_blank" title="View on Solscan">' + truncAddr(a.addr) + '</a>' +
          copyBtn(a.addr) +
        '</div>' +
        '<div class="addr-bals" data-bal="' + (a.balKey || '') + '"><span class="bal-loading">—</span></div>' +
      '</div>';
    }).join('') +
    '</div>';
}

function renderBalances() {
  var ticker = CFG.ticker || '';
  var fmtUsdc = function(n) {
    if (n === undefined || n === null) return '';
    if (n >= 1e6) return (n / 1e6).toFixed(2) + 'M USDC';
    if (n >= 1e3) return (n / 1e3).toFixed(1) + 'K USDC';
    if (n >= 100) return n.toFixed(0) + ' USDC';
    return '<$100 USDC';
  };
  var fmtTokens = function(n) {
    if (n === undefined || n === null || n === 0) return '0 ' + ticker;
    if (n >= 1e6) return (n / 1e6).toFixed(2) + 'M ' + ticker;
    if (n >= 1e3) return (n / 1e3).toFixed(0) + 'K ' + ticker;
    return n.toLocaleString() + ' ' + ticker;
  };

  // Map balance keys to actual data
  var balData = {
    dao: { usdc: CFG.treasuryUSDC || 0, tokens: CFG.daoTokenBalance || 0 },
    futamm: { usdc: CFG.futAmmUSDC || 0, tokens: CFG.futAmmTokens || 0 },
    metamm: { usdc: CFG.metAmmUSDC || 0, tokens: CFG.metAmmTokens || 0 },
    lock: { usdc: 0, tokens: CFG.lockTokenBalance || 0 },
    buyback: { usdc: 0, tokens: CFG.buybackTokenBalance || 0 },
  };

  document.querySelectorAll('.addr-bals').forEach(function(el) {
    var key = el.dataset.bal;
    if (!key) { el.innerHTML = '<span class="bal-token">—</span>'; return; }
    var d = balData[key] || { usdc: 0, tokens: 0 };
    var usdcStr = fmtUsdc(d.usdc);
    var tokenStr = fmtTokens(d.tokens);
    if (usdcStr) {
      el.innerHTML = '<span class="bal-usdc">' + usdcStr + '</span>' +
        '<span class="bal-sep">·</span>' +
        '<span class="bal-token">' + tokenStr + '</span>';
    } else {
      el.innerHTML = '<span class="bal-token">' + tokenStr + '</span>';
    }
  });
}

// ═══════════════════════════════════════════════════════════════════════
// ALLOWANCE SCHEDULE
// ═══════════════════════════════════════════════════════════════════════
async function fetchAllowance() {
  try {
    var res = await fetch(API_BASE_DASH + '/api/allowance?token=' + tokenKey);
    var data = await res.json();
    if (data && !data.message) renderAllowance(data);
    else if (data && data.utilization && data.utilization.length > 0) renderAllowance(data);
  } catch (e) { console.error('Allowance fetch error:', e); }
}

function renderAllowance(data) {
  var section = document.getElementById('allowance-section');
  var cards = document.getElementById('allowance-cards');
  var history = document.getElementById('allowance-history');
  if (!section || !cards) return;

  section.style.display = 'block';

  var fmtK = function(v) {
    if (v >= 1000000) return '$' + (v / 1000000).toFixed(1) + 'M';
    if (v >= 1000) return '$' + (v / 1000).toFixed(0) + 'K';
    return '$' + v.toLocaleString();
  };

  var fmtDate = function(d) {
    var parts = d.split('-');
    var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    return months[parseInt(parts[1]) - 1] + ' ' + parseInt(parts[2]);
  };

  // Build cards
  var html = '';

  // Card 1: Monthly Allowance Cap
  if (data.monthlyAllowance) {
    html += '<div class="allowance-card"><div class="ac-label">Monthly Allowance</div><div class="ac-value">' + fmtK(data.monthlyAllowance) + '</div><div class="ac-sub">' + (data.schedule ? data.schedule.frequency : '') + ' schedule</div></div>';
  }

  // Card 2: Avg Utilization
  if (data.avgUtilization !== null && data.avgUtilization !== undefined) {
    var utilColor = data.avgUtilization > 100 ? '#e84057' : data.avgUtilization > 80 ? '#ff8c42' : '#00e5a0';
    html += '<div class="allowance-card"><div class="ac-label">Avg Utilization</div><div class="ac-value" style="color:' + utilColor + '">' + data.avgUtilization + '%</div>';
    html += '<div class="util-bar"><div class="util-fill" style="width:' + Math.min(100, data.avgUtilization) + '%;background:' + utilColor + '"></div></div></div>';
  }

  // Card 3: Total Paid Out
  if (data.summary) {
    html += '<div class="allowance-card"><div class="ac-label">Total Paid Out</div><div class="ac-value">' + fmtK(data.summary.totalPaidOut) + '</div><div class="ac-sub">' + data.summary.monthsLive + ' months live</div></div>';
  }

  // Card 4: Next Payment
  if (data.nextPredicted) {
    var np = data.nextPredicted;
    var statusText = np.overdue ? '<span style="color:#e84057">' + Math.abs(np.daysUntil) + 'd overdue</span>' : '<span style="color:#00e5a0">in ' + np.daysUntil + ' days</span>';
    html += '<div class="allowance-card"><div class="ac-label">Next Predicted</div><div class="ac-value">' + fmtDate(np.date) + '</div><div class="ac-sub">' + statusText + ' · ~' + fmtK(np.estimatedAmount) + '</div></div>';
  }

  // Card 5: Last Payment
  if (data.lastPayment) {
    var lp = data.lastPayment;
    html += '<div class="allowance-card"><div class="ac-label">Last Payment</div><div class="ac-value">' + fmtDate(lp.date) + '</div><div class="ac-sub">' + lp.daysAgo + ' days ago · ' + fmtK(lp.amount) + '</div></div>';
  }

  cards.innerHTML = html;

  // Monthly utilization bars
  if (data.utilization && data.utilization.length > 0 && data.monthlyAllowance) {
    var utilHtml = '<div style="margin-top:8px;font-size:9px;color:var(--dim);font-family:Inter,sans-serif;text-transform:uppercase;letter-spacing:0.5px;margin-bottom:6px">Monthly Breakdown</div>';
    data.utilization.forEach(function(u) {
      var pct = u.utilization || 0;
      var barColor = pct > 100 ? '#e84057' : pct > 80 ? '#ff8c42' : '#00e5a0';
      var barWidth = Math.min(100, pct);
      utilHtml += '<div class="allowance-month">';
      utilHtml += '<span class="am-label" style="min-width:48px">' + u.month + '</span>';
      utilHtml += '<span class="am-bar"><span class="am-fill" style="width:' + barWidth + '%;background:' + barColor + '"></span></span>';
      utilHtml += '<span class="am-pct">' + pct + '%</span>';
      utilHtml += '<span style="color:var(--muted);margin-left:4px">' + fmtK(u.spent) + '</span>';
      utilHtml += '</div>';
    });
    history.innerHTML = utilHtml;
  }

  // Show special payments if any
  if (data.specialPayments && data.specialPayments.length > 0) {
    var spHtml = '<div style="margin-top:10px;font-size:9px;color:var(--dim);font-family:Inter,sans-serif;text-transform:uppercase;letter-spacing:0.5px;margin-bottom:4px">Special Payments (governance)</div>';
    data.specialPayments.forEach(function(sp) {
      spHtml += '<div style="font-size:10px;color:var(--muted);padding:2px 0">' + fmtDate(sp.date) + ' — ' + fmtK(sp.amount) + '</div>';
    });
    history.innerHTML += spHtml;
  }
}

// ═══════════════════════════════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════════════════════════════
(async function main() {
  if (!CFG.live) return;
  CFG.effectiveSupply = CFG.supply;
  var navPerToken = renderUI(false);
  renderAddresses();

  try {
    // Fetch allowance data for chart markers
    var allowancePromise = fetch(API_BASE_DASH + '/api/allowance?token=' + tokenKey)
      .then(function(r) { return r.json(); })
      .then(function(d) {
        if (d && d.cycles) {
          _allowancePayments = d.cycles.map(function(c) { return { date: c.startDate, amount: c.amount }; });
        }
      }).catch(function() {});

    var results = await Promise.all([fetchOHLCV(), fetchFromAPI(), fetchNAVHistory(), allowancePromise]);
    var ohlcv = results[0], apiOk = results[1];
    var isLive = !!(ohlcv || apiOk);
    navPerToken = renderUI(isLive);
    renderBalances();

    var chartData = (ohlcv && ohlcv.length > 0) ? ohlcv : [];

    if (apiOk && chartData.length > 0) {
      var lastCandle = chartData[chartData.length - 1];
      if (Math.abs(lastCandle.price - CFG.spot) > CFG.spot * 0.01) {
        chartData.push({ date: new Date(), open: lastCandle.price, high: Math.max(lastCandle.price, CFG.spot), low: Math.min(lastCandle.price, CFG.spot), close: CFG.spot, price: CFG.spot });
      }
    }

    var loadEl = document.getElementById('chart-loading');
    if (loadEl) loadEl.style.display = 'none';
    try {
      initChart(chartData, navPerToken);
    } catch(chartErr) {
      console.error('Chart init error:', chartErr);
    }
    renderNAVStats(chartData, navPerToken);

    if (!ohlcv) {
      var notice = document.createElement('div');
      notice.style.cssText = 'text-align:center;font-size:9px;color:#ff8c42;font-family:Inter,sans-serif;padding:6px 0';
      notice.textContent = '\u26a0 Chart data unavailable — price data could not be loaded.';
      var chartContainer = document.getElementById('chart-container');
      chartContainer.parentNode.insertBefore(notice, chartContainer.nextSibling);
    }

    console.log('NAVgator ' + CFG.ticker + ' | Live: ' + isLive + ' | OHLCV: ' + (ohlcv ? ohlcv.length + ' candles' : 'none') + ' | Spot: $' + CFG.spot + ' | Treasury: $' + CFG.treasuryUSDC.toLocaleString() + ' | EffSupply: ' + (CFG.effectiveSupply || CFG.supply).toLocaleString() + ' | NAV: $' + navPerToken.toFixed(6));

    // Fetch and render allowance data
    fetchAllowance();
  } catch (err) {
    console.error('NAVgator init error:', err);
    var loadEl2 = document.getElementById('chart-loading');
    if (loadEl2) loadEl2.remove();
    initChart([], navPerToken);
    var notice2 = document.createElement('div');
    notice2.style.cssText = 'text-align:center;font-size:9px;color:#e84057;font-family:Inter,sans-serif;padding:6px 0';
    notice2.textContent = '\u26a0 Error loading data — chart unavailable.';
    var cc2 = document.getElementById('chart-container');
    cc2.parentNode.insertBefore(notice2, cc2.nextSibling);
  }
})();
} // end if (_hasToken)
</script>
</body>
</html>
