<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NAVgator · Dashboard</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=DM+Serif+Display&family=JetBrains+Mono:wght@300;400;500&display=swap');
  :root {
    --bg: #0c0c10; --bg2: #141418; --bg3: #1a1a20;
    --border: #222228; --border2: #2a2a32;
    --dim: #555560; --muted: #77778a; --text: #a0a0b0; --bright: #d0d0dd; --white: #eeeef2;
    --green: #00e5a0; --green-dim: rgba(0,229,160,0.10);
    --red: #e84057; --orange: #f59e42; --blue: #5b8def; --purple: #9f8cfc;
    --card-bg: #16161c; --card-border: #24242c;
  }
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: 'Inter', -apple-system, system-ui, sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; -webkit-font-smoothing: antialiased; }
  ::selection { background: rgba(0,229,160,0.25); }

  .wrap { max-width: 980px; margin: 0 auto; padding: 40px 32px 64px; }

  /* Nav bar */
  .nav { display: flex; align-items: center; gap: 16px; margin-bottom: 32px; flex-wrap: wrap; }
  .nav-brand { font-family: 'DM Serif Display', serif; font-size: 18px; font-weight: 400; color: var(--white); text-decoration: none; letter-spacing: -0.3px; display: flex; align-items: center; gap: 8px; }
  .nav-brand span { color: var(--green); }
  .nav-brand-icon { display: inline-flex; align-items: center; justify-content: center; width: 26px; height: 26px; border-radius: 6px; background: linear-gradient(135deg, var(--green), #00b880); font-family: 'DM Serif Display', serif; font-size: 13px; font-weight: 400; color: #0c0c10; flex-shrink: 0; }
  .nav-sep { color: var(--dim); }
  .nav-tokens { display: flex; gap: 6px; flex-wrap: wrap; }
  .nav-tok { font-family: 'Inter', sans-serif; font-size: 10px; font-weight: 500; letter-spacing: 0.8px; text-transform: uppercase; padding: 5px 12px; border-radius: 6px; border: 1px solid var(--border2); color: var(--muted); text-decoration: none; transition: all 0.2s; }
  .nav-tok:hover { border-color: var(--green); color: var(--white); background: rgba(255,255,255,0.03); }
  .nav-tok.active { border-color: var(--green); color: var(--green); background: var(--green-dim); }

  /* Subheader line */
  .sub { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 500; color: var(--muted); letter-spacing: 1.5px; text-transform: uppercase; margin-bottom: 10px; }
  .sub .data-tag { color: var(--green); }

  /* Title */
  h1 { font-family: 'DM Serif Display', serif; font-size: 42px; font-weight: 400; color: var(--white); margin-bottom: 12px; line-height: 1.1; letter-spacing: -0.5px; }

  /* Description */
  .desc { font-family: 'Inter', sans-serif; font-size: 14px; font-weight: 400; color: var(--muted); line-height: 1.7; max-width: 740px; margin-bottom: 32px; }
  .desc b { color: var(--white); font-weight: 600; }
  .desc .hl-orange { color: var(--orange); font-weight: 600; }
  .desc .hl-green { color: var(--green); font-weight: 600; }

  /* 5 metric cards row */
  .cards { display: grid; grid-template-columns: repeat(5, 1fr); gap: 14px; margin-bottom: 24px; }
  @media (max-width: 800px) { .cards { grid-template-columns: repeat(3, 1fr); } }
  @media (max-width: 500px) { .cards { grid-template-columns: repeat(2, 1fr); } h1 { font-size: 30px; } }
  .card { border: 1px solid var(--card-border); border-radius: 12px; padding: 20px 22px; background: var(--card-bg); }
  .card-label { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 500; color: var(--muted); margin-bottom: 10px; }
  .card-value { font-family: 'DM Serif Display', serif; font-size: 32px; font-weight: 400; line-height: 1.1; color: var(--white); }
  .card-sub { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 400; color: var(--dim); margin-top: 6px; }

  /* Params bar */
  .params { display: flex; flex-wrap: wrap; gap: 6px 24px; font-family: 'Inter', sans-serif; font-size: 12px; font-weight: 400; color: var(--dim); padding: 14px 0; border-top: 1px solid var(--border); border-bottom: 1px solid var(--border); margin-bottom: 28px; }
  .params b { color: var(--text); font-weight: 600; }
  .params .hl { color: var(--green); font-weight: 600; }
  .params .spot { color: var(--red); font-weight: 600; }

  /* Chart section */
  .chart-section { background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 14px; padding: 24px 20px 16px; margin-bottom: 28px; position: relative; }
  .chart-title { font-family: 'Inter', sans-serif; font-size: 12px; font-weight: 500; color: var(--muted); margin-bottom: 16px; }
  .chart-title span { color: var(--red); }
  .chart-controls { display: flex; gap: 6px; position: absolute; top: 20px; right: 20px; z-index: 2; align-items: center; }
  .chart-btn-group { display: flex; gap: 4px; }
  .chart-btn-group + .chart-btn-group { margin-left: 8px; padding-left: 10px; border-left: 1px solid var(--border2); }
  .chart-btn { font-family: 'Inter', sans-serif; font-size: 10px; font-weight: 500; padding: 5px 12px; border-radius: 6px; border: 1px solid var(--border2); color: var(--muted); background: transparent; cursor: pointer; transition: all 0.2s; }
  .chart-btn:hover { border-color: var(--green); color: var(--white); }
  .chart-btn.active { border-color: var(--green); color: var(--green); background: var(--green-dim); }
  #chart-container { width: 100%; height: 400px; position: relative; }
  .chart-loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); font-size: 12px; color: var(--dim); }

  /* Tooltip */
  .chart-tooltip { position: absolute; display: none; pointer-events: none; background: rgba(12,12,16,0.96); border: 1px solid var(--card-border); border-radius: 10px; padding: 12px 16px; z-index: 10; backdrop-filter: blur(8px); }
  .tt-price { font-family: 'DM Serif Display', serif; font-size: 22px; font-weight: 400; color: var(--white); margin-bottom: 4px; }
  .tt-line { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 400; margin-top: 3px; }
  .tt-date { font-family: 'Inter', sans-serif; font-size: 10px; color: var(--dim); margin-top: 6px; }

  /* Legend */
  .legend { display: flex; flex-wrap: wrap; gap: 18px; padding: 12px 4px 0; font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 400; color: var(--muted); }
  .legend-item { display: flex; align-items: center; gap: 6px; }
  .legend-line { display: inline-block; width: 18px; height: 2.5px; border-radius: 2px; }
  .legend-fill { display: inline-block; width: 12px; height: 12px; border-radius: 2px; }
  .legend-dash { display: inline-block; width: 16px; height: 0; border-top: 2px dashed; }

  /* Address section */
  .nav-stats-bar { display: flex; gap: 0; margin-top: 12px; border-radius: 10px; overflow: hidden; font-family: 'Inter', sans-serif; font-size: 12px; }
  .nav-stats-bar .ns-item { flex: 1; padding: 12px 16px; display: flex; flex-direction: column; gap: 4px; }
  .nav-stats-bar .ns-label { font-size: 10px; font-weight: 600; letter-spacing: 1px; text-transform: uppercase; opacity: 0.7; }
  .nav-stats-bar .ns-value { font-size: 16px; font-weight: 600; }
  .nav-stats-bar .ns-sub { font-size: 10px; opacity: 0.6; }
  .nav-stats-bar .ns-above { background: rgba(0,229,160,0.08); color: #00e5a0; }
  .nav-stats-bar .ns-below { background: rgba(232,64,87,0.08); color: #e84057; }
  .nav-stats-bar .ns-neutral { background: rgba(255,255,255,0.04); color: var(--muted); }
  .nav-stats-bar .ns-progress { height: 4px; border-radius: 2px; margin-top: 6px; background: rgba(255,255,255,0.06); overflow: hidden; }
  .nav-stats-bar .ns-progress-fill { height: 100%; border-radius: 2px; }

  .addr-section { background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 14px; padding: 20px 22px; margin-bottom: 28px; }
  .addr-title { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 600; color: var(--muted); letter-spacing: 1.5px; text-transform: uppercase; margin-bottom: 14px; }
  .addr-row { display: flex; align-items: center; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid var(--border); font-family: 'Inter', sans-serif; font-size: 12px; }
  .addr-row:last-child { border-bottom: none; }
  .addr-label { color: var(--muted); font-weight: 500; min-width: 100px; }
  .addr-val { display: flex; align-items: center; gap: 8px; }
  .addr-val a { color: var(--green); text-decoration: none; font-family: 'JetBrains Mono', monospace; font-size: 11px; }
  .addr-val a:hover { text-decoration: underline; }
  .addr-copy { background: none; border: 1px solid var(--border2); border-radius: 4px; color: var(--dim); font-size: 10px; padding: 2px 6px; cursor: pointer; transition: all 0.2s; font-family: 'Inter', sans-serif; }
  .addr-copy:hover { border-color: var(--green); color: var(--green); }
  .addr-copy.copied { border-color: var(--green); color: var(--green); }

  .footer { font-family: 'Inter', sans-serif; font-size: 10px; font-weight: 400; color: var(--dim); text-align: center; padding: 24px 0; border-top: 1px solid var(--border); }
  .footer a { color: var(--muted); text-decoration: underline; }

  /* ── Landing page styles ── */
  .landing { display: none; }
  .landing.active { display: block; }
  .dashboard { display: none; }
  .dashboard.active { display: block; }
  .hero { padding: 80px 0 48px; text-align: center; }
  .logo-mark { display: inline-flex; align-items: center; justify-content: center; width: 64px; height: 64px; border-radius: 16px; background: linear-gradient(135deg, var(--green), #00b880); font-family: 'DM Serif Display', serif; font-size: 30px; font-weight: 400; color: #0c0c10; margin-bottom: 24px; box-shadow: 0 0 60px rgba(0,229,160,0.15), 0 0 120px rgba(0,229,160,0.05); animation: float 6s ease-in-out infinite; position: relative; }
  .logo-mark::after { content: ''; position: absolute; inset: -1px; border-radius: 17px; background: linear-gradient(135deg, rgba(0,229,160,0.4), rgba(0,184,128,0.1)); z-index: -1; filter: blur(1px); }
  @keyframes float { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-6px)} }
  .hero h1 { font-family: 'DM Serif Display', serif; font-size: 52px; font-weight: 400; color: var(--white); line-height: 1.1; margin-bottom: 14px; letter-spacing: -1px; }
  .hero h1 span { color: var(--green); }
  .tagline { font-family: 'Inter', sans-serif; font-size: 15px; font-weight: 400; color: var(--muted); line-height: 1.7; max-width: 540px; margin: 0 auto 40px; }
  .sort-bar { display: flex; align-items: center; gap: 8px; margin-bottom: 16px; flex-wrap: wrap; }
  .sort-label { font-family: 'Inter', sans-serif; font-size: 10px; font-weight: 500; letter-spacing: 1.5px; text-transform: uppercase; color: var(--dim); }
  .sort-btn { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 500; padding: 5px 12px; border-radius: 6px; border: 1px solid var(--border2); color: var(--muted); background: transparent; cursor: pointer; transition: all 0.2s; }
  .sort-btn:hover { border-color: var(--green); color: var(--white); background: rgba(255,255,255,0.03); }
  .sort-btn.active { border-color: var(--green); color: var(--green); background: var(--green-dim); }
  .tokens { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 14px; margin-bottom: 48px; }
  .token-card { border: 1px solid var(--card-border); border-radius: 14px; padding: 24px 22px; background: var(--card-bg); text-decoration: none; color: inherit; transition: all 0.25s ease; position: relative; overflow: hidden; }
  .token-card:hover { transform: translateY(-2px); box-shadow: 0 6px 30px rgba(0,229,160,0.06); border-color: var(--border2); }
  .tc-header { display: flex; align-items: center; gap: 10px; margin-bottom: 16px; position: relative; }
  .tc-icon { width: 38px; height: 38px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-family: 'DM Serif Display', serif; font-size: 16px; font-weight: 400; color: #0c0c10; flex-shrink: 0; }
  .tc-name { font-family: 'DM Serif Display', serif; font-size: 18px; font-weight: 400; color: var(--white); }
  .tc-pair { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 400; color: var(--dim); margin-top: 2px; }
  .tc-arrow { position: absolute; top: 0; right: 0; font-size: 16px; color: var(--dim); transition: all 0.25s; }
  .token-card:hover .tc-arrow { color: var(--green); transform: translateX(3px); }
  .tc-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; position: relative; }
  .tc-stat-label { font-family: 'Inter', sans-serif; font-size: 10px; font-weight: 500; color: var(--muted); }
  .tc-stat-val { font-family: 'DM Serif Display', serif; font-size: 16px; font-weight: 400; margin-top: 2px; }
  .how { padding: 36px 0 48px; border-top: 1px solid var(--border); }
  .how h2 { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 600; letter-spacing: 2px; text-transform: uppercase; color: var(--dim); margin-bottom: 24px; }
  .how-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; }
  @media (max-width: 600px) { .how-grid { grid-template-columns: 1fr; } .hero h1 { font-size: 36px; } }
</style>
</head>
<body>

<div class="wrap">

  <!-- ══ LANDING PAGE ══ -->
  <div class="landing" id="landing-view">
    <div class="hero">
      <div class="logo-mark" style="background:transparent;box-shadow:none"><svg width="48" height="30" viewBox="0 0 160 100"><ellipse cx="80" cy="50" rx="55" ry="30" fill="none" stroke="#00e5a0" stroke-width="5"/><ellipse cx="80" cy="50" rx="7" ry="26" fill="#00e5a0"/></svg></div>
      <h1>NAV<span>gator</span></h1>
      <p class="tagline">Real-time NAV analytics for MetaDAO ownership tokens. Treasury tracking, discount/premium metrics, and live on-chain data.</p>
    </div>
    <div class="sort-bar" id="sort-bar">
      <span class="sort-label">Sort by</span>
      <button class="sort-btn active" data-sort="mcap">MCap</button>
      <button class="sort-btn" data-sort="treasury">Treasury</button>
      <button class="sort-btn" data-sort="discount">Discount</button>
    </div>
    <div class="tokens" id="tokens"></div>
    <div class="how">
      <h2>How Treasury Backing Works</h2>
      <div class="how-grid">
        <div class="how-item"><div class="how-num" style="font-size:12px;font-weight:600;color:var(--green);margin-bottom:6px">01</div><div style="font-size:13px;color:var(--white);font-weight:600;margin-bottom:5px">Treasury-backed tokens</div><div style="font-size:12px;color:var(--muted);line-height:1.6">MetaDAO ICOs deposit all raised USDC into an on-chain treasury. The team draws a fixed monthly budget — every dollar is governed by futarchy.</div></div>
        <div class="how-item"><div class="how-num" style="font-size:12px;font-weight:600;color:var(--green);margin-bottom:6px">02</div><div style="font-size:13px;color:var(--white);font-weight:600;margin-bottom:5px">Backing = Treasury ÷ Supply</div><div style="font-size:12px;color:var(--muted);line-height:1.6">Each token has a claim on treasury USDC. When spot trades below backing, you're buying below the treasury floor — dissolution returns more than market price.</div></div>
        <div class="how-item"><div class="how-num" style="font-size:12px;font-weight:600;color:var(--green);margin-bottom:6px">03</div><div style="font-size:13px;color:var(--white);font-weight:600;margin-bottom:5px">Dissolution right</div><div style="font-size:12px;color:var(--muted);line-height:1.6">Any holder can propose dissolution via futarchy. If passed, treasury distributes pro-rata. This creates a soft price floor enforced by rational arbitrage.</div></div>
      </div>
    </div>
    <div class="footer">NAVgator · Treasury analytics for ownership tokens · <a href="https://metadao.fi" target="_blank">MetaDAO</a> · Data via NAVgator API + Birdeye + Solana RPC · Not financial advice</div>
  </div>

  <!-- ══ DASHBOARD VIEW ══ -->
  <div class="dashboard" id="dashboard-view">

  <!-- Nav -->
  <nav class="nav" id="nav"></nav>

  <div class="sub" id="sub-line">LOADING…</div>
  <h1 id="title">Loading Dashboard…</h1>
  <div class="desc" id="desc">Fetching data…</div>

  <div class="cards" id="cards"></div>
  <div class="params" id="params"></div>

  <div class="chart-section">
    <div class="chart-title" id="chart-label"></div>
    <div class="chart-controls" id="chart-controls">
      <div class="chart-btn-group" id="chart-view-toggle">
        <button class="chart-btn active" data-view="candle">Candle</button>
        <button class="chart-btn" data-view="nav">NAV</button>
      </div>
      <div class="chart-btn-group">
        <button class="chart-btn" data-tf="12H">12H</button>
        <button class="chart-btn active" data-tf="1D">1D</button>
        <button class="chart-btn" data-tf="1W">1W</button>
        <button class="chart-btn" data-tf="1M">1M</button>
      </div>
    </div>
    <div id="chart-container">
      <div class="chart-loading" id="chart-loading">⏳ Fetching price history…</div>
    </div>
    <div class="legend">
      <span class="legend-item"><span class="legend-fill" style="background:#00e5a0"></span> <span id="leg-spot-label">Bullish</span></span>
      <span class="legend-item"><span class="legend-fill" style="background:#e84057"></span> Bearish</span>
      <span class="legend-item"><span class="legend-line" style="background:#e84057"></span> NAV <span id="leg-strike">…</span></span>
    </div>
    <div class="nav-stats-bar" id="nav-stats-bar"></div>
  </div>

  <!-- Address section -->
  <div class="addr-section" id="addr-section"></div>

  <div class="footer">
    <a href="index.html">← NAVgator Home</a> · Treasury analytics for ownership tokens · Not financial advice
  </div>

  </div><!-- /dashboard-view -->
</div><!-- /wrap -->

<script>
// ═══════════════════════════════════════════════════════════════════════
// VIEW ROUTING — landing page vs dashboard
// ═══════════════════════════════════════════════════════════════════════
const _params = new URLSearchParams(window.location.search);
const _hasToken = _params.has('token');

if (_hasToken) {
  document.getElementById('dashboard-view').classList.add('active');
  document.title = 'NAVgator · Dashboard';
} else {
  document.getElementById('landing-view').classList.add('active');
  document.title = 'NAVgator — Treasury Analytics for Ownership Tokens';
}

// ═══════════════════════════════════════════════════════════════════════
// TOKEN CONFIGS
// ═══════════════════════════════════════════════════════════════════════
const TOKENS = {
  solo: { live: true,
    name: 'Solomon', ticker: 'SOLO', pair: 'SOLO/USDC',
    color: '#00e5a0',
    mint: 'SoLo9oxzLDpcq1dpqAgMwgce5WqkRDtNXK7EPnbmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: '98SPcyUZ2rqM2dgjCqqSXS4gJrNTLSNUAAVCF38xYj9u',
    ammWallet: 'DzYtzoNvPbyFCzwZA6cSm9eDEEmxEB9f8AGkJXUXgnSA',
    ammWallet2: '2zsbECzM7roqnDcuv2TNGpfv5PAnuqGmMo5YPtqmUz5p',
    lockWallet: 'Bo24B7DDVtpa9VxZ4LN8FrAT7TM3cgkri41a5GjFg5Dk',
    gtPool: 'o5rJFXSKTsuws58rBMNPG8jdKdnY4Z7ouU29dyohE4g',
    raise: 8_000_000, supply: 10_000_000, icoPrice: 0.80, ath: 1.09,
    monthlyBurn: 100_000, realizedVol: 99, tradingDays: 85,
    genesisStrike: 0.62, genesisPut: 0.300,
    spot: 0.55, treasuryUSDC: 7_420_000, ammUSDCFixed: null,
    tge: '2025-11-18',
    draws: [
      { date: '2025-12-01', amount: 100_000, label: 'Draw #1' },
      { date: '2026-01-01', amount: 100_000, label: 'Draw #2' },
      { date: '2026-02-01', amount: 100_000, label: 'Draw #3' },
    ],
    fallback: { peakDay: 1, peakPrice: 1.09, bounceDay: 30, bouncePrice: 0.70, listPrice: 0.94, floor: 0.40 },
  },
  zkfg: { live: true,
    name: 'ZKLSOL', ticker: 'ZKFG', pair: 'ZKFG/USDC',
    color: '#9f8cfc',
    mint: 'ZKFHiLAfAFMTcDAuCtjNW54VzpERvoe7PBF9mYgmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: 'BNvDfXYG2FAyBDYD71Xr9GhKE18MbmhtjsLKsCuXho6z',
    ammWallet: '5FPGRzY9ArJFwY2Hp2y2eqMzVewyWCBox7esmpuZfCvE',
    gtPool: 'JDuK4Wp3MQM6d9QKDNDNgoELHkfAMSqbbqzbmkz19vis',
    raise: 970_000, supply: 10_000_000, icoPrice: 0.097, ath: 0.145,
    monthlyBurn: 50_000, realizedVol: 120, tradingDays: 107,
    genesisStrike: 0.097, genesisPut: 0.055,
    spot: 0.0654, treasuryUSDC: 820_000, ammUSDCFixed: null,
    tge: '2025-10-24',
    draws: [
      { date: '2025-11-24', amount: 50_000, label: 'Draw #1' },
      { date: '2025-12-24', amount: 50_000, label: 'Draw #2' },
      { date: '2026-01-24', amount: 50_000, label: 'Draw #3' },
    ],
    fallback: { peakDay: 14, peakPrice: 0.145, bounceDay: 45, bouncePrice: 0.09, listPrice: 0.0687, floor: 0.02 },
  },
  umbra: { live: true,
    name: 'Umbra', ticker: 'UMBRA', pair: 'UMBRA/USDC',
    color: '#00c2ff',
    mint: 'PRVT6TB7uss3FrUd2D9xs2zqDBsa3GbMJMwCQsgmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: '6VsC8PuKkXm5xo54c2vbrAaSfQipkpGHqNuKTxXFySx6',
    ammWallet: 'BLkBSE96kQys7SrMioKxeMiVbeo4Ckk2Y4n1JphKxYnv',
    ammWallet2: '7dVri3qjYD3uobSZL3Zth8vSCgU6r6R2nvFsh7uVfDte',
    lockWallet: '3kX3EWm9iPB6oxFS2NJ71L6v5wzFZ8rQMEG6HC8QHJtF',
    gtPool: '7dVri3qjYD3uobSZL3Zth8vSCgU6r6R2nvFsh7uVfDte',
    gtPoolLegacy: 'BLkBSE96kQys7SrMioKxeMiVbeo4Ckk2Y4n1JphKxYnv',
    raise: 3_000_000, supply: 10_000_000, icoPrice: 0.30, ath: 2.43,
    monthlyBurn: 34_000, realizedVol: 110, tradingDays: 122,
    genesisStrike: 0.24, genesisPut: 0.12,
    spot: 0.76, treasuryUSDC: 2_860_000, ammUSDCFixed: null,
    tge: '2025-10-10',
    draws: [
      { date: '2025-11-10', amount: 34_000, label: 'Draw #1' },
      { date: '2025-12-10', amount: 34_000, label: 'Draw #2' },
      { date: '2026-01-10', amount: 34_000, label: 'Draw #3' },
      { date: '2026-02-10', amount: 34_000, label: 'Draw #4' },
    ],
    fallback: { peakDay: 3, peakPrice: 2.43, bounceDay: 30, bouncePrice: 1.10, listPrice: 2.31, floor: 0.30 },
  },
  avici: { live: true,
    name: 'Avici', ticker: 'AVICI', pair: 'AVICI/USDC',
    color: '#ff6b9d',
    mint: 'BANKJmvhT8tiJRsBSS1n2HryMBPvT5Ze4HU95DUAmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: 'DGgYoUcu1aDZt4GEL5NQiducwHRGbkMWsUzsXh2j622G',
    ammWallet: '3D854kknnQhu9xVaRNV154oZ9oN2WF3tXsq3LDu7fFMn',
    ammWallet2: '5gB4NPgFB3MHFHSeKN4sbaY6t9MB8ikCe9HyiKYid4Td',
    gtPool: '5gB4NPgFB3MHFHSeKN4sbaY6t9MB8ikCe9HyiKYid4Td',
    gtPoolLegacy: '3D854kknnQhu9xVaRNV154oZ9oN2WF3tXsq3LDu7fFMn',
    raise: 3_500_000, supply: 12_900_000, icoPrice: 0.35, ath: 7.57,
    monthlyBurn: 45_000, realizedVol: 130, tradingDays: 114,
    genesisStrike: 0.22, genesisPut: 0.11,
    spot: 1.08, treasuryUSDC: 3_300_000, ammUSDCFixed: null,
    tge: '2025-10-18',
    draws: [
      { date: '2025-11-18', amount: 45_000, label: 'Draw #1' },
      { date: '2025-12-18', amount: 45_000, label: 'Draw #2' },
      { date: '2026-01-18', amount: 45_000, label: 'Draw #3' },
    ],
    fallback: { peakDay: 40, peakPrice: 7.57, bounceDay: 70, bouncePrice: 3.50, listPrice: 0.50, floor: 0.45 },
  },
  loyal: { live: true,
    name: 'Loyal', ticker: 'LOYAL', pair: 'LOYAL/USDC',
    color: '#ffd700',
    mint: 'LoyALuiy1mRSpjRBRw3iCp88T7xSD4kxTL6uYdpAmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: 'AQyyTwCKemeeMu8ZPZFxrXMbVwAYTSbBhi1w4PBrhvYE',
    ammWallet: 'GxpJkPEsPmuRCCTNnfZaDKg4X3gf4ZPgmqgFqtibaPtK',
    ammWallet2: 'BGg7WsK98rhqtTp2uSKMa2yETqgwShFAjyf1RmYqCF7n',
    buybackWallet: 'AfGAjj7TQByC2WQtCNRhsyq1WeZqmQ7oNRoGb2JbgoQg',
    gtPool: 'BGg7WsK98rhqtTp2uSKMa2yETqgwShFAjyf1RmYqCF7n',
    gtPoolLegacy: 'GxpJkPEsPmuRCCTNnfZaDKg4X3gf4ZPgmqgFqtibaPtK',
    raise: 500_000, supply: 10_000_000, icoPrice: 0.05, ath: 0.37,
    monthlyBurn: 45_000, realizedVol: 140, tradingDays: 114,
    genesisStrike: 0.038, genesisPut: 0.02,
    spot: 0.13, treasuryUSDC: 420_000, ammUSDCFixed: null,
    tge: '2025-10-23',
    draws: [
      { date: '2025-11-23', amount: 45_000, label: 'Draw #1' },
      { date: '2025-12-23', amount: 45_000, label: 'Draw #2' },
      { date: '2026-01-23', amount: 45_000, label: 'Draw #3' },
    ],
    fallback: { peakDay: 1, peakPrice: 0.37, bounceDay: 40, bouncePrice: 0.15, listPrice: 0.09, floor: 0.03 },
  },
  paystream: { live: false,
    name: 'Paystream', ticker: 'PAY', pair: 'PAY/USDC',
    color: '#44ddaa',
    mint: '',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: 'BpXtB2ASf2Tft97ewTd8PayXCqFQ6Wqod33qrwwfK9Vz',
    ammWallet: '6FRXzTe3HajL8Fwmmkupp8g3y3wn3g3QEjj8sABndre3',
    ammWallet2: '6F88Y6iukU9GuL8CMWnx6YT832vBymNPicJBikQWeYe4',
    buybackWallet: '3BAUsXfhhK2H1KH18GYNhUvLUsPrKWcePEA5N2UKP6VL',
    gtPool: '6F88Y6iukU9GuL8CMWnx6YT832vBymNPicJBikQWeYe4',
    gtPoolLegacy: '6FRXzTe3HajL8Fwmmkupp8g3y3wn3g3QEjj8sABndre3',
    raise: 300_000, supply: 10_000_000, icoPrice: 0.03, ath: 0.04,
    monthlyBurn: 15_000, realizedVol: 100, tradingDays: 100,
    genesisStrike: 0.024, genesisPut: 0.012,
    spot: 0.021, treasuryUSDC: 255_000, ammUSDCFixed: null,
    tge: '2025-10-27',
    draws: [
      { date: '2025-11-27', amount: 15_000, label: 'Draw #1' },
      { date: '2025-12-27', amount: 15_000, label: 'Draw #2' },
      { date: '2026-01-27', amount: 15_000, label: 'Draw #3' },
    ],
    fallback: { peakDay: 10, peakPrice: 0.04, bounceDay: 35, bouncePrice: 0.028, listPrice: 0.03, floor: 0.01 },
  },
  omfg: { live: true,
    name: 'Omnipair', ticker: 'OMFG', pair: 'OMFG/USDC',
    color: '#ff8855',
    mint: 'omfgRBnxHsNJh6YeGbGAmWenNkenzsXyBXm3WDhmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: '34rned2SLUcYjUrM9meQkuyJY4QDBcKhkcUPXCgGuXD9',
    ammWallet: '2WNhaB6TPyZ3ynJjAUM4ZZ1Hdeep8FJ3A76FjGjTVjjS',
    ammWallet2: 'BiNnErm2VDkbKGiABj9ZRUjybz879NhH2heeWE7m5M6d',
    gtPool: 'BiNnErm2VDkbKGiABj9ZRUjybz879NhH2heeWE7m5M6d',
    gtPoolLegacy: '2WNhaB6TPyZ3ynJjAUM4ZZ1Hdeep8FJ3A76FjGjTVjjS',
    raise: 500_000, supply: 10_000_000, icoPrice: 0.05, ath: 0.83,
    monthlyBurn: 25_000, realizedVol: 120, tradingDays: 130,
    genesisStrike: 0.04, genesisPut: 0.02,
    spot: 0.32, treasuryUSDC: 400_000, ammUSDCFixed: null,
    tge: '2025-10-02',
    draws: [
      { date: '2025-11-02', amount: 25_000, label: 'Draw #1' },
      { date: '2025-12-02', amount: 25_000, label: 'Draw #2' },
      { date: '2026-01-02', amount: 25_000, label: 'Draw #3' },
      { date: '2026-02-02', amount: 25_000, label: 'Draw #4' },
    ],
    fallback: { peakDay: 21, peakPrice: 0.83, bounceDay: 50, bouncePrice: 0.50, listPrice: 0.08, floor: 0.04 },
  },
  meta: { live: false,
    name: 'MetaDAO', ticker: 'META', pair: 'META/USDC',
    color: '#ff5533',
    mint: 'METAwkXcqyXKy1AtsSgJ8JiUHwGCafnZL38n3vYmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: 'BfzJzFUeE54zv6Q2QdAZR4yx7UXuYRsfkeeirrRcxDvk',
    ammWallet: 'CUPoiqkK4hxyCiJcLC4yE9AtJP1MoV1vFV2vx3jqwWeS',
    ammWallet2: 'EXpXkwcWDhjEYyC5pfNfxsu8fUtK4CDCYTZR4ApQNRzo',
    gtPool: 'EXpXkwcWDhjEYyC5pfNfxsu8fUtK4CDCYTZR4ApQNRzo',
    gtPoolLegacy: 'CUPoiqkK4hxyCiJcLC4yE9AtJP1MoV1vFV2vx3jqwWeS',
    raise: 0, supply: 22_080_000, icoPrice: 0.17, ath: 10.69,
    monthlyBurn: 0, realizedVol: 95, tradingDays: 300,
    genesisStrike: 0, genesisPut: 0,
    spot: 3.78, treasuryUSDC: 0, ammUSDCFixed: null,
    tge: '2025-04-09',
    draws: [],
    fallback: { peakDay: 140, peakPrice: 10.69, bounceDay: 200, bouncePrice: 5.50, listPrice: 0.50, floor: 0.10 },
    note: 'Platform token — no ICO treasury structure. Treasury analytics are approximate.',
  },
  rngr: { live: true,
    name: 'Ranger', ticker: 'RNGR', pair: 'RNGR/USDC',
    color: '#22dd88',
    mint: 'RNGRtJMbCveqCp7AC6U95KmrdKecFckaJZiWbPGmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: '55H1Q1YrHJQ93uhG4jqrBBHx3a8H7TCM8kvf2UM2g5q3',
    ammWallet: '1PAwyDkWNFCcR96GhEReXHJBv3YEFVazCaQgNicVuKv',
    ammWallet2: '59WuweKV7DAg8aUgRhNytScQxioaFYNJdWnox5FxAXFq',
    buybackWallet: '33AEddb7BxoA7Y65BzybFCV5WyGy7LfBdjiL2anCDEkr',
    lockWallet: 'F35JE1HZMtZXXWdy3koSPRe1gGFQyqd5kpbPw2xNcjR8',
    gtPool: '59WuweKV7DAg8aUgRhNytScQxioaFYNJdWnox5FxAXFq',
    gtPoolLegacy: '1PAwyDkWNFCcR96GhEReXHJBv3YEFVazCaQgNicVuKv',
    raise: 8_000_000, supply: 10_000_000, icoPrice: 0.60, ath: 0.865,
    monthlyBurn: 250_000, realizedVol: 90, tradingDays: 32,
    genesisStrike: 0.47, genesisPut: 0.18,
    spot: 0.54, treasuryUSDC: 5_750_000, ammUSDCFixed: null,
    tge: '2026-01-10',
    draws: [
      { date: '2026-02-10', amount: 250_000, label: 'Draw #1' },
    ],
    fallback: { peakDay: 1, peakPrice: 0.865, bounceDay: 15, bouncePrice: 0.55, listPrice: 0.81, floor: 0.40 },
  },
};
// ═══════════════════════════════════════════════════════════════════════
// LANDING PAGE LOGIC
// ═══════════════════════════════════════════════════════════════════════
if (!_hasToken) {
  const landingTokens = Object.entries(TOKENS).map(([key, t]) => ({
    key, name: t.ticker, desc: t.name + (t.pair ? ' · ' + t.pair.split('/')[0] : ''),
    color: t.color, spot: t.spot, strike: t.raise > 0 ? t.treasuryUSDC / t.supply : 0,
    treasury: t.treasuryUSDC, mcap: t.spot * t.supply, live: t.live,
  }));
  const lfmt$ = (n) => '$' + (n >= 1 ? n.toFixed(2) : n >= 0.01 ? n.toFixed(4) : n.toFixed(6));
  const lfmtM = n => n>=1e6?'$'+(n/1e6).toFixed(1)+'M':'$'+(n/1e3).toFixed(0)+'K';

  function renderTokens(sortKey) {
    const sorted = [...landingTokens].sort((a, b) => {
      if (sortKey === 'treasury') return b.treasury - a.treasury;
      if (sortKey === 'discount') {
        const da = a.strike > 0 ? (a.strike - a.spot) / a.strike : -999;
        const db = b.strike > 0 ? (b.strike - b.spot) / b.strike : -999;
        return db - da;
      }
      return b.mcap - a.mcap;
    });
    document.getElementById('tokens').innerHTML = sorted.map(t => {
      const noStrike = t.strike === 0;
      const discPct = t.strike > 0 ? ((t.spot - t.strike) / t.strike * 100) : 0;
      const isDiscount = discPct < 0;
      const fmtMcap = t.mcap >= 1e6 ? '$'+(t.mcap/1e6).toFixed(1)+'M' : '$'+(t.mcap/1e3).toFixed(0)+'K';
      const discLabel = noStrike ? 'N/A' : isDiscount ? Math.abs(discPct).toFixed(1) + '% discount' : '+' + discPct.toFixed(0) + '% premium';
      const comingSoon = !t.live;
      const overlay = comingSoon ? '<div style="position:absolute;inset:0;background:rgba(12,12,16,0.82);border-radius:14px;display:flex;align-items:center;justify-content:center;z-index:2"><span style="font-size:12px;font-weight:600;color:var(--muted);letter-spacing:1px;text-transform:uppercase">Coming Soon</span></div>' : '';
      return `<a class="token-card" ${comingSoon?'style="pointer-events:none"':'href="index.html?token='+t.key+'"'} onmouseover="this.style.borderColor='${t.color}'" onmouseout="this.style.borderColor=''">
        ${overlay}
        <div class="tc-header">
          <div class="tc-icon" style="background:${t.color}">${t.name[0]}</div>
          <div><div class="tc-name">${t.name}</div><div class="tc-pair">${t.desc}</div></div>
          <span class="tc-arrow">→</span>
        </div>
        <div class="tc-stats">
          <div><div class="tc-stat-label">Spot</div><div class="tc-stat-val" style="color:var(--white)">${lfmt$(t.spot)}</div></div>
          <div><div class="tc-stat-label">MCap</div><div class="tc-stat-val" style="color:var(--text)">${fmtMcap}</div></div>
          <div><div class="tc-stat-label">${noStrike?'—':'Backing'}</div><div class="tc-stat-val" style="color:#e84057">${noStrike?'N/A':lfmt$(t.strike)}</div></div>
          <div><div class="tc-stat-label">vs NAV</div><div class="tc-stat-val" style="color:${isDiscount?'var(--red)':'var(--green)'}">${discLabel}</div></div>
        </div>
      </a>`;
    }).join('');
  }

  renderTokens('mcap');
  document.getElementById('sort-bar').addEventListener('click', e => {
    const btn = e.target.closest('.sort-btn');
    if (!btn) return;
    document.querySelectorAll('.sort-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    renderTokens(btn.dataset.sort);
  });

  // Fetch live data from backend API
  const API_BASE = 'https://navgator-api.vercel.app';
  const currentSort = () => document.querySelector('.sort-btn.active')?.dataset.sort || 'mcap';

  async function fetchLandingData() {
    try {
      const res = await fetch(API_BASE + '/api/current');
      const data = await res.json();
      if (!data.tokens) return;
      for (const t of data.tokens) {
        if (t.error) continue;
        const lt = landingTokens.find(x => x.key === t.token);
        if (!lt) continue;
        if (t.spot > 0) { lt.spot = t.spot; lt.mcap = t.spot * (t.effectiveSupply || TOKENS[t.token].supply); }
        if (t.treasuryUSDC > 0 && t.effectiveSupply > 0) { lt.treasury = t.treasuryUSDC; lt.strike = t.treasuryUSDC / t.effectiveSupply; }
      }
      renderTokens(currentSort());
      console.log('NAVgator landing: live data loaded from API');
    } catch (e) { console.warn('API fetch failed:', e.message); }
  }

  fetchLandingData();
}

// ═══════════════════════════════════════════════════════════════════════
// DASHBOARD LOGIC (only when ?token= is present)
// ═══════════════════════════════════════════════════════════════════════
if (_hasToken) {
const params = new URLSearchParams(window.location.search);
const tokenKey = (params.get('token') || 'solo').toLowerCase();
const CFG = TOKENS[tokenKey] || TOKENS.solo;
const API_BASE_DASH = 'https://navgator-api.vercel.app';

document.title = `NAVgator · ${CFG.ticker}/USDC — Treasury Analytics`;

// Build nav — dim non-live tokens
const navEl = document.getElementById('nav');
const LIVE_KEYS = new Set(Object.entries(TOKENS).filter(([k,v]) => v.live).map(([k]) => k));
let navHTML = '<a href="index.html" class="nav-brand"><svg width="22" height="14" viewBox="0 0 160 100" style="flex-shrink:0"><ellipse cx="80" cy="50" rx="55" ry="30" fill="none" stroke="#00e5a0" stroke-width="6"/><ellipse cx="80" cy="50" rx="7" ry="26" fill="#00e5a0"/></svg> NAV<span>gator</span></a><span class="nav-sep">·</span><div class="nav-tokens">';
for (const [key, tok] of Object.entries(TOKENS)) {
  const isLive = LIVE_KEYS.has(key);
  const dimStyle = !isLive ? 'opacity:0.35;pointer-events:none;' : '';
  navHTML += `<a class="nav-tok${key===tokenKey?' active':''}" href="index.html?token=${key}" style="${dimStyle}${key===tokenKey?'border-color:'+tok.color+';color:'+tok.color:''}">${tok.ticker}</a>`;
}
navHTML += '</div>';
navEl.innerHTML = navHTML;

// If token is not live, show coming soon overlay and stop
if (!CFG.live) {
  document.getElementById('sub-line').textContent = 'COMING SOON';
  document.getElementById('title').textContent = CFG.name + ' — Coming Soon';
  document.getElementById('desc').innerHTML = `<b>${CFG.ticker}</b> dashboard is under development. Treasury tracking, price charts, and analytics will be available soon.`;
  document.getElementById('cards').innerHTML = '';
  document.getElementById('params').innerHTML = '';
  document.getElementById('chart-loading').textContent = 'Coming Soon';
  const scs = document.getElementById('strike-chart-section');
  if (scs) scs.style.display = 'none';
}

// ═══════════════════════════════════════════════════════════════════════
// MATH
// ═══════════════════════════════════════════════════════════════════════
const pDec = (v) => v >= 1 ? 2 : v >= 0.01 ? 4 : 6;
const fmt$ = (n,d) => '$'+n.toFixed(d !== undefined ? d : pDec(n));
const fmtM = n => n>=1e6?'$'+(n/1e6).toFixed(1)+'M':n>=1e3?'$'+(n/1e3).toFixed(0)+'K':fmt$(n,2);
const fmtBurn = n => n>=1e6?'$'+(n/1e6).toFixed(1)+'M':n>=1e3?'$'+(n/1e3).toFixed(0)+'K':'$'+n;

// ═══════════════════════════════════════════════════════════════════════
// LIVE DATA FETCHERS
// ═══════════════════════════════════════════════════════════════════════
async function fetchOHLCV() {
  var candles = await fetchCandlesForTF('1D');
  return candles.length > 0 ? candles : null;
}

async function fetchFromAPI() {
  try {
    const res = await fetch(API_BASE_DASH + '/api/current?token=' + tokenKey);
    const data = await res.json();
    if (data.error) return false;
    if (data.spot > 0) CFG.spot = data.spot;
    if (data.treasuryUSDC > 0) CFG.treasuryUSDC = data.treasuryUSDC;
    if (data.effectiveSupply > 0) CFG.effectiveSupply = data.effectiveSupply;
    if (data.onChainSupply > 0) CFG.onChainSupply = data.onChainSupply;
    if (data.lockedTokens > 0) CFG.lockedTokenBalance = data.lockedTokens;
    if (data.ammTokens > 0) CFG.ammTokenBalance = data.ammTokens;
    console.log('API data:', data);
    return true;
  } catch (e) { console.warn('API fetch failed:', e.message); return false; }
}

// ═══════════════════════════════════════════════════════════════════════
// FALLBACK SIMULATED DATA
// ═══════════════════════════════════════════════════════════════════════
function genFallback() {
  const fb = CFG.fallback;
  const data = [];
  const tge = new Date(CFG.tge);
  const now = new Date();
  const days = Math.floor((now - tge) / 86400000);
  let price = fb.listPrice;
  let seed = 42;
  const rng = () => { seed = (seed * 16807) % 2147483647; return seed / 2147483647; };
  for (let d = 0; d <= days; d++) {
    const noise = (rng() - 0.48) * 0.025 * price;
    if (d < fb.peakDay) {
      price += (fb.listPrice + (fb.peakPrice-fb.listPrice)*(1-Math.pow(1-d/fb.peakDay,1.8)) - price) * 0.12 + noise;
    } else if (d < fb.bounceDay) {
      price += (fb.peakPrice + (fb.bouncePrice-fb.peakPrice)*Math.pow((d-fb.peakDay)/(fb.bounceDay-fb.peakDay),0.6) - price) * 0.06 + noise*0.8;
    } else {
      price += (fb.bouncePrice + (CFG.spot-fb.bouncePrice)*Math.pow((d-fb.bounceDay)/Math.max(days-fb.bounceDay,1),0.7) - price) * 0.04 + noise*0.6;
    }
    price = Math.max(fb.floor, price);
    if (d === days) price = CFG.spot;
    data.push({ date: new Date(tge.getTime() + d*86400000), price: parseFloat(price.toFixed(6)) });
  }
  return data;
}

// ═══════════════════════════════════════════════════════════════════════
// CHART — DexScreener-style Candlesticks + NAV line
// ═══════════════════════════════════════════════════════════════════════
var _allCandles = {};  // keyed by timeframe
var _navPerToken = 0;
var _chartTF = '1D';
var _chartScrollPx = 0;  // pixel offset for panning
var _chartScrollY = 0;   // vertical pixel offset for panning
var _chartVisible = 60;  // how many candles fit in view (controls zoom)
var _chartYScale = 1.0;  // vertical zoom multiplier (>1 = stretched, <1 = compressed)
var _chartViewMode = 'candle'; // 'candle' or 'nav'

async function fetchCandlesForTF(tf) {
  if (_allCandles[tf]) return _allCandles[tf];
  if (!CFG.mint) return [];
  try {
    var tge = new Date(CFG.tge);
    var now = new Date();
    var timeFrom = Math.floor(tge.getTime() / 1000);
    var timeTo = Math.floor(now.getTime() / 1000);
    var url = 'https://public-api.birdeye.so/defi/ohlcv?address=' + CFG.mint + '&type=' + tf + '&time_from=' + timeFrom + '&time_to=' + timeTo;
    var res = await fetch(url, {
      headers: { 'Accept': 'application/json', 'X-API-KEY': 'f570879c3c51419fb0c7e75e38793434' }
    });
    if (!res.ok) return [];
    var json = await res.json();
    var items = json.data && json.data.items ? json.data.items : [];
    var candles = items.map(function(c) {
      return { date: new Date(c.unixTime * 1000), open: c.o, high: c.h, low: c.l, close: c.c, price: c.c };
    }).filter(function(d) { return d.price > 0; });
    candles.sort(function(a, b) { return a.date - b.date; });
    _allCandles[tf] = candles;
    return candles;
  } catch (e) { return []; }
}

function drawChart(candles, navPerToken) {
  var container = document.getElementById('chart-container');
  container.innerHTML = '';
  var n = candles.length;
  if (n === 0) { container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;font-size:12px;color:#555560">No chart data available</div>'; return; }

  var dpr = window.devicePixelRatio || 1;
  var cw = Math.min(920, container.clientWidth);
  var ch = 400;
  var mg = { top: 24, right: 72, bottom: 52, left: 16 };
  var w = cw - mg.left - mg.right;
  var h = ch - mg.top - mg.bottom;

  var canvas = document.createElement('canvas');
  canvas.width = cw * dpr; canvas.height = ch * dpr;
  canvas.style.width = cw + 'px'; canvas.style.height = ch + 'px';
  canvas.style.cursor = 'crosshair';
  container.appendChild(canvas);
  var ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);

  // Fixed-width candles based on zoom level
  var candleW = Math.max(1, Math.floor(w / _chartVisible));
  var bodyW = Math.max(1, candleW <= 2 ? candleW : candleW - 2);
  var wickW = bodyW < 4 ? 1 : 1.5;

  // Total width of all candles as a block
  var totalBlockW = n * candleW;

  // _chartScrollPx: 0 = default (latest candle at right edge)
  // positive = scrolled right (viewing older), negative = scrolled left
  // Default position: right-align the block so last candle is at right edge
  var defaultOffset = w - totalBlockW;
  var blockX = mg.left + defaultOffset + _chartScrollPx;

  // Clamp: latest candle can go to left edge, oldest candle can go to right edge
  var minBlockX = mg.left + w - totalBlockW;  // normal: right-aligned (offset=0 default)
  var maxBlockX = mg.left + w - candleW;       // oldest candle at right edge
  var minScrollLeft = mg.left - (blockX - _chartScrollPx) + candleW - w;  // latest at left edge
  // Actually let's just compute limits on _chartScrollPx:
  // blockX = mg.left + defaultOffset + scrollPx
  // Latest candle at left edge: blockX + (n-1)*candleW + candleW/2 = mg.left + candleW/2
  //   => mg.left + defaultOffset + scrollPx + (n-1)*candleW = mg.left
  //   => scrollPx = -(defaultOffset + (n-1)*candleW) = -(w - totalBlockW + (n-1)*candleW) = -(w - candleW)
  // Oldest candle at right edge: blockX + candleW/2 = mg.left + w - candleW/2
  //   => mg.left + defaultOffset + scrollPx = mg.left + w - candleW
  //   => scrollPx = w - candleW - defaultOffset = w - candleW - w + totalBlockW = totalBlockW - candleW = (n-1)*candleW
  var minScroll = -(w - candleW);
  var maxScroll = Math.max(0, (n - 1) * candleW);
  _chartScrollPx = Math.max(minScroll, Math.min(maxScroll, _chartScrollPx));
  blockX = mg.left + defaultOffset + _chartScrollPx;

  // sx: x position of candle index i
  var sx = function(i) { return blockX + i * candleW + candleW / 2; };

  // Determine which candles are visible on screen
  var visStart = Math.max(0, Math.floor((mg.left - blockX) / candleW));
  var visEnd = Math.min(n, Math.ceil((mg.left + w - blockX) / candleW));

  // Price range from ALL candles so Y axis stays fixed during zoom
  var allHigh = -Infinity, allLow = Infinity;
  for (var i = 0; i < n; i++) {
    var hi = candles[i].high || candles[i].price;
    var lo = candles[i].low || candles[i].price;
    if (hi > allHigh) allHigh = hi;
    if (lo < allLow) allLow = lo;
  }
  if (navPerToken > allHigh) allHigh = navPerToken;
  if (navPerToken < allLow) allLow = navPerToken;
  var pPad = (allHigh - allLow) * 0.08 || allHigh * 0.05;
  var pMinBase = allLow - pPad;
  var pMaxBase = allHigh + pPad;
  // Apply vertical zoom: scale around the midpoint
  var pMid = (pMinBase + pMaxBase) / 2;
  var pHalf = (pMaxBase - pMinBase) / 2;
  // Apply vertical pan: shift the midpoint based on scroll
  var pRange = pHalf * 2 / _chartYScale;
  var yPanAmount = (_chartScrollY / 300) * pRange; // 300px drag = full range shift
  pMid += yPanAmount;
  var pMin = pMid - pHalf / _chartYScale;
  var pMax = pMid + pHalf / _chartYScale;

  var sy = function(p) { return mg.top + (1 - (p - pMin) / (pMax - pMin)) * h; };

  // Clip to chart area
  ctx.save();
  ctx.beginPath();
  ctx.rect(mg.left, 0, w, ch);
  ctx.clip();

  // Grid
  ctx.strokeStyle = '#222228'; ctx.lineWidth = 0.5;
  for (var gi = 0; gi <= 6; gi++) {
    var v = pMin + (pMax - pMin) * gi / 6;
    ctx.beginPath(); ctx.moveTo(mg.left, sy(v)); ctx.lineTo(mg.left + w, sy(v)); ctx.stroke();
  }

  // NAV flat line
  var navY = sy(navPerToken);
  ctx.fillStyle = 'rgba(232,64,87,0.06)';
  ctx.fillRect(mg.left, navY, w, mg.top + h - navY);
  ctx.fillStyle = 'rgba(0,229,160,0.04)';
  ctx.fillRect(mg.left, mg.top, w, navY - mg.top);
  ctx.strokeStyle = '#e84057'; ctx.lineWidth = 2; ctx.setLineDash([8, 4]);
  ctx.beginPath(); ctx.moveTo(mg.left, navY); ctx.lineTo(mg.left + w, navY); ctx.stroke();
  ctx.setLineDash([]);

  // Draw only visible candles (skip off-screen ones for performance)
  for (var ci = visStart; ci < visEnd; ci++) {
    var d = candles[ci];
    var x = sx(ci);
    var hasOHLC = d.open != null && d.high != null && d.low != null;

    if (hasOHLC) {
      var bull = d.close >= d.open;
      var bodyCol = bull ? '#00e5a0' : '#e84057';
      var wickCol = bull ? 'rgba(0,229,160,0.5)' : 'rgba(232,64,87,0.5)';
      var yH = sy(d.high), yL = sy(d.low);
      var yO = sy(d.open), yC = sy(d.close);
      var bTop = Math.min(yO, yC), bBot = Math.max(yO, yC);
      var bH = Math.max(1, bBot - bTop);

      ctx.strokeStyle = wickCol; ctx.lineWidth = wickW;
      ctx.beginPath(); ctx.moveTo(x, yH); ctx.lineTo(x, yL); ctx.stroke();

      ctx.fillStyle = bodyCol;
      ctx.fillRect(x - bodyW / 2, bTop, bodyW, bH);
    } else {
      ctx.fillStyle = '#f0f0f5';
      ctx.beginPath(); ctx.arc(x, sy(d.price), 1.5, 0, Math.PI * 2); ctx.fill();
    }
  }

  ctx.restore(); // end clip

  // X labels (below chart, outside clip)
  var mo = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  ctx.textAlign = 'center'; ctx.fillStyle = '#555560'; ctx.font = '10px Inter, sans-serif';
  var xStep = Math.max(1, Math.floor(_chartVisible / 8));
  for (var xi = visStart; xi < visEnd; xi += xStep) {
    var xd = candles[xi].date;
    var xPos = sx(xi);
    if (xPos > mg.left && xPos < mg.left + w) {
      ctx.fillText(mo[xd.getMonth()] + '-' + String(xd.getDate()).padStart(2, '0'), xPos, mg.top + h + 20);
    }
  }

  // Y labels (right side)
  var yd = pMax >= 1 ? 2 : pMax >= 0.01 ? 4 : 6;
  ctx.fillStyle = '#555560'; ctx.font = '10px Inter, sans-serif'; ctx.textAlign = 'left';
  for (var yi = 0; yi <= 6; yi++) {
    var yv = pMin + (pMax - pMin) * yi / 6;
    ctx.fillText('$' + yv.toFixed(yd), mg.left + w + 6, sy(yv) + 3);
  }

  // NAV label (right side, outside clip)
  ctx.fillStyle = '#e84057'; ctx.font = '11px Inter, sans-serif'; ctx.textAlign = 'left';
  ctx.fillText('NAV ' + fmt$(navPerToken), mg.left + w + 6, navY + 4);

  // Current price marker + label (only if last candle is visible)
  var last = candles[n - 1];
  var lastX = sx(n - 1);
  if (lastX >= mg.left && lastX <= mg.left + w) {
    var lastBull = (last.close || last.price) >= (last.open || last.price);
    ctx.fillStyle = lastBull ? '#00e5a0' : '#e84057';
    ctx.beginPath(); ctx.arc(lastX, sy(last.price), 5, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = '#0c0c10'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(lastX, sy(last.price), 5, 0, Math.PI * 2); ctx.stroke();
  }
  ctx.fillStyle = '#f0f0f5'; ctx.font = '11px Inter, sans-serif'; ctx.textAlign = 'left';
  ctx.fillText(fmt$(last.price), mg.left + w + 6, sy(last.price) + 4);

  // Tooltip
  var tt = document.createElement('div');
  tt.className = 'chart-tooltip';
  container.appendChild(tt);
  canvas.addEventListener('mousemove', function(e) {
    var rect = canvas.getBoundingClientRect();
    var mx = e.clientX - rect.left;
    if (mx < mg.left || mx > mg.left + w) { tt.style.display = 'none'; return; }
    var idx = Math.round((mx - blockX) / candleW - 0.5);
    idx = Math.max(0, Math.min(n - 1, idx));
    var dd = candles[idx];
    var belowNAV = dd.price < navPerToken;
    var pctNAV = navPerToken > 0 ? Math.abs((dd.price - navPerToken) / navPerToken * 100) : 0;
    tt.style.display = 'block';
    tt.style.left = Math.min(sx(idx) + 16, cw - 180) + 'px';
    tt.style.top = Math.max(sy(dd.high || dd.price) - 90, 0) + 'px';
    tt.innerHTML = '<div class="tt-price">' + fmt$(dd.price) + '</div>'
      + (dd.open != null ? '<div class="tt-line" style="color:var(--dim)">O ' + fmt$(dd.open) + ' · H ' + fmt$(dd.high) + ' · L ' + fmt$(dd.low) + '</div>' : '')
      + '<div class="tt-line" style="color:#e84057">NAV: ' + fmt$(navPerToken) + '</div>'
      + '<div class="tt-line" style="color:' + (belowNAV ? '#e84057' : '#00e5a0') + '">' + pctNAV.toFixed(1) + '% ' + (belowNAV ? 'below' : 'above') + ' NAV</div>'
      + '<div class="tt-date">' + dd.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) + '</div>';
  });
  canvas.addEventListener('mouseleave', function() { tt.style.display = 'none'; });
}

function drawNAVChart(candles, navPerToken) {
  var container = document.getElementById('chart-container');
  container.innerHTML = '';
  var n = candles.length;
  if (n === 0) { container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;font-size:12px;color:#555560">No chart data available</div>'; return; }

  var dpr = window.devicePixelRatio || 1;
  var cw = Math.min(920, container.clientWidth);
  var ch = 400;
  var mg = { top: 24, right: 72, bottom: 52, left: 16 };
  var w = cw - mg.left - mg.right;
  var h = ch - mg.top - mg.bottom;

  var canvas = document.createElement('canvas');
  canvas.width = cw * dpr; canvas.height = ch * dpr;
  canvas.style.width = cw + 'px'; canvas.style.height = ch + 'px';
  canvas.style.cursor = 'crosshair';
  container.appendChild(canvas);
  var ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);

  // Fixed-width based on zoom
  var candleW = Math.max(1, Math.floor(w / _chartVisible));
  var totalBlockW = n * candleW;
  var defaultOffset = w - totalBlockW;
  var blockX = mg.left + defaultOffset + _chartScrollPx;
  var minScroll = -(w - candleW);
  var maxScroll = Math.max(0, (n - 1) * candleW);
  _chartScrollPx = Math.max(minScroll, Math.min(maxScroll, _chartScrollPx));
  blockX = mg.left + defaultOffset + _chartScrollPx;

  var sx = function(i) { return blockX + i * candleW + candleW / 2; };
  var visStart = Math.max(0, Math.floor((mg.left - blockX) / candleW));
  var visEnd = Math.min(n, Math.ceil((mg.left + w - blockX) / candleW));

  // Price range from all candles
  var allHigh = -Infinity, allLow = Infinity;
  for (var i = 0; i < n; i++) {
    var p = candles[i].close || candles[i].price;
    if (p > allHigh) allHigh = p;
    if (p < allLow) allLow = p;
  }
  if (navPerToken > allHigh) allHigh = navPerToken;
  if (navPerToken < allLow) allLow = navPerToken;
  var pPad = (allHigh - allLow) * 0.08 || allHigh * 0.05;
  var pMinBase = allLow - pPad;
  var pMaxBase = allHigh + pPad;
  var pMid = (pMinBase + pMaxBase) / 2;
  var pHalf = (pMaxBase - pMinBase) / 2;
  var pRange = pHalf * 2 / _chartYScale;
  var yPanAmount = (_chartScrollY / 300) * pRange;
  pMid += yPanAmount;
  var pMin = pMid - pHalf / _chartYScale;
  var pMax = pMid + pHalf / _chartYScale;

  var sy = function(p) { return mg.top + (1 - (p - pMin) / (pMax - pMin)) * h; };

  // Clip to chart area
  ctx.save();
  ctx.beginPath();
  ctx.rect(mg.left, 0, w, ch);
  ctx.clip();

  // Grid
  ctx.strokeStyle = '#222228'; ctx.lineWidth = 0.5;
  for (var gi = 0; gi <= 6; gi++) {
    var v = pMin + (pMax - pMin) * gi / 6;
    ctx.beginPath(); ctx.moveTo(mg.left, sy(v)); ctx.lineTo(mg.left + w, sy(v)); ctx.stroke();
  }

  // NAV horizontal line
  var navY = sy(navPerToken);
  ctx.strokeStyle = '#e84057'; ctx.lineWidth = 2; ctx.setLineDash([8, 4]);
  ctx.beginPath(); ctx.moveTo(mg.left, navY); ctx.lineTo(mg.left + w, navY); ctx.stroke();
  ctx.setLineDash([]);

  // Percentage reference lines from NAV (-10%, -20%, etc. and +10%, +20%, etc.)
  var pctSteps = [10, 20, 30, 40, 50, 60, 70, 80, 90];
  ctx.font = '9px Inter, sans-serif';
  for (var pi = 0; pi < pctSteps.length; pi++) {
    var pct = pctSteps[pi];
    // Below NAV
    var belowPrice = navPerToken * (1 - pct / 100);
    var belowY = sy(belowPrice);
    if (belowY > mg.top && belowY < mg.top + h) {
      ctx.strokeStyle = 'rgba(232,64,87,0.25)'; ctx.lineWidth = 0.5; ctx.setLineDash([4, 4]);
      ctx.beginPath(); ctx.moveTo(mg.left, belowY); ctx.lineTo(mg.left + w, belowY); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = 'rgba(232,64,87,0.5)'; ctx.textAlign = 'right';
      ctx.fillText('-' + pct + '%', mg.left + w - 4, belowY - 3);
    }
    // Above NAV
    var abovePrice = navPerToken * (1 + pct / 100);
    var aboveY = sy(abovePrice);
    if (aboveY > mg.top && aboveY < mg.top + h) {
      ctx.strokeStyle = 'rgba(0,229,160,0.25)'; ctx.lineWidth = 0.5; ctx.setLineDash([4, 4]);
      ctx.beginPath(); ctx.moveTo(mg.left, aboveY); ctx.lineTo(mg.left + w, aboveY); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = 'rgba(0,229,160,0.5)'; ctx.textAlign = 'right';
      ctx.fillText('+' + pct + '%', mg.left + w - 4, aboveY - 3);
    }
  }

  // Fill areas between price line and NAV line — green above, red below
  // Build the price path for visible range
  var fillStart = Math.max(0, visStart);
  var fillEnd = Math.min(n, visEnd);

  // Green fill (price above NAV)
  ctx.beginPath();
  for (var fi = fillStart; fi < fillEnd; fi++) {
    var px = sx(fi);
    var pp = candles[fi].close || candles[fi].price;
    var priceY = sy(pp);
    var clampedY = Math.min(priceY, navY); // only above NAV
    if (fi === fillStart) ctx.moveTo(px, navY);
    ctx.lineTo(px, clampedY);
  }
  ctx.lineTo(sx(fillEnd - 1), navY);
  ctx.closePath();
  ctx.fillStyle = 'rgba(0,229,160,0.15)';
  ctx.fill();

  // Red fill (price below NAV)
  ctx.beginPath();
  for (var ri = fillStart; ri < fillEnd; ri++) {
    var rx = sx(ri);
    var rp = candles[ri].close || candles[ri].price;
    var rpY = sy(rp);
    var clampedRY = Math.max(rpY, navY); // only below NAV
    if (ri === fillStart) ctx.moveTo(rx, navY);
    ctx.lineTo(rx, clampedRY);
  }
  ctx.lineTo(sx(fillEnd - 1), navY);
  ctx.closePath();
  ctx.fillStyle = 'rgba(232,64,87,0.15)';
  ctx.fill();

  // Price line
  ctx.beginPath();
  ctx.strokeStyle = '#f0f0f5'; ctx.lineWidth = 2;
  for (var li = fillStart; li < fillEnd; li++) {
    var lx = sx(li);
    var lp = candles[li].close || candles[li].price;
    if (li === fillStart) ctx.moveTo(lx, sy(lp));
    else ctx.lineTo(lx, sy(lp));
  }
  ctx.stroke();

  // Color the line segments green/red
  for (var si = fillStart; si < fillEnd - 1; si++) {
    var x1 = sx(si), x2 = sx(si + 1);
    var p1 = candles[si].close || candles[si].price;
    var p2 = candles[si + 1].close || candles[si + 1].price;
    var above = (p1 + p2) / 2 >= navPerToken;
    ctx.beginPath();
    ctx.strokeStyle = above ? '#00e5a0' : '#e84057';
    ctx.lineWidth = 2.5;
    ctx.moveTo(x1, sy(p1));
    ctx.lineTo(x2, sy(p2));
    ctx.stroke();
  }

  // Current price dot
  var last = candles[n - 1];
  var lastX = sx(n - 1);
  if (lastX >= mg.left && lastX <= mg.left + w) {
    var lastAbove = last.price >= navPerToken;
    ctx.fillStyle = lastAbove ? '#00e5a0' : '#e84057';
    ctx.beginPath(); ctx.arc(lastX, sy(last.price), 5, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = '#0c0c10'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(lastX, sy(last.price), 5, 0, Math.PI * 2); ctx.stroke();
  }

  ctx.restore(); // end clip

  // X labels
  var mo = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  ctx.textAlign = 'center'; ctx.fillStyle = '#555560'; ctx.font = '10px Inter, sans-serif';
  var xStep = Math.max(1, Math.floor(_chartVisible / 8));
  for (var xi = visStart; xi < visEnd; xi += xStep) {
    var xd = candles[xi].date;
    var xPos = sx(xi);
    if (xPos > mg.left && xPos < mg.left + w) {
      ctx.fillText(mo[xd.getMonth()] + '-' + String(xd.getDate()).padStart(2, '0'), xPos, mg.top + h + 20);
    }
  }

  // Y labels (right side)
  var yd = pMax >= 1 ? 2 : pMax >= 0.01 ? 4 : 6;
  ctx.fillStyle = '#555560'; ctx.font = '10px Inter, sans-serif'; ctx.textAlign = 'left';
  for (var yi = 0; yi <= 6; yi++) {
    var yv = pMin + (pMax - pMin) * yi / 6;
    ctx.fillText('$' + yv.toFixed(yd), mg.left + w + 6, sy(yv) + 3);
  }

  // NAV + price labels on right
  ctx.fillStyle = '#e84057'; ctx.font = '11px Inter, sans-serif'; ctx.textAlign = 'left';
  ctx.fillText('NAV ' + fmt$(navPerToken), mg.left + w + 6, navY + 4);
  ctx.fillStyle = '#f0f0f5';
  ctx.fillText(fmt$(last.price), mg.left + w + 6, sy(last.price) + 4);

  // Tooltip
  var tt = document.createElement('div');
  tt.className = 'chart-tooltip';
  container.appendChild(tt);
  canvas.addEventListener('mousemove', function(e) {
    var rect = canvas.getBoundingClientRect();
    var mx = e.clientX - rect.left;
    if (mx < mg.left || mx > mg.left + w) { tt.style.display = 'none'; return; }
    var idx = Math.round((mx - blockX) / candleW - 0.5);
    idx = Math.max(0, Math.min(n - 1, idx));
    var dd = candles[idx];
    var belowNAV = dd.price < navPerToken;
    var pctNAV = navPerToken > 0 ? Math.abs((dd.price - navPerToken) / navPerToken * 100) : 0;
    tt.style.display = 'block';
    tt.style.left = Math.min(sx(idx) + 16, cw - 180) + 'px';
    tt.style.top = Math.max(sy(dd.price) - 70, 0) + 'px';
    tt.innerHTML = '<div class="tt-price">' + fmt$(dd.price) + '</div>'
      + '<div class="tt-line" style="color:#e84057">NAV: ' + fmt$(navPerToken) + '</div>'
      + '<div class="tt-line" style="color:' + (belowNAV ? '#e84057' : '#00e5a0') + '">' + pctNAV.toFixed(1) + '% ' + (belowNAV ? 'below' : 'above') + ' NAV</div>'
      + '<div class="tt-date">' + dd.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) + '</div>';
  });
  canvas.addEventListener('mouseleave', function() { tt.style.display = 'none'; });
}

// Dispatcher — calls the right chart based on view mode
function renderChart(candles, navPerToken) {
  if (_chartViewMode === 'nav') {
    drawNAVChart(candles, navPerToken);
  } else {
    drawChart(candles, navPerToken);
  }
}

function initChart(rawCandles, navPerToken) {
  _allCandles['1D'] = rawCandles;
  _navPerToken = navPerToken;
  _chartTF = '1D';
  _chartScrollPx = 0;
  _chartVisible = Math.min(60, rawCandles.length);

  function currentCandles() { return _allCandles[_chartTF] || rawCandles; }
  function redraw() { renderChart(currentCandles(), _navPerToken); }

  redraw();

  // Wheel: deltaX = horizontal pan (two-finger swipe), deltaY = zoom (pinch/scroll)
  var container = document.getElementById('chart-container');
  container.addEventListener('wheel', function(e) {
    e.preventDefault();
    if (Math.abs(e.deltaX) > Math.abs(e.deltaY)) {
      // Horizontal swipe — pan the chart
      _chartScrollPx -= e.deltaX;
      redraw();
    } else {
      // Vertical scroll — zoom, right side (recent) expands slowly, left side (old) expands faster
      var rect = container.getBoundingClientRect();
      var mx = e.clientX - rect.left;
      var cw = Math.min(920, container.clientWidth);
      var mgLeft = 16, mgRight = 72;
      var ww = cw - mgLeft - mgRight;
      
      var oldCandleW = Math.max(1, Math.floor(ww / _chartVisible));
      // Zoom rate scales up as you zoom out further — 2% of current visible
      var zoomAmt = Math.max(1, Math.round(_chartVisible * 0.02));
      
      if (e.deltaY < 0) {
        // Scroll up = skinnier = more candles
        _chartVisible = Math.min(5000, _chartVisible + zoomAmt);
      } else {
        // Scroll down = fatter = fewer candles
        _chartVisible = Math.max(3, _chartVisible - zoomAmt);
      }
      
      var newCandleW = Math.max(1, Math.floor(ww / _chartVisible));
      
      // Asymmetric anchor: anchor point at 7/8 of the way from left
      // This means right side (recent candles) barely moves, left side expands more
      var anchorPx = ww * (7 / 8);
      var scale = newCandleW / oldCandleW;
      _chartScrollPx = _chartScrollPx * scale + anchorPx * (1 - scale);
      
      redraw();
    }
  }, { passive: false });

  // Pan with click-drag on container (chart area = horizontal pan, right edge = Y scale)
  var dragging = false, yDragging = false, dragStartX = 0, dragStartY = 0, dragStartScroll = 0, dragStartScrollY = 0, dragStartYScale = 1;
  container.addEventListener('mousedown', function(e) {
    var rect = container.getBoundingClientRect();
    var mx = e.clientX - rect.left;
    var my = e.clientY - rect.top;
    // Find the canvas to get its actual width
    var cvs = container.querySelector('canvas');
    var canvasW = cvs ? cvs.offsetWidth : Math.min(920, container.clientWidth);
    // Y-axis zone: right 80px of canvas area (price labels + drag zone)
    var chartLeft = 16; // mg.left
    var yZoneStart = canvasW - 80;

    if (mx >= yZoneStart && my >= 24 && my <= 376) {
      // Clicked on Y-axis label area — vertical scale drag
      e.preventDefault();
      yDragging = true; dragStartY = e.clientY; dragStartYScale = _chartYScale;
      container.style.cursor = 'ns-resize';
    } else if (mx >= chartLeft && mx < yZoneStart) {
      // Clicked on chart area — horizontal + vertical pan
      dragging = true; dragStartX = e.clientX; dragStartY = e.clientY;
      dragStartScroll = _chartScrollPx; dragStartScrollY = _chartScrollY;
      container.style.cursor = 'grabbing';
    }
  });
  window.addEventListener('mousemove', function(e) {
    if (dragging) {
      var dx = e.clientX - dragStartX;
      var dy = e.clientY - dragStartY;
      _chartScrollPx = dragStartScroll + dx;
      _chartScrollY = dragStartScrollY + dy;
      redraw();
    } else if (yDragging) {
      var dy = e.clientY - dragStartY;
      _chartYScale = Math.max(0.2, Math.min(10, dragStartYScale * Math.pow(1.01, -dy)));
      redraw();
    }
  });
  window.addEventListener('mouseup', function() {
    if (dragging || yDragging) { dragging = false; yDragging = false; container.style.cursor = ''; }
  });

  // Cursor hint for Y-axis zone
  container.addEventListener('mousemove', function(e) {
    if (dragging || yDragging) return;
    var rect = container.getBoundingClientRect();
    var mx = e.clientX - rect.left;
    var my = e.clientY - rect.top;
    var cvs = container.querySelector('canvas');
    var canvasW = cvs ? cvs.offsetWidth : Math.min(920, container.clientWidth);
    var yZoneStart = canvasW - 80;
    container.style.cursor = (mx >= yZoneStart && my >= 24 && my <= 376) ? 'ns-resize' : '';
  });

  // Timeframe buttons
  var controls = document.getElementById('chart-controls');
  if (controls) {
    controls.addEventListener('click', async function(e) {
      var btn = e.target.closest('.chart-btn');
      if (!btn) return;

      // View toggle (Candle / NAV)
      if (btn.dataset.view) {
        document.querySelectorAll('#chart-view-toggle .chart-btn').forEach(function(b) { b.classList.remove('active'); });
        btn.classList.add('active');
        _chartViewMode = btn.dataset.view;
        redraw();
        return;
      }

      // Timeframe toggle
      if (btn.dataset.tf) {
        controls.querySelectorAll('[data-tf]').forEach(function(b) { b.classList.remove('active'); });
        btn.classList.add('active');
        _chartTF = btn.dataset.tf;
        _chartScrollPx = 0;
        _chartScrollY = 0;
        _chartYScale = 1.0;
        var candles = await fetchCandlesForTF(_chartTF);
        if (candles.length === 0) candles = rawCandles;
        _chartVisible = Math.min(60, candles.length);
        redraw();
        renderNAVStats(candles, _navPerToken);
      }
    });
  }

  // Resize
  var resizeTimer;
  window.addEventListener('resize', function() {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(redraw, 400);
  });
}

// ═══════════════════════════════════════════════════════════════════════
// RENDER UI
// ═══════════════════════════════════════════════════════════════════════
function renderUI(isLive) {
  const supplyForNAV = CFG.effectiveSupply || CFG.supply;
  const strike = CFG.treasuryUSDC / supplyForNAV;
  const itm = CFG.spot < strike;
  const monthsLeft = CFG.monthlyBurn > 0 ? Math.floor(CFG.treasuryUSDC / CFG.monthlyBurn) : '\u221e';
  const discPct = strike > 0 ? ((CFG.spot - strike) / strike * 100) : 0;
  const isDiscount = discPct < 0;

  document.getElementById('sub-line').innerHTML = CFG.pair + ' \u00b7 FUTARCHY CPMM \u00b7 <span class="data-tag">' + (isLive ? 'LIVE' : 'SNAPSHOT') + '</span>';
  document.getElementById('title').textContent = CFG.ticker + ' \u2014 ' + (itm ? 'Trading Below Treasury Floor' : 'Trading Above Treasury Floor');
  document.getElementById('desc').innerHTML =
    CFG.ticker + ' is trading at <b>' + fmt$(CFG.spot) + '</b>, ' + (itm ? 'below' : 'above') + ' the <b>' + fmt$(strike) + '</b> treasury floor (treasury/token). ' +
    'Token holders can vote for dissolution and claim their pro-rata share of the treasury. ' +
    (itm ? 'Currently trading at a <span class="hl-orange">' + Math.abs(discPct).toFixed(1) + '%</span> discount \u2014 each token is backed by more than its market price.' : '');

  document.getElementById('cards').innerHTML =
    '<div class="card"><div class="card-label">Treasury</div><div class="card-value" style="color:var(--green)">' + fmtM(CFG.treasuryUSDC) + '</div><div class="card-sub">' + fmtM(CFG.monthlyBurn) + '/mo burn</div></div>' +
    '<div class="card"><div class="card-label">Spot Price</div><div class="card-value" style="color:var(--white)">' + fmt$(CFG.spot) + '</div><div class="card-sub">current market price</div></div>' +
    '<div class="card"><div class="card-label">Backing / Token</div><div class="card-value" style="color:var(--white)">' + fmt$(strike) + '</div><div class="card-sub">treasury \u00f7 holder supply</div></div>' +
    '<div class="card"><div class="card-label">' + (isDiscount ? 'Discount' : 'Premium') + '</div><div class="card-value" style="color:' + (isDiscount ? 'var(--red)' : 'var(--green)') + '">' + (isDiscount ? Math.abs(discPct).toFixed(1) + '%' : '+' + discPct.toFixed(0) + '%') + '</div><div class="card-sub">' + (isDiscount ? 'below treasury floor' : 'above treasury floor') + '</div></div>' +
    '<div class="card"><div class="card-label">Runway</div><div class="card-value" style="color:var(--orange)">' + monthsLeft + ' mo</div><div class="card-sub">at current burn rate</div></div>';

  document.getElementById('params').innerHTML =
    '<span>Raise <b>' + fmtM(CFG.raise) + '</b></span>' +
    '<span>Supply <b>' + (supplyForNAV / 1e6).toFixed(1) + 'M</b></span>' +
    '<span>S\u2080 <b>' + fmt$(CFG.icoPrice) + '</b></span>' +
    '<span>NAV <span class="hl">' + fmt$(strike) + '</span></span>' +
    '<span>Spot now <span class="spot">' + fmt$(CFG.spot) + '</span></span>' +
    '<span>ATH <b>' + fmt$(CFG.ath) + '</b></span>' +
    '<span>Burn <b>' + fmtBurn(CFG.monthlyBurn) + '/mo</b></span>';

  document.getElementById('chart-label').innerHTML = CFG.ticker + ' Price History \u2014 <span style="color:#e84057">dashed line = NAV (treasury \u00f7 holder supply)</span>';
  document.getElementById('leg-spot-label').textContent = CFG.ticker + ' bullish';
  document.getElementById('leg-strike').textContent = fmt$(strike);

  return strike;
}

// ═══════════════════════════════════════════════════════════════════════
// NAV STATS BAR
// ═══════════════════════════════════════════════════════════════════════
function renderNAVStats(candles, navPerToken) {
  var bar = document.getElementById('nav-stats-bar');
  if (!bar || !candles || candles.length === 0 || !navPerToken) { if (bar) bar.innerHTML = ''; return; }

  var aboveDays = 0, belowDays = 0;
  var currentStreak = 0, currentAbove = false;
  var maxAboveStreak = 0, maxBelowStreak = 0;
  var tempAbove = 0, tempBelow = 0;
  var avgAbovePct = 0, avgBelowPct = 0;
  var abovePctSum = 0, belowPctSum = 0;

  for (var i = 0; i < candles.length; i++) {
    var p = candles[i].close || candles[i].price;
    var pct = (p - navPerToken) / navPerToken * 100;
    if (p >= navPerToken) {
      aboveDays++;
      abovePctSum += pct;
      tempAbove++;
      if (tempAbove > maxAboveStreak) maxAboveStreak = tempAbove;
      tempBelow = 0;
    } else {
      belowDays++;
      belowPctSum += Math.abs(pct);
      tempBelow++;
      if (tempBelow > maxBelowStreak) maxBelowStreak = tempBelow;
      tempAbove = 0;
    }
  }

  var total = aboveDays + belowDays;
  var abovePct = total > 0 ? (aboveDays / total * 100) : 0;
  var belowPct = total > 0 ? (belowDays / total * 100) : 0;
  var avgAbove = aboveDays > 0 ? (abovePctSum / aboveDays) : 0;
  var avgBelow = belowDays > 0 ? (belowPctSum / belowDays) : 0;

  // Current streak
  var lastP = candles[candles.length - 1].close || candles[candles.length - 1].price;
  var isAboveNow = lastP >= navPerToken;
  currentStreak = 0;
  for (var j = candles.length - 1; j >= 0; j--) {
    var jp = candles[j].close || candles[j].price;
    if ((jp >= navPerToken) === isAboveNow) currentStreak++;
    else break;
  }

  bar.innerHTML =
    '<div class="ns-item ns-above">' +
      '<div class="ns-label">Time Above NAV</div>' +
      '<div class="ns-value">' + abovePct.toFixed(1) + '%</div>' +
      '<div class="ns-sub">' + aboveDays + ' of ' + total + ' periods · avg +' + avgAbove.toFixed(1) + '%</div>' +
      '<div class="ns-progress"><div class="ns-progress-fill" style="width:' + abovePct + '%;background:#00e5a0"></div></div>' +
    '</div>' +
    '<div class="ns-item ns-below">' +
      '<div class="ns-label">Time Below NAV</div>' +
      '<div class="ns-value">' + belowPct.toFixed(1) + '%</div>' +
      '<div class="ns-sub">' + belowDays + ' of ' + total + ' periods · avg -' + avgBelow.toFixed(1) + '%</div>' +
      '<div class="ns-progress"><div class="ns-progress-fill" style="width:' + belowPct + '%;background:#e84057"></div></div>' +
    '</div>' +
    '<div class="ns-item ns-neutral">' +
      '<div class="ns-label">Current Streak</div>' +
      '<div class="ns-value" style="color:' + (isAboveNow ? '#00e5a0' : '#e84057') + '">' + currentStreak + ' periods</div>' +
      '<div class="ns-sub">' + (isAboveNow ? 'above' : 'below') + ' NAV · longest ' + (isAboveNow ? maxAboveStreak + ' above' : maxBelowStreak + ' below') + '</div>' +
    '</div>';
}

// ═══════════════════════════════════════════════════════════════════════
// ADDRESS SECTION
// ═══════════════════════════════════════════════════════════════════════
function renderAddresses() {
  const section = document.getElementById('addr-section');
  if (!section) return;
  const truncAddr = a => a.slice(0, 6) + '…' + a.slice(-4);
  const solscanType = (label) => label === 'Token CA' ? 'token' : 'account';
  const addrs = [];
  if (CFG.mint) addrs.push(['Token CA', CFG.mint]);
  if (CFG.daoWallet) addrs.push(['DAO Treasury', CFG.daoWallet]);
  if (CFG.ammWallet) addrs.push(['AMM Pool 1', CFG.ammWallet]);
  if (CFG.ammWallet2) addrs.push(['AMM Pool 2', CFG.ammWallet2]);
  if (CFG.lockWallet) addrs.push(['Lock Contract', CFG.lockWallet]);
  if (CFG.buybackWallet) addrs.push(['Buyback Wallet', CFG.buybackWallet]);

  section.innerHTML = '<div class="addr-title">On-Chain Addresses</div>' +
    addrs.map(function(a) {
      var label = a[0], addr = a[1];
      var type = solscanType(label);
      return '<div class="addr-row"><span class="addr-label">' + label + '</span><div class="addr-val">' +
        '<a href="https://solscan.io/' + type + '/' + addr + '" target="_blank">' + truncAddr(addr) + '</a>' +
        '<button class="addr-copy" onclick="navigator.clipboard.writeText(\'' + addr + '\');this.textContent=\'Copied!\';this.classList.add(\'copied\');setTimeout(function(){this.textContent=\'Copy\';this.classList.remove(\'copied\')}.bind(this),1500)">Copy</button>' +
        '</div></div>';
    }).join('');
}

// ═══════════════════════════════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════════════════════════════
(async function main() {
  if (!CFG.live) return;
  CFG.effectiveSupply = CFG.supply;
  var navPerToken = renderUI(false);
  renderAddresses();

  try {
    var results = await Promise.all([fetchOHLCV(), fetchFromAPI()]);
    var ohlcv = results[0], apiOk = results[1];
    var isLive = !!(ohlcv || apiOk);
    navPerToken = renderUI(isLive);

    var chartData = (ohlcv && ohlcv.length > 0) ? ohlcv : genFallback();

    if (apiOk && chartData.length > 0) {
      var lastCandle = chartData[chartData.length - 1];
      if (Math.abs(lastCandle.price - CFG.spot) > CFG.spot * 0.01) {
        chartData.push({ date: new Date(), open: lastCandle.price, high: Math.max(lastCandle.price, CFG.spot), low: Math.min(lastCandle.price, CFG.spot), close: CFG.spot, price: CFG.spot });
      }
    }

    var loadEl = document.getElementById('chart-loading');
    if (loadEl) loadEl.remove();
    initChart(chartData, navPerToken);
    renderNAVStats(chartData, navPerToken);

    if (!ohlcv) {
      var notice = document.createElement('div');
      notice.style.cssText = 'text-align:center;font-size:9px;color:#ff8c42;font-family:Inter,sans-serif;padding:6px 0';
      notice.textContent = '\u26a0 Chart API unreachable \u2014 showing simulated data.';
      document.getElementById('chart-container').appendChild(notice);
    }

    console.log('NAVgator ' + CFG.ticker + ' | Live: ' + isLive + ' | OHLCV: ' + (ohlcv ? ohlcv.length + ' candles' : 'fallback') + ' | Spot: $' + CFG.spot + ' | Treasury: $' + CFG.treasuryUSDC.toLocaleString() + ' | EffSupply: ' + (CFG.effectiveSupply || CFG.supply).toLocaleString() + ' | NAV: $' + navPerToken.toFixed(6));
  } catch (err) {
    console.error('NAVgator init error:', err);
    var loadEl2 = document.getElementById('chart-loading');
    if (loadEl2) loadEl2.remove();
    initChart(genFallback(), navPerToken);
    var notice2 = document.createElement('div');
    notice2.style.cssText = 'text-align:center;font-size:9px;color:#e84057;font-family:Inter,sans-serif;padding:6px 0';
    notice2.textContent = '\u26a0 Error loading data \u2014 showing simulated chart.';
    document.getElementById('chart-container').appendChild(notice2);
  }
})();
} // end if (_hasToken)
</script>
</body>
</html>
