<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NAVgator · Dashboard</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=DM+Serif+Display&family=JetBrains+Mono:wght@300;400;500&display=swap');
  :root {
    --bg: #0c0c10; --bg2: #141418; --bg3: #1a1a20;
    --border: #222228; --border2: #2a2a32;
    --dim: #555560; --muted: #77778a; --text: #a0a0b0; --bright: #d0d0dd; --white: #eeeef2;
    --green: #00e5a0; --green-dim: rgba(0,229,160,0.10);
    --red: #e84057; --orange: #f59e42; --blue: #5b8def; --purple: #9f8cfc;
    --card-bg: #16161c; --card-border: #24242c;
  }
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: 'Inter', -apple-system, system-ui, sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; -webkit-font-smoothing: antialiased; }
  ::selection { background: rgba(0,229,160,0.25); }

  .wrap { max-width: 980px; margin: 0 auto; padding: 40px 32px 64px; }

  /* Nav bar */
  .nav { display: flex; align-items: center; gap: 16px; margin-bottom: 32px; flex-wrap: wrap; }
  .nav-brand { font-family: 'DM Serif Display', serif; font-size: 18px; font-weight: 400; color: var(--white); text-decoration: none; letter-spacing: -0.3px; display: flex; align-items: center; gap: 8px; }
  .nav-brand span { color: var(--green); }
  .nav-brand-icon { display: inline-flex; align-items: center; justify-content: center; width: 26px; height: 26px; border-radius: 6px; background: linear-gradient(135deg, var(--green), #00b880); font-family: 'DM Serif Display', serif; font-size: 13px; font-weight: 400; color: #0c0c10; flex-shrink: 0; }
  .nav-sep { color: var(--dim); }
  .nav-tokens { display: flex; gap: 6px; flex-wrap: wrap; }
  .nav-tok { font-family: 'Inter', sans-serif; font-size: 10px; font-weight: 500; letter-spacing: 0.8px; text-transform: uppercase; padding: 5px 12px; border-radius: 6px; border: 1px solid var(--border2); color: var(--muted); text-decoration: none; transition: all 0.2s; }
  .nav-tok:hover { border-color: var(--green); color: var(--white); background: rgba(255,255,255,0.03); }
  .nav-tok.active { border-color: var(--green); color: var(--green); background: var(--green-dim); }

  /* Subheader line */
  .sub { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 500; color: var(--muted); letter-spacing: 1.5px; text-transform: uppercase; margin-bottom: 10px; }
  .sub .data-tag { color: var(--green); }

  /* Title */
  h1 { font-family: 'DM Serif Display', serif; font-size: 42px; font-weight: 400; color: var(--white); margin-bottom: 12px; line-height: 1.1; letter-spacing: -0.5px; }

  /* Description */
  .desc { font-family: 'Inter', sans-serif; font-size: 14px; font-weight: 400; color: var(--muted); line-height: 1.7; max-width: 740px; margin-bottom: 32px; }
  .desc b { color: var(--white); font-weight: 600; }
  .desc .hl-orange { color: var(--orange); font-weight: 600; }
  .desc .hl-green { color: var(--green); font-weight: 600; }

  /* 5 metric cards row */
  .cards { display: grid; grid-template-columns: repeat(5, 1fr); gap: 14px; margin-bottom: 24px; }
  @media (max-width: 800px) { .cards { grid-template-columns: repeat(3, 1fr); } }
  @media (max-width: 500px) { .cards { grid-template-columns: repeat(2, 1fr); } h1 { font-size: 30px; } }
  .card { border: 1px solid var(--card-border); border-radius: 12px; padding: 20px 22px; background: var(--card-bg); }
  .card-label { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 500; color: var(--muted); margin-bottom: 10px; }
  .card-value { font-family: 'DM Serif Display', serif; font-size: 32px; font-weight: 400; line-height: 1.1; color: var(--white); }
  .card-sub { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 400; color: var(--dim); margin-top: 6px; }

  /* Params bar */
  .params { display: flex; flex-wrap: wrap; gap: 6px 24px; font-family: 'Inter', sans-serif; font-size: 12px; font-weight: 400; color: var(--dim); padding: 14px 0; border-top: 1px solid var(--border); border-bottom: 1px solid var(--border); margin-bottom: 28px; }
  .params b { color: var(--text); font-weight: 600; }
  .params .hl { color: var(--green); font-weight: 600; }
  .params .spot { color: var(--red); font-weight: 600; }

  /* Chart section */
  .chart-section { background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 14px; padding: 24px 20px 16px; margin-bottom: 28px; position: relative; }
  .chart-title { font-family: 'Inter', sans-serif; font-size: 12px; font-weight: 500; color: var(--muted); margin-bottom: 16px; }
  .chart-title span { color: var(--red); }
  .chart-controls { display: flex; gap: 6px; position: absolute; top: 20px; right: 20px; z-index: 2; }
  .chart-btn { font-family: 'Inter', sans-serif; font-size: 10px; font-weight: 500; padding: 5px 12px; border-radius: 6px; border: 1px solid var(--border2); color: var(--muted); background: transparent; cursor: pointer; transition: all 0.2s; }
  .chart-btn:hover { border-color: var(--green); color: var(--white); }
  .chart-btn.active { border-color: var(--green); color: var(--green); background: var(--green-dim); }
  #chart-container { width: 100%; height: 400px; position: relative; }
  .chart-loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); font-size: 12px; color: var(--dim); }

  /* Tooltip */
  .chart-tooltip { position: absolute; display: none; pointer-events: none; background: rgba(12,12,16,0.96); border: 1px solid var(--card-border); border-radius: 10px; padding: 12px 16px; z-index: 10; backdrop-filter: blur(8px); }
  .tt-price { font-family: 'DM Serif Display', serif; font-size: 22px; font-weight: 400; color: var(--white); margin-bottom: 4px; }
  .tt-line { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 400; margin-top: 3px; }
  .tt-date { font-family: 'Inter', sans-serif; font-size: 10px; color: var(--dim); margin-top: 6px; }

  /* Legend */
  .legend { display: flex; flex-wrap: wrap; gap: 18px; padding: 12px 4px 0; font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 400; color: var(--muted); }
  .legend-item { display: flex; align-items: center; gap: 6px; }
  .legend-line { display: inline-block; width: 18px; height: 2.5px; border-radius: 2px; }
  .legend-fill { display: inline-block; width: 12px; height: 12px; border-radius: 2px; }
  .legend-dash { display: inline-block; width: 16px; height: 0; border-top: 2px dashed; }

  .footer { font-family: 'Inter', sans-serif; font-size: 10px; font-weight: 400; color: var(--dim); text-align: center; padding: 24px 0; border-top: 1px solid var(--border); }
  .footer a { color: var(--muted); text-decoration: underline; }

  /* ── Landing page styles ── */
  .landing { display: none; }
  .landing.active { display: block; }
  .dashboard { display: none; }
  .dashboard.active { display: block; }
  .hero { padding: 80px 0 48px; text-align: center; }
  .logo-mark { display: inline-flex; align-items: center; justify-content: center; width: 64px; height: 64px; border-radius: 16px; background: linear-gradient(135deg, var(--green), #00b880); font-family: 'DM Serif Display', serif; font-size: 30px; font-weight: 400; color: #0c0c10; margin-bottom: 24px; box-shadow: 0 0 60px rgba(0,229,160,0.15), 0 0 120px rgba(0,229,160,0.05); animation: float 6s ease-in-out infinite; position: relative; }
  .logo-mark::after { content: ''; position: absolute; inset: -1px; border-radius: 17px; background: linear-gradient(135deg, rgba(0,229,160,0.4), rgba(0,184,128,0.1)); z-index: -1; filter: blur(1px); }
  @keyframes float { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-6px)} }
  .hero h1 { font-family: 'DM Serif Display', serif; font-size: 52px; font-weight: 400; color: var(--white); line-height: 1.1; margin-bottom: 14px; letter-spacing: -1px; }
  .hero h1 span { color: var(--green); }
  .tagline { font-family: 'Inter', sans-serif; font-size: 15px; font-weight: 400; color: var(--muted); line-height: 1.7; max-width: 540px; margin: 0 auto 40px; }
  .sort-bar { display: flex; align-items: center; gap: 8px; margin-bottom: 16px; flex-wrap: wrap; }
  .sort-label { font-family: 'Inter', sans-serif; font-size: 10px; font-weight: 500; letter-spacing: 1.5px; text-transform: uppercase; color: var(--dim); }
  .sort-btn { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 500; padding: 5px 12px; border-radius: 6px; border: 1px solid var(--border2); color: var(--muted); background: transparent; cursor: pointer; transition: all 0.2s; }
  .sort-btn:hover { border-color: var(--green); color: var(--white); background: rgba(255,255,255,0.03); }
  .sort-btn.active { border-color: var(--green); color: var(--green); background: var(--green-dim); }
  .tokens { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 14px; margin-bottom: 48px; }
  .token-card { border: 1px solid var(--card-border); border-radius: 14px; padding: 24px 22px; background: var(--card-bg); text-decoration: none; color: inherit; transition: all 0.25s ease; position: relative; overflow: hidden; }
  .token-card:hover { transform: translateY(-2px); box-shadow: 0 6px 30px rgba(0,229,160,0.06); border-color: var(--border2); }
  .tc-header { display: flex; align-items: center; gap: 10px; margin-bottom: 16px; position: relative; }
  .tc-icon { width: 38px; height: 38px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-family: 'DM Serif Display', serif; font-size: 16px; font-weight: 400; color: #0c0c10; flex-shrink: 0; }
  .tc-name { font-family: 'DM Serif Display', serif; font-size: 18px; font-weight: 400; color: var(--white); }
  .tc-pair { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 400; color: var(--dim); margin-top: 2px; }
  .tc-arrow { position: absolute; top: 0; right: 0; font-size: 16px; color: var(--dim); transition: all 0.25s; }
  .token-card:hover .tc-arrow { color: var(--green); transform: translateX(3px); }
  .tc-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; position: relative; }
  .tc-stat-label { font-family: 'Inter', sans-serif; font-size: 10px; font-weight: 500; color: var(--muted); }
  .tc-stat-val { font-family: 'DM Serif Display', serif; font-size: 16px; font-weight: 400; margin-top: 2px; }
  .how { padding: 36px 0 48px; border-top: 1px solid var(--border); }
  .how h2 { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 600; letter-spacing: 2px; text-transform: uppercase; color: var(--dim); margin-bottom: 24px; }
  .how-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; }
  @media (max-width: 600px) { .how-grid { grid-template-columns: 1fr; } .hero h1 { font-size: 36px; } }
</style>
</head>
<body>

<div class="wrap">

  <!-- ══ LANDING PAGE ══ -->
  <div class="landing" id="landing-view">
    <div class="hero">
      <div class="logo-mark">N</div>
      <h1>NAV<span>gator</span></h1>
      <p class="tagline">Real-time NAV analytics for MetaDAO ownership tokens. Treasury tracking, discount/premium metrics, and live on-chain data.</p>
    </div>
    <div class="sort-bar" id="sort-bar">
      <span class="sort-label">Sort by</span>
      <button class="sort-btn active" data-sort="mcap">MCap</button>
      <button class="sort-btn" data-sort="treasury">Treasury</button>
      <button class="sort-btn" data-sort="discount">Discount</button>
    </div>
    <div class="tokens" id="tokens"></div>
    <div class="how">
      <h2>How Treasury Backing Works</h2>
      <div class="how-grid">
        <div class="how-item"><div class="how-num" style="font-size:12px;font-weight:600;color:var(--green);margin-bottom:6px">01</div><div style="font-size:13px;color:var(--white);font-weight:600;margin-bottom:5px">Treasury-backed tokens</div><div style="font-size:12px;color:var(--muted);line-height:1.6">MetaDAO ICOs deposit all raised USDC into an on-chain treasury. The team draws a fixed monthly budget — every dollar is governed by futarchy.</div></div>
        <div class="how-item"><div class="how-num" style="font-size:12px;font-weight:600;color:var(--green);margin-bottom:6px">02</div><div style="font-size:13px;color:var(--white);font-weight:600;margin-bottom:5px">Backing = Treasury ÷ Supply</div><div style="font-size:12px;color:var(--muted);line-height:1.6">Each token has a claim on treasury USDC. When spot trades below backing, you're buying below the treasury floor — dissolution returns more than market price.</div></div>
        <div class="how-item"><div class="how-num" style="font-size:12px;font-weight:600;color:var(--green);margin-bottom:6px">03</div><div style="font-size:13px;color:var(--white);font-weight:600;margin-bottom:5px">Dissolution right</div><div style="font-size:12px;color:var(--muted);line-height:1.6">Any holder can propose dissolution via futarchy. If passed, treasury distributes pro-rata. This creates a soft price floor enforced by rational arbitrage.</div></div>
      </div>
    </div>
    <div class="footer">NAVgator · Treasury analytics for ownership tokens · <a href="https://metadao.fi" target="_blank">MetaDAO</a> · Data via GeckoTerminal + DexScreener + Solana RPC · Not financial advice</div>
  </div>

  <!-- ══ DASHBOARD VIEW ══ -->
  <div class="dashboard" id="dashboard-view">

  <!-- Nav -->
  <nav class="nav" id="nav"></nav>

  <div class="sub" id="sub-line">LOADING…</div>
  <h1 id="title">Loading Dashboard…</h1>
  <div class="desc" id="desc">Fetching data…</div>

  <div class="cards" id="cards"></div>
  <div class="params" id="params"></div>

  <div class="chart-section">
    <div class="chart-title" id="chart-label"></div>
    <div class="chart-controls">
      <button class="chart-btn active" data-view="full">Full</button>
      <button class="chart-btn" data-view="strike">Focus NAV</button>
    </div>
    <div id="chart-container">
      <div class="chart-loading" id="chart-loading">⏳ Fetching price history…</div>
    </div>
    <div class="legend">
      <span class="legend-item"><span class="legend-fill" style="background:#00e5a0"></span> <span id="leg-spot-label">Bullish</span></span>
      <span class="legend-item"><span class="legend-fill" style="background:#e84057"></span> Bearish</span>
      <span class="legend-item"><span class="legend-line" style="background:#e84057"></span> NAV <span id="leg-strike">…</span></span>
    </div>
  </div>

  <div class="footer">
    <a href="index.html">← NAVgator Home</a> · Treasury analytics for ownership tokens · Not financial advice
  </div>

  </div><!-- /dashboard-view -->
</div><!-- /wrap -->

<script>
// ═══════════════════════════════════════════════════════════════════════
// VIEW ROUTING — landing page vs dashboard
// ═══════════════════════════════════════════════════════════════════════
const _params = new URLSearchParams(window.location.search);
const _hasToken = _params.has('token');

if (_hasToken) {
  document.getElementById('dashboard-view').classList.add('active');
  document.title = 'NAVgator · Dashboard';
} else {
  document.getElementById('landing-view').classList.add('active');
  document.title = 'NAVgator — Treasury Analytics for Ownership Tokens';
}

// ═══════════════════════════════════════════════════════════════════════
// TOKEN CONFIGS
// ═══════════════════════════════════════════════════════════════════════
const TOKENS = {
  solo: { live: true,
    name: 'Solomon', ticker: 'SOLO', pair: 'SOLO/USDC',
    color: '#00e5a0',
    mint: 'SoLo9oxzLDpcq1dpqAgMwgce5WqkRDtNXK7EPnbmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: '98SPcyUZ2rqM2dgjCqqSXS4gJrNTLSNUAAVCF38xYj9u',
    ammWallet: 'DzYtzoNvPbyFCzwZA6cSm9eDEEmxEB9f8AGkJXUXgnSA',
    ammWallet2: '2zsbECzM7roqnDcuv2TNGpfv5PAnuqGmMo5YPtqmUz5p',
    gtPool: 'o5rJFXSKTsuws58rBMNPG8jdKdnY4Z7ouU29dyohE4g',
    raise: 8_000_000, supply: 10_000_000, icoPrice: 0.80, ath: 1.09,
    monthlyBurn: 100_000, realizedVol: 99, tradingDays: 85,
    genesisStrike: 0.62, genesisPut: 0.300,
    spot: 0.55, treasuryUSDC: 7_420_000, ammUSDCFixed: null,
    tge: '2025-11-18',
    draws: [
      { date: '2025-12-01', amount: 100_000, label: 'Draw #1' },
      { date: '2026-01-01', amount: 100_000, label: 'Draw #2' },
      { date: '2026-02-01', amount: 100_000, label: 'Draw #3' },
    ],
    fallback: { peakDay: 1, peakPrice: 1.09, bounceDay: 30, bouncePrice: 0.70, listPrice: 0.94, floor: 0.40 },
  },
  zkfg: { live: true,
    name: 'ZKLSOL', ticker: 'ZKFG', pair: 'ZKFG/USDC',
    color: '#9f8cfc',
    mint: 'ZKFHiLAfAFMTcDAuCtjNW54VzpERvoe7PBF9mYgmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: 'BNvDfXYG2FAyBDYD71Xr9GhKE18MbmhtjsLKsCuXho6z',
    ammWallet: '5FPGRzY9ArJFwY2Hp2y2eqMzVewyWCBox7esmpuZfCvE',
    gtPool: 'JDuK4Wp3MQM6d9QKDNDNgoELHkfAMSqbbqzbmkz19vis',
    raise: 970_000, supply: 10_000_000, icoPrice: 0.097, ath: 0.145,
    monthlyBurn: 50_000, realizedVol: 120, tradingDays: 107,
    genesisStrike: 0.097, genesisPut: 0.055,
    spot: 0.0654, treasuryUSDC: 820_000, ammUSDCFixed: null,
    tge: '2025-10-24',
    draws: [
      { date: '2025-11-24', amount: 50_000, label: 'Draw #1' },
      { date: '2025-12-24', amount: 50_000, label: 'Draw #2' },
      { date: '2026-01-24', amount: 50_000, label: 'Draw #3' },
    ],
    fallback: { peakDay: 14, peakPrice: 0.145, bounceDay: 45, bouncePrice: 0.09, listPrice: 0.0687, floor: 0.02 },
  },
  umbra: { live: true,
    name: 'Umbra', ticker: 'UMBRA', pair: 'UMBRA/USDC',
    color: '#00c2ff',
    mint: 'PRVT6TB7uss3FrUd2D9xs2zqDBsa3GbMJMwCQsgmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: '6VsC8PuKkXm5xo54c2vbrAaSfQipkpGHqNuKTxXFySx6',
    ammWallet: 'BLkBSE96kQys7SrMioKxeMiVbeo4Ckk2Y4n1JphKxYnv',
    ammWallet2: '7dVri3qjYD3uobSZL3Zth8vSCgU6r6R2nvFsh7uVfDte',
    gtPool: '7dVri3qjYD3uobSZL3Zth8vSCgU6r6R2nvFsh7uVfDte',
    gtPoolLegacy: 'BLkBSE96kQys7SrMioKxeMiVbeo4Ckk2Y4n1JphKxYnv',
    raise: 3_000_000, supply: 10_000_000, icoPrice: 0.30, ath: 2.43,
    monthlyBurn: 34_000, realizedVol: 110, tradingDays: 122,
    genesisStrike: 0.24, genesisPut: 0.12,
    spot: 0.76, treasuryUSDC: 2_860_000, ammUSDCFixed: null,
    tge: '2025-10-10',
    draws: [
      { date: '2025-11-10', amount: 34_000, label: 'Draw #1' },
      { date: '2025-12-10', amount: 34_000, label: 'Draw #2' },
      { date: '2026-01-10', amount: 34_000, label: 'Draw #3' },
      { date: '2026-02-10', amount: 34_000, label: 'Draw #4' },
    ],
    fallback: { peakDay: 3, peakPrice: 2.43, bounceDay: 30, bouncePrice: 1.10, listPrice: 2.31, floor: 0.30 },
  },
  avici: { live: true,
    name: 'Avici', ticker: 'AVICI', pair: 'AVICI/USDC',
    color: '#ff6b9d',
    mint: 'BANKJmvhT8tiJRsBSS1n2HryMBPvT5Ze4HU95DUAmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: 'DGgYoUcu1aDZt4GEL5NQiducwHRGbkMWsUzsXh2j622G',
    ammWallet: '3D854kknnQhu9xVaRNV154oZ9oN2WF3tXsq3LDu7fFMn',
    gtPool: '5gB4NPgFB3MHFHSeKN4sbaY6t9MB8ikCe9HyiKYid4Td',
    gtPoolLegacy: '3D854kknnQhu9xVaRNV154oZ9oN2WF3tXsq3LDu7fFMn',
    raise: 3_500_000, supply: 12_900_000, icoPrice: 0.35, ath: 7.57,
    monthlyBurn: 45_000, realizedVol: 130, tradingDays: 114,
    genesisStrike: 0.22, genesisPut: 0.11,
    spot: 1.08, treasuryUSDC: 3_300_000, ammUSDCFixed: null,
    tge: '2025-10-18',
    draws: [
      { date: '2025-11-18', amount: 45_000, label: 'Draw #1' },
      { date: '2025-12-18', amount: 45_000, label: 'Draw #2' },
      { date: '2026-01-18', amount: 45_000, label: 'Draw #3' },
    ],
    fallback: { peakDay: 40, peakPrice: 7.57, bounceDay: 70, bouncePrice: 3.50, listPrice: 0.50, floor: 0.45 },
  },
  loyal: { live: true,
    name: 'Loyal', ticker: 'LOYAL', pair: 'LOYAL/USDC',
    color: '#ffd700',
    mint: 'LoyALuiy1mRSpjRBRw3iCp88T7xSD4kxTL6uYdpAmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: 'AQyyTwCKemeeMu8ZPZFxrXMbVwAYTSbBhi1w4PBrhvYE',
    ammWallet: 'GxpJkPEsPmuRCCTNnfZaDKg4X3gf4ZPgmqgFqtibaPtK',
    ammWallet2: 'BGg7WsK98rhqtTp2uSKMa2yETqgwShFAjyf1RmYqCF7n',
    buybackWallet: 'AfGAjj7TQByC2WQtCNRhsyq1WeZqmQ7oNRoGb2JbgoQg',
    gtPool: 'BGg7WsK98rhqtTp2uSKMa2yETqgwShFAjyf1RmYqCF7n',
    gtPoolLegacy: 'GxpJkPEsPmuRCCTNnfZaDKg4X3gf4ZPgmqgFqtibaPtK',
    raise: 500_000, supply: 10_000_000, icoPrice: 0.05, ath: 0.37,
    monthlyBurn: 45_000, realizedVol: 140, tradingDays: 114,
    genesisStrike: 0.038, genesisPut: 0.02,
    spot: 0.13, treasuryUSDC: 420_000, ammUSDCFixed: null,
    tge: '2025-10-23',
    draws: [
      { date: '2025-11-23', amount: 45_000, label: 'Draw #1' },
      { date: '2025-12-23', amount: 45_000, label: 'Draw #2' },
      { date: '2026-01-23', amount: 45_000, label: 'Draw #3' },
    ],
    fallback: { peakDay: 1, peakPrice: 0.37, bounceDay: 40, bouncePrice: 0.15, listPrice: 0.09, floor: 0.03 },
  },
  paystream: { live: false,
    name: 'Paystream', ticker: 'PAY', pair: 'PAY/USDC',
    color: '#44ddaa',
    mint: '',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: 'BpXtB2ASf2Tft97ewTd8PayXCqFQ6Wqod33qrwwfK9Vz',
    ammWallet: '6FRXzTe3HajL8Fwmmkupp8g3y3wn3g3QEjj8sABndre3',
    ammWallet2: '6F88Y6iukU9GuL8CMWnx6YT832vBymNPicJBikQWeYe4',
    buybackWallet: '3BAUsXfhhK2H1KH18GYNhUvLUsPrKWcePEA5N2UKP6VL',
    gtPool: '6F88Y6iukU9GuL8CMWnx6YT832vBymNPicJBikQWeYe4',
    gtPoolLegacy: '6FRXzTe3HajL8Fwmmkupp8g3y3wn3g3QEjj8sABndre3',
    raise: 300_000, supply: 10_000_000, icoPrice: 0.03, ath: 0.04,
    monthlyBurn: 15_000, realizedVol: 100, tradingDays: 100,
    genesisStrike: 0.024, genesisPut: 0.012,
    spot: 0.021, treasuryUSDC: 255_000, ammUSDCFixed: null,
    tge: '2025-10-27',
    draws: [
      { date: '2025-11-27', amount: 15_000, label: 'Draw #1' },
      { date: '2025-12-27', amount: 15_000, label: 'Draw #2' },
      { date: '2026-01-27', amount: 15_000, label: 'Draw #3' },
    ],
    fallback: { peakDay: 10, peakPrice: 0.04, bounceDay: 35, bouncePrice: 0.028, listPrice: 0.03, floor: 0.01 },
  },
  omfg: { live: true,
    name: 'Omnipair', ticker: 'OMFG', pair: 'OMFG/USDC',
    color: '#ff8855',
    mint: 'DHW6DToYjhwknzVCDvZ6r7hSv7ZpGw9adEN8NvZuUpVh',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: '34rned2SLUcYjUrM9meQkuyJY4QDBcKhkcUPXCgGuXD9',
    ammWallet: '2WNhaB6TPyZ3ynJjAUM4ZZ1Hdeep8FJ3A76FjGjTVjjS',
    ammWallet2: 'BiNnErm2VDkbKGiABj9ZRUjybz879NhH2heeWE7m5M6d',
    gtPool: 'BiNnErm2VDkbKGiABj9ZRUjybz879NhH2heeWE7m5M6d',
    gtPoolLegacy: '2WNhaB6TPyZ3ynJjAUM4ZZ1Hdeep8FJ3A76FjGjTVjjS',
    raise: 500_000, supply: 10_000_000, icoPrice: 0.05, ath: 0.83,
    monthlyBurn: 25_000, realizedVol: 120, tradingDays: 130,
    genesisStrike: 0.04, genesisPut: 0.02,
    spot: 0.32, treasuryUSDC: 400_000, ammUSDCFixed: null,
    tge: '2025-10-02',
    draws: [
      { date: '2025-11-02', amount: 25_000, label: 'Draw #1' },
      { date: '2025-12-02', amount: 25_000, label: 'Draw #2' },
      { date: '2026-01-02', amount: 25_000, label: 'Draw #3' },
      { date: '2026-02-02', amount: 25_000, label: 'Draw #4' },
    ],
    fallback: { peakDay: 21, peakPrice: 0.83, bounceDay: 50, bouncePrice: 0.50, listPrice: 0.08, floor: 0.04 },
  },
  meta: { live: false,
    name: 'MetaDAO', ticker: 'META', pair: 'META/USDC',
    color: '#ff5533',
    mint: 'METAwkXcqyXKy1AtsSgJ8JiUHwGCafnZL38n3vYmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: 'BfzJzFUeE54zv6Q2QdAZR4yx7UXuYRsfkeeirrRcxDvk',
    ammWallet: 'CUPoiqkK4hxyCiJcLC4yE9AtJP1MoV1vFV2vx3jqwWeS',
    ammWallet2: 'EXpXkwcWDhjEYyC5pfNfxsu8fUtK4CDCYTZR4ApQNRzo',
    gtPool: 'EXpXkwcWDhjEYyC5pfNfxsu8fUtK4CDCYTZR4ApQNRzo',
    gtPoolLegacy: 'CUPoiqkK4hxyCiJcLC4yE9AtJP1MoV1vFV2vx3jqwWeS',
    raise: 0, supply: 22_080_000, icoPrice: 0.17, ath: 10.69,
    monthlyBurn: 0, realizedVol: 95, tradingDays: 300,
    genesisStrike: 0, genesisPut: 0,
    spot: 3.78, treasuryUSDC: 0, ammUSDCFixed: null,
    tge: '2025-04-09',
    draws: [],
    fallback: { peakDay: 140, peakPrice: 10.69, bounceDay: 200, bouncePrice: 5.50, listPrice: 0.50, floor: 0.10 },
    note: 'Platform token — no ICO treasury structure. Treasury analytics are approximate.',
  },
  rngr: { live: true,
    name: 'Ranger', ticker: 'RNGR', pair: 'RNGR/USDC',
    color: '#22dd88',
    mint: 'RNGRtJMbCveqCp7AC6U95KmrdKecFckaJZiWbPGmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: '55H1Q1YrHJQ93uhG4jqrBBHx3a8H7TCM8kvf2UM2g5q3',
    ammWallet: '1PAwyDkWNFCcR96GhEReXHJBv3YEFVazCaQgNicVuKv',
    ammWallet2: '59WuweKV7DAg8aUgRhNytScQxioaFYNJdWnox5FxAXFq',
    buybackWallet: '33AEddb7BxoA7Y65BzybFCV5WyGy7LfBdjiL2anCDEkr',
    gtPool: '59WuweKV7DAg8aUgRhNytScQxioaFYNJdWnox5FxAXFq',
    gtPoolLegacy: '1PAwyDkWNFCcR96GhEReXHJBv3YEFVazCaQgNicVuKv',
    raise: 8_000_000, supply: 10_000_000, icoPrice: 0.60, ath: 0.865,
    monthlyBurn: 250_000, realizedVol: 90, tradingDays: 32,
    genesisStrike: 0.47, genesisPut: 0.18,
    spot: 0.54, treasuryUSDC: 5_750_000, ammUSDCFixed: null,
    tge: '2026-01-10',
    draws: [
      { date: '2026-02-10', amount: 250_000, label: 'Draw #1' },
    ],
    fallback: { peakDay: 1, peakPrice: 0.865, bounceDay: 15, bouncePrice: 0.55, listPrice: 0.81, floor: 0.40 },
  },
};
// ═══════════════════════════════════════════════════════════════════════
// LANDING PAGE LOGIC
// ═══════════════════════════════════════════════════════════════════════
if (!_hasToken) {
  const landingTokens = Object.entries(TOKENS).map(([key, t]) => ({
    key, name: t.ticker, desc: t.name + (t.pair ? ' · ' + t.pair.split('/')[0] : ''),
    color: t.color, spot: t.spot, strike: t.raise > 0 ? t.treasuryUSDC / t.supply : 0,
    treasury: t.treasuryUSDC, mcap: t.spot * t.supply, live: t.live,
  }));
  const lfmt$ = (n) => '$' + (n >= 1 ? n.toFixed(2) : n >= 0.01 ? n.toFixed(4) : n.toFixed(6));
  const lfmtM = n => n>=1e6?'$'+(n/1e6).toFixed(1)+'M':'$'+(n/1e3).toFixed(0)+'K';

  function renderTokens(sortKey) {
    const sorted = [...landingTokens].sort((a, b) => {
      if (sortKey === 'treasury') return b.treasury - a.treasury;
      if (sortKey === 'discount') {
        const da = a.strike > 0 ? (a.strike - a.spot) / a.strike : -999;
        const db = b.strike > 0 ? (b.strike - b.spot) / b.strike : -999;
        return db - da;
      }
      return b.mcap - a.mcap;
    });
    document.getElementById('tokens').innerHTML = sorted.map(t => {
      const noStrike = t.strike === 0;
      const discPct = t.strike > 0 ? ((t.spot - t.strike) / t.strike * 100) : 0;
      const isDiscount = discPct < 0;
      const fmtMcap = t.mcap >= 1e6 ? '$'+(t.mcap/1e6).toFixed(1)+'M' : '$'+(t.mcap/1e3).toFixed(0)+'K';
      const discLabel = noStrike ? 'N/A' : isDiscount ? Math.abs(discPct).toFixed(1) + '% discount' : '+' + discPct.toFixed(0) + '% premium';
      const comingSoon = !t.live;
      const overlay = comingSoon ? '<div style="position:absolute;inset:0;background:rgba(12,12,16,0.82);border-radius:14px;display:flex;align-items:center;justify-content:center;z-index:2"><span style="font-size:12px;font-weight:600;color:var(--muted);letter-spacing:1px;text-transform:uppercase">Coming Soon</span></div>' : '';
      return `<a class="token-card" ${comingSoon?'style="pointer-events:none"':'href="index.html?token='+t.key+'"'} onmouseover="this.style.borderColor='${t.color}'" onmouseout="this.style.borderColor=''">
        ${overlay}
        <div class="tc-header">
          <div class="tc-icon" style="background:${t.color}">${t.name[0]}</div>
          <div><div class="tc-name">${t.name}</div><div class="tc-pair">${t.desc}</div></div>
          <span class="tc-arrow">→</span>
        </div>
        <div class="tc-stats">
          <div><div class="tc-stat-label">Spot</div><div class="tc-stat-val" style="color:var(--white)">${lfmt$(t.spot)}</div></div>
          <div><div class="tc-stat-label">MCap</div><div class="tc-stat-val" style="color:var(--text)">${fmtMcap}</div></div>
          <div><div class="tc-stat-label">${noStrike?'—':'Backing'}</div><div class="tc-stat-val" style="color:#e84057">${noStrike?'N/A':lfmt$(t.strike)}</div></div>
          <div><div class="tc-stat-label">vs NAV</div><div class="tc-stat-val" style="color:${isDiscount?'var(--red)':'var(--green)'}">${discLabel}</div></div>
        </div>
      </a>`;
    }).join('');
  }

  renderTokens('mcap');
  document.getElementById('sort-bar').addEventListener('click', e => {
    const btn = e.target.closest('.sort-btn');
    if (!btn) return;
    document.querySelectorAll('.sort-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    renderTokens(btn.dataset.sort);
  });

  // Fetch live spot prices for all live tokens and re-render
  const HELIUS_RPC = 'https://mainnet.helius-rpc.com/?api-key=6ac6fe69-3333-4cb8-a1ba-03a3d17fa70e';
  const currentSort = () => document.querySelector('.sort-btn.active')?.dataset.sort || 'mcap';

  async function fetchLandingData() {
    const liveEntries = Object.entries(TOKENS).filter(([k, t]) => t.live && t.mint);
    // Fetch spot prices from DexScreener in parallel
    const spotPromises = liveEntries.map(async ([key, t]) => {
      try {
        const res = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${t.mint}`);
        const data = await res.json();
        const pair = data.pairs?.find(p => p.quoteToken?.symbol === 'USDC');
        if (pair) return { key, spot: parseFloat(pair.priceUsd) };
      } catch (e) {}
      return null;
    });
    // Fetch treasury USDC balances from Helius in parallel
    const treasuryPromises = liveEntries.map(async ([key, t]) => {
      try {
        const getBalance = async (owner) => {
          if (!owner) return 0;
          const res = await fetch(HELIUS_RPC, {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ jsonrpc:'2.0', id:1, method:'getTokenAccountsByOwner',
              params: [owner, { mint: t.usdcMint }, { encoding: 'jsonParsed' }] }),
          });
          const json = await res.json();
          let total = 0;
          for (const acct of (json.result?.value || [])) total += acct.account?.data?.parsed?.info?.tokenAmount?.uiAmount || 0;
          return total;
        };
        const [dao, amm, amm2] = await Promise.all([getBalance(t.daoWallet), getBalance(t.ammWallet), getBalance(t.ammWallet2)]);
        const total = dao + amm + amm2;
        if (total > 0) return { key, treasury: total };
      } catch (e) {}
      return null;
    });

    const [spots, treasuries] = await Promise.all([
      Promise.all(spotPromises),
      Promise.all(treasuryPromises),
    ]);

    // Update landingTokens with live data
    for (const s of spots) {
      if (!s) continue;
      const lt = landingTokens.find(t => t.key === s.key);
      if (lt) { lt.spot = s.spot; lt.mcap = s.spot * TOKENS[s.key].supply; }
    }
    for (const tr of treasuries) {
      if (!tr) continue;
      const lt = landingTokens.find(t => t.key === tr.key);
      if (lt) { lt.treasury = tr.treasury; lt.strike = tr.treasury / TOKENS[tr.key].supply; }
    }

    renderTokens(currentSort());
    console.log('NAVgator landing: live data loaded for', spots.filter(Boolean).length, 'tokens');
  }

  fetchLandingData();
}

// ═══════════════════════════════════════════════════════════════════════
// DASHBOARD LOGIC (only when ?token= is present)
// ═══════════════════════════════════════════════════════════════════════
if (_hasToken) {
const params = new URLSearchParams(window.location.search);
const tokenKey = (params.get('token') || 'solo').toLowerCase();
const CFG = TOKENS[tokenKey] || TOKENS.solo;
CFG.rpcUrl = 'https://mainnet.helius-rpc.com/?api-key=6ac6fe69-3333-4cb8-a1ba-03a3d17fa70e';

document.title = `NAVgator · ${CFG.ticker}/USDC — Treasury Analytics`;

// Build nav — dim non-live tokens
const navEl = document.getElementById('nav');
const LIVE_KEYS = new Set(Object.entries(TOKENS).filter(([k,v]) => v.live).map(([k]) => k));
let navHTML = '<a href="index.html" class="nav-brand"><span class="nav-brand-icon">N</span> NAV<span>gator</span></a><span class="nav-sep">·</span><div class="nav-tokens">';
for (const [key, tok] of Object.entries(TOKENS)) {
  const isLive = LIVE_KEYS.has(key);
  const dimStyle = !isLive ? 'opacity:0.35;pointer-events:none;' : '';
  navHTML += `<a class="nav-tok${key===tokenKey?' active':''}" href="index.html?token=${key}" style="${dimStyle}${key===tokenKey?'border-color:'+tok.color+';color:'+tok.color:''}">${tok.ticker}</a>`;
}
navHTML += '</div>';
navEl.innerHTML = navHTML;

// If token is not live, show coming soon overlay and stop
if (!CFG.live) {
  document.getElementById('sub-line').textContent = 'COMING SOON';
  document.getElementById('title').textContent = CFG.name + ' — Coming Soon';
  document.getElementById('desc').innerHTML = `<b>${CFG.ticker}</b> dashboard is under development. Treasury tracking, price charts, and analytics will be available soon.`;
  document.getElementById('cards').innerHTML = '';
  document.getElementById('params').innerHTML = '';
  document.getElementById('chart-loading').textContent = 'Coming Soon';
  const scs = document.getElementById('strike-chart-section');
  if (scs) scs.style.display = 'none';
}

// ═══════════════════════════════════════════════════════════════════════
// MATH
// ═══════════════════════════════════════════════════════════════════════
const pDec = (v) => v >= 1 ? 2 : v >= 0.01 ? 4 : 6;
const fmt$ = (n,d) => '$'+n.toFixed(d !== undefined ? d : pDec(n));
const fmtM = n => n>=1e6?'$'+(n/1e6).toFixed(1)+'M':n>=1e3?'$'+(n/1e3).toFixed(0)+'K':fmt$(n,2);
const fmtBurn = n => n>=1e6?'$'+(n/1e6).toFixed(1)+'M':n>=1e3?'$'+(n/1e3).toFixed(0)+'K':'$'+n;

// ═══════════════════════════════════════════════════════════════════════
// LIVE DATA FETCHERS
// ═══════════════════════════════════════════════════════════════════════
async function fetchOHLCV() {
  if (!CFG.gtPool) return null;
  const fetchPool = async (pool) => {
    try {
      const url = `https://api.geckoterminal.com/api/v2/networks/solana/pools/${pool}/ohlcv/day?aggregate=1&limit=1000&currency=usd`;
      const res = await fetch(url, { headers: { Accept: 'application/json' } });
      if (!res.ok) return [];
      const json = await res.json();
      const candles = json?.data?.attributes?.ohlcv_list;
      if (!candles) return [];
      return candles.map(c => ({ date: new Date(c[0] * 1000), open: parseFloat(c[1]), high: parseFloat(c[2]), low: parseFloat(c[3]), close: parseFloat(c[4]), price: parseFloat(c[4]) })).filter(d => d.price > 0).reverse();
    } catch (e) { return []; }
  };
  try {
    const [current, legacy] = await Promise.all([
      fetchPool(CFG.gtPool),
      CFG.gtPoolLegacy ? fetchPool(CFG.gtPoolLegacy) : [],
    ]);
    if (current.length === 0 && legacy.length === 0) return null;
    const merged = [...legacy];
    const existingDates = new Set(merged.map(d => d.date.toDateString()));
    for (const c of current) { if (!existingDates.has(c.date.toDateString())) merged.push(c); }
    merged.sort((a, b) => a.date - b.date);
    return merged.length > 0 ? merged : null;
  } catch (e) { console.warn('GeckoTerminal OHLCV failed:', e.message); return null; }
}

async function fetchSpot() {
  if (!CFG.mint) return false;
  try {
    const res = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${CFG.mint}`);
    const data = await res.json();
    const pair = data.pairs?.find(p => p.quoteToken?.symbol === 'USDC');
    if (pair) {
      CFG.spot = parseFloat(pair.priceUsd);
      CFG.volume24h = parseFloat(pair.volume?.h24 || 0);
      return true;
    }
  } catch (e) { console.warn('DexScreener failed:', e.message); }
  return false;
}

async function fetchTreasury() {
  if (!CFG.daoWallet) return false;
  try {
    const getBalance = async (owner) => {
      if (!owner) return 0;
      const res = await fetch(CFG.rpcUrl, {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ jsonrpc:'2.0', id:1, method:'getTokenAccountsByOwner',
          params: [owner, { mint: CFG.usdcMint }, { encoding: 'jsonParsed' }] }),
      });
      const json = await res.json();
      let total = 0;
      for (const acct of (json.result?.value || [])) total += acct.account?.data?.parsed?.info?.tokenAmount?.uiAmount || 0;
      return total;
    };
    const [dao, amm, amm2] = await Promise.all([getBalance(CFG.daoWallet), getBalance(CFG.ammWallet), getBalance(CFG.ammWallet2)]);
    const total = dao + amm + amm2;
    console.log(`Treasury fetch ${CFG.ticker}: DAO(${CFG.daoWallet?.slice(0,8)})=$${dao.toLocaleString()}, AMM1(${CFG.ammWallet?.slice(0,8)})=$${amm.toLocaleString()}, AMM2(${CFG.ammWallet2?.slice(0,8) || 'none'})=$${amm2.toLocaleString()}, TOTAL=$${total.toLocaleString()}`);
    if (total > 0) { CFG.treasuryUSDC = total; CFG.daoUSDC = dao; CFG.ammUSDCLive = amm + amm2; return true; }
  } catch (e) { console.warn('RPC failed:', e.message); }
  return false;
}

async function fetchEffectiveSupply() {
  if (!CFG.mint) return false;
  try {
    const getTokenBalance = async (owner) => {
      if (!owner) return 0;
      const res = await fetch(CFG.rpcUrl, {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ jsonrpc:'2.0', id:1, method:'getTokenAccountsByOwner',
          params: [owner, { mint: CFG.mint }, { encoding: 'jsonParsed' }] }),
      });
      const json = await res.json();
      let total = 0;
      for (const acct of (json.result?.value || [])) total += acct.account?.data?.parsed?.info?.tokenAmount?.uiAmount || 0;
      return total;
    };

    const supplyRes = await fetch(CFG.rpcUrl, {
      method: 'POST', headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ jsonrpc:'2.0', id:1, method:'getTokenSupply', params: [CFG.mint] }),
    });
    const supplyJson = await supplyRes.json();
    const onChainSupply = parseFloat(supplyJson?.result?.value?.uiAmount || 0);

    // Fetch token balances in ALL excluded wallets: AMMs, DAO treasury, buyback
    const [amm1Tokens, amm2Tokens, daoTokens, buybackTokens] = await Promise.all([
      getTokenBalance(CFG.ammWallet),
      getTokenBalance(CFG.ammWallet2),
      getTokenBalance(CFG.daoWallet),
      getTokenBalance(CFG.buybackWallet),
    ]);
    const excludedTokens = amm1Tokens + amm2Tokens + daoTokens + buybackTokens;
    CFG.ammTokenBalance = amm1Tokens + amm2Tokens;
    CFG.daoTokenBalance = daoTokens;
    CFG.buybackTokenBalance = buybackTokens;

    // Effective supply = on-chain total minus all non-circulating tokens
    const totalSupply = onChainSupply > 0 ? onChainSupply : CFG.supply;
    CFG.effectiveSupply = Math.max(1, totalSupply - excludedTokens);
    console.log(`${CFG.ticker} supply: onChain=${totalSupply.toLocaleString()}, AMM=${(amm1Tokens+amm2Tokens).toLocaleString()}, DAO=${daoTokens.toLocaleString()}, Buyback=${buybackTokens.toLocaleString()}, excluded=${excludedTokens.toLocaleString()}, effective=${CFG.effectiveSupply.toLocaleString()}`);
    return true;
  } catch (e) { console.warn('Effective supply fetch failed:', e.message); return false; }
}

// ═══════════════════════════════════════════════════════════════════════
// FALLBACK SIMULATED DATA
// ═══════════════════════════════════════════════════════════════════════
function genFallback() {
  const fb = CFG.fallback;
  const data = [];
  const tge = new Date(CFG.tge);
  const now = new Date();
  const days = Math.floor((now - tge) / 86400000);
  let price = fb.listPrice;
  let seed = 42;
  const rng = () => { seed = (seed * 16807) % 2147483647; return seed / 2147483647; };
  for (let d = 0; d <= days; d++) {
    const noise = (rng() - 0.48) * 0.025 * price;
    if (d < fb.peakDay) {
      price += (fb.listPrice + (fb.peakPrice-fb.listPrice)*(1-Math.pow(1-d/fb.peakDay,1.8)) - price) * 0.12 + noise;
    } else if (d < fb.bounceDay) {
      price += (fb.peakPrice + (fb.bouncePrice-fb.peakPrice)*Math.pow((d-fb.peakDay)/(fb.bounceDay-fb.peakDay),0.6) - price) * 0.06 + noise*0.8;
    } else {
      price += (fb.bouncePrice + (CFG.spot-fb.bouncePrice)*Math.pow((d-fb.bounceDay)/Math.max(days-fb.bounceDay,1),0.7) - price) * 0.04 + noise*0.6;
    }
    price = Math.max(fb.floor, price);
    if (d === days) price = CFG.spot;
    data.push({ date: new Date(tge.getTime() + d*86400000), price: parseFloat(price.toFixed(6)) });
  }
  return data;
}

// ═══════════════════════════════════════════════════════════════════════
// CHART — Pure Canvas
// ═══════════════════════════════════════════════════════════════════════
function drawChart(history, strike, vol, viewMode) {
  viewMode = viewMode || 'full';
  const container = document.getElementById('chart-container');
  container.innerHTML = '';

  const dpr = window.devicePixelRatio || 1;
  const cw = Math.min(920, container.clientWidth);
  const ch = 400;
  const mg = { top: 24, right: 58, bottom: 52, left: 62 };
  const w = cw - mg.left - mg.right;
  const h = ch - mg.top - mg.bottom;

  const canvas = document.createElement('canvas');
  canvas.width = cw * dpr; canvas.height = ch * dpr;
  canvas.style.width = cw + 'px'; canvas.style.height = ch + 'px';
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);

  const draws = CFG.draws.map(d => ({ ...d, date: new Date(d.date) })).sort((a,b) => a.date - b.date);
  const now = Date.now();
  const supplyDiv = CFG.effectiveSupply || CFG.supply;
  const startingTreasury = CFG.raise;
  
  function treasuryAtDate(t) {
    let treasury = startingTreasury;
    for (const draw of draws) {
      if (draw.date.getTime() <= t) treasury -= draw.amount;
    }
    return Math.max(0, treasury);
  }

  const enriched = history.map((d, idx) => {
    const t = d.date.getTime();
    const treasuryAtT = treasuryAtDate(t);
    const K = treasuryAtT / supplyDiv;
    return { ...d, t, strikeAtDate: K, intrinsic: Math.max(0, K - d.price) };
  });

  const tMin = enriched[0].t, tMax = enriched[enriched.length-1].t;
  const allP = enriched.flatMap(d => [d.high || d.price, d.low || d.price, d.strikeAtDate]).concat([CFG.icoPrice]);
  let pMin, pMax;
  if (viewMode === 'strike') {
    const strikes = enriched.map(d => d.strikeAtDate);
    const kMin = Math.min(...strikes);
    const kMax = Math.max(...strikes);
    const kMid = (kMin + kMax) / 2;
    const kRange = Math.max(kMax - kMin, kMid * 0.15);
    const spotNearStrike = Math.abs(CFG.spot - kMid) < kRange * 3;
    pMin = Math.min(kMin - kRange * 2, spotNearStrike ? CFG.spot * 0.9 : kMin - kRange * 2);
    pMax = Math.max(kMax + kRange * 2, spotNearStrike ? CFG.spot * 1.1 : kMax + kRange * 2);
  } else {
    pMin = Math.min(...allP) * 0.85;
    pMax = Math.max(...allP) * 1.06;
  }

  const sx = t => mg.left + (t - tMin) / (tMax - tMin) * w;
  const sy = p => mg.top + (1 - (p - pMin) / (pMax - pMin)) * h;

  // Grid
  ctx.strokeStyle = '#222228'; ctx.lineWidth = 0.5;
  for (let i = 0; i <= 6; i++) { const v = pMin + (pMax-pMin)*i/6, y = sy(v); ctx.beginPath(); ctx.moveTo(mg.left, y); ctx.lineTo(mg.left+w, y); ctx.stroke(); }

  // Y labels
  const yd = pMax >= 1 ? 2 : pMax >= 0.01 ? 4 : 6;
  ctx.fillStyle = '#555560'; ctx.font = '10px Inter, sans-serif'; ctx.textAlign = 'right';
  for (let i = 0; i <= 6; i++) { const v = pMin + (pMax-pMin)*i/6; ctx.fillText('$'+v.toFixed(yd), mg.left-8, sy(v)+3); }

  // X labels
  const mo = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  ctx.textAlign = 'center';
  for (let i = 0; i <= 8; i++) { const t = tMin + (tMax-tMin)*i/8; const d = new Date(t); ctx.fillText(`${mo[d.getMonth()]}-${String(d.getDate()).padStart(2,'0')}`, sx(t), mg.top+h+20); }

  // NAV line — red staircase
  const startNAVperToken = startingTreasury / supplyDiv;
  const currentNAVperToken = CFG.treasuryUSDC / supplyDiv;

  const allDraws = draws.sort((a,b) => a.date - b.date);
  const segments = [];
  let segStart = mg.left;
  let navLevel = startNAVperToken;
  
  for (const draw of allDraws) {
    const drawT = draw.date.getTime();
    if (drawT > tMax) break;
    const drawX = Math.max(mg.left, sx(drawT));
    if (drawX > segStart) {
      segments.push({ x1: segStart, x2: drawX, nav: navLevel, draw: drawT >= tMin ? draw : null });
    }
    navLevel -= draw.amount / supplyDiv;
    segStart = drawX;
  }
  const finalNAV = navLevel;
  segments.push({ x1: segStart, x2: mg.left + w, nav: finalNAV, draw: null });

  if (allDraws.length === 0) {
    segments.length = 0;
    segments.push({ x1: mg.left, x2: mg.left + w, nav: currentNAVperToken, draw: null });
  }

  // Draw staircase
  ctx.strokeStyle = '#e84057'; ctx.lineWidth = 1.5; ctx.setLineDash([]);
  ctx.beginPath();
  ctx.moveTo(segments[0].x1, sy(segments[0].nav));
  for (let i = 0; i < segments.length; i++) {
    const y = sy(segments[i].nav);
    ctx.lineTo(segments[i].x2, y);
    if (i < segments.length - 1) {
      const nextY = sy(segments[i + 1].nav);
      ctx.lineTo(segments[i].x2, nextY);
    }
  }
  ctx.stroke();

  // Tick marks at drops
  const tickExtend = 6;
  ctx.strokeStyle = '#e84057'; ctx.lineWidth = 2;
  for (let i = 0; i < segments.length - 1; i++) {
    const x = segments[i].x2;
    const yTop = sy(segments[i].nav) - tickExtend;
    const yBot = sy(segments[i + 1].nav) + tickExtend;
    ctx.beginPath(); ctx.moveTo(x, yTop); ctx.lineTo(x, yBot); ctx.stroke();
  }

  // Labels at drops
  ctx.fillStyle = '#e84057'; ctx.font = '8px Inter, sans-serif'; ctx.textAlign = 'center';
  for (const seg of segments) {
    if (seg.draw) {
      const x = seg.x2;
      const y = sy(seg.nav);
      ctx.fillText('-' + fmtBurn(seg.draw.amount), x, y - 8);
    }
  }

  // NAV label on right edge
  ctx.fillStyle = '#e84057'; ctx.font = '10px Inter, sans-serif'; ctx.textAlign = 'left';
  ctx.fillText('NAV ' + fmt$(currentNAVperToken), mg.left + w + 4, sy(segments[segments.length - 1].nav) + 4);

  // Premium/Discount shading (using close prices vs NAV)
  function navAtTime(t) {
    for (let i = segments.length - 1; i >= 0; i--) {
      if (sx(t) >= segments[i].x1 - 0.5) return segments[i].nav;
    }
    return segments[0].nav;
  }

  for (let i = 0; i < enriched.length - 1; i++) {
    const p0 = enriched[i], p1 = enriched[i + 1];
    const nav0 = navAtTime(p0.t), nav1 = navAtTime(p1.t);
    const x0 = sx(p0.t), x1 = sx(p1.t);
    const yPrice0 = sy(p0.price), yPrice1 = sy(p1.price);
    const yNav0 = sy(nav0), yNav1 = sy(nav1);
    const midPrice = (p0.price + p1.price) / 2;
    const midNav = (nav0 + nav1) / 2;
    const isAbove = midPrice >= midNav;

    ctx.fillStyle = isAbove ? 'rgba(0,229,160,0.06)' : 'rgba(232,64,87,0.10)';
    ctx.beginPath();
    ctx.moveTo(x0, yPrice0);
    ctx.lineTo(x1, yPrice1);
    ctx.lineTo(x1, yNav1);
    ctx.lineTo(x0, yNav0);
    ctx.closePath();
    ctx.fill();
  }

  // Candlesticks
  const totalCandles = enriched.length;
  const candleSpacing = w / Math.max(totalCandles, 1);
  const candleWidth = Math.max(1, Math.min(candleSpacing * 0.7, 12));
  const wickWidth = Math.max(1, candleWidth < 4 ? 1 : 1.5);

  for (let i = 0; i < enriched.length; i++) {
    const d = enriched[i];
    const x = sx(d.t);
    const hasOHLC = d.open !== undefined && d.high !== undefined && d.low !== undefined;
    
    if (hasOHLC) {
      const bullish = d.close >= d.open;
      const bodyColor = bullish ? '#00e5a0' : '#e84057';
      const wickColor = bullish ? 'rgba(0,229,160,0.6)' : 'rgba(232,64,87,0.6)';
      
      const yOpen = sy(d.open);
      const yClose = sy(d.close);
      const yHigh = sy(d.high);
      const yLow = sy(d.low);
      const bodyTop = Math.min(yOpen, yClose);
      const bodyBot = Math.max(yOpen, yClose);
      const bodyHeight = Math.max(1, bodyBot - bodyTop);

      // Wick (high to low)
      ctx.strokeStyle = wickColor;
      ctx.lineWidth = wickWidth;
      ctx.beginPath();
      ctx.moveTo(x, yHigh);
      ctx.lineTo(x, yLow);
      ctx.stroke();

      // Body
      ctx.fillStyle = bodyColor;
      if (candleWidth >= 3) {
        // Filled rectangle body
        ctx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
        // Subtle border for definition
        ctx.strokeStyle = bodyColor;
        ctx.lineWidth = 0.5;
        ctx.strokeRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
      } else {
        // Too narrow for rect — draw as a thick line
        ctx.strokeStyle = bodyColor;
        ctx.lineWidth = Math.max(1.5, candleWidth);
        ctx.beginPath();
        ctx.moveTo(x, bodyTop);
        ctx.lineTo(x, bodyBot);
        ctx.stroke();
      }
    } else {
      // Fallback: no OHLC data, draw as a dot
      ctx.fillStyle = '#f0f0f5';
      ctx.beginPath();
      ctx.arc(x, sy(d.price), 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Current price dot (last candle highlight)
  const last = enriched[enriched.length-1];
  const lastBullish = last.close >= (last.open || last.price);
  ctx.fillStyle = lastBullish ? '#00e5a0' : '#e84057';
  ctx.beginPath(); ctx.arc(sx(last.t), sy(last.price), 4, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = '#0c0c10'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(sx(last.t), sy(last.price), 4, 0, Math.PI*2); ctx.stroke();

  // Tooltip
  const lastStrike = currentNAVperToken;
  const tt = document.createElement('div');
  tt.className = 'chart-tooltip';
  container.appendChild(tt);
  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    if (mx < mg.left || mx > mg.left+w) { tt.style.display='none'; return; }
    const t = tMin + (mx - mg.left)/w * (tMax - tMin);
    let ci = 0, md = Infinity;
    for (let i = 0; i < enriched.length; i++) { const dist = Math.abs(enriched[i].t - t); if (dist < md) { md = dist; ci = i; } }
    const d = enriched[ci];
    tt.style.display = 'block';
    tt.style.left = Math.min(sx(d.t)+16, cw-160)+'px';
    tt.style.top = Math.max(sy(d.price)-80, 0)+'px';
    tt.innerHTML = `<div class="tt-price">${fmt$(d.price)}</div>
      ${d.open !== undefined ? `<div class="tt-line" style="color:var(--dim)">O ${fmt$(d.open)} · H ${fmt$(d.high)} · L ${fmt$(d.low)}</div>` : ''}
      <div class="tt-line" style="color:#e84057">NAV: ${fmt$(lastStrike)}</div>
      <div class="tt-line" style="color:${d.price < lastStrike ? '#e84057' : '#00e5a0'}">${d.price < lastStrike ? ((lastStrike - d.price) / lastStrike * 100).toFixed(1) + '% below NAV' : ((d.price - lastStrike) / lastStrike * 100).toFixed(0) + '% above NAV'}</div>
      <div class="tt-date">${d.date.toLocaleDateString('en-US',{month:'short',day:'numeric',year:'numeric'})}</div>`;
  });
  canvas.addEventListener('mouseleave', () => { tt.style.display='none'; });

  let rt;
  window._chartViewMode = viewMode;
  window._chartArgs = [history, strike, vol];
  window.addEventListener('resize', () => { clearTimeout(rt); rt = setTimeout(() => drawChart(history, strike, vol, window._chartViewMode), 400); });
}

// Chart view toggle
document.querySelector('.chart-controls')?.addEventListener('click', e => {
  const btn = e.target.closest('.chart-btn');
  if (!btn || !window._chartArgs) return;
  document.querySelectorAll('.chart-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  window._chartViewMode = btn.dataset.view;
  drawChart(...window._chartArgs, btn.dataset.view);
});

// ═══════════════════════════════════════════════════════════════════════
// RENDER UI
// ═══════════════════════════════════════════════════════════════════════
function renderUI(isLive) {
  const supplyForNAV = CFG.effectiveSupply || CFG.supply;
  const strike = CFG.treasuryUSDC / supplyForNAV;
  const intrinsic = Math.max(0, strike - CFG.spot);
  const itm = CFG.spot < strike;
  const intrPct = CFG.spot > 0 ? (intrinsic / CFG.spot * 100) : 0;
  const monthsLeft = CFG.monthlyBurn > 0 ? Math.floor(CFG.treasuryUSDC / CFG.monthlyBurn) : '∞';
  const discPct = strike > 0 ? ((CFG.spot - strike) / strike * 100) : 0;
  const isDiscount = discPct < 0;

  document.getElementById('sub-line').innerHTML = `${CFG.pair} · FUTARCHY CPMM · <span class="data-tag">${isLive ? 'REAL DATA' : 'SNAPSHOT DATA'}</span>`;
  document.getElementById('title').textContent = `${CFG.ticker} — ${itm ? 'Trading Below Treasury Floor' : 'Trading Above Treasury Floor'}`;
  document.getElementById('desc').innerHTML =
    `${CFG.ticker} is trading at <b>${fmt$(CFG.spot)}</b>, ${itm?'below':'above'} the <b>${fmt$(strike)}</b> treasury floor (treasury/token). ` +
    `Token holders can vote for dissolution and claim their pro-rata share of the treasury. ` +
    (itm ? `Currently trading at a <span class="hl-orange">${Math.abs(discPct).toFixed(1)}%</span> discount — each token is backed by more than its market price. ` : '');

  document.getElementById('cards').innerHTML = `
    <div class="card"><div class="card-label">Treasury</div><div class="card-value" style="color:var(--green)">${fmtM(CFG.treasuryUSDC)}</div><div class="card-sub">${fmtM(CFG.monthlyBurn)}/mo burn</div></div>
    <div class="card"><div class="card-label">Spot Price</div><div class="card-value" style="color:var(--white)">${fmt$(CFG.spot)}</div><div class="card-sub">current market price</div></div>
    <div class="card"><div class="card-label">Backing / Token</div><div class="card-value" style="color:var(--white)">${fmt$(strike)}</div><div class="card-sub">treasury ÷ holder supply</div></div>
    <div class="card"><div class="card-label">${isDiscount ? 'Discount' : 'Premium'}</div><div class="card-value" style="color:${isDiscount ? 'var(--red)' : 'var(--green)'}">${isDiscount ? Math.abs(discPct).toFixed(1) + '%' : '+' + discPct.toFixed(0) + '%'}</div><div class="card-sub">${isDiscount ? 'below treasury floor' : 'above treasury floor'}</div></div>
    <div class="card"><div class="card-label">Runway</div><div class="card-value" style="color:var(--orange)">${monthsLeft} mo</div><div class="card-sub">at current burn rate</div></div>
  `;

  document.getElementById('params').innerHTML = `
    <span>Raise <b>${fmtM(CFG.raise)}</b></span>
    <span>Supply <b>${(supplyForNAV/1e6).toFixed(1)}M</b></span>
    <span>S₀ <b>${fmt$(CFG.icoPrice)}</b></span>
    <span>NAV <span class="hl">${fmt$(strike)}</span></span>
    <span>Spot now <span class="spot">${fmt$(CFG.spot)}</span></span>
    <span>ATH <b>${fmt$(CFG.ath)}</b></span>
    <span>Burn <b>${fmtBurn(CFG.monthlyBurn)}/mo</b></span>
  `;

  document.getElementById('chart-label').innerHTML = `${CFG.ticker} Price History — <span style="color:#e84057">red line = NAV (treasury/token)</span>`;
  document.getElementById('leg-spot-label').textContent = CFG.ticker + ' bullish';
  document.getElementById('leg-strike').textContent = fmt$(strike);

  return strike;
}

// ═══════════════════════════════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════════════════════════════
(async function main() {
  if (!CFG.live) return;
  CFG.effectiveSupply = CFG.supply;
  let strike = renderUI(false);
  try {
    const [ohlcv, spotOk, treasuryOk] = await Promise.all([fetchOHLCV(), fetchSpot(), fetchTreasury()]);
    await fetchEffectiveSupply();
    const isLive = !!(ohlcv || spotOk || treasuryOk);
    strike = renderUI(isLive);

    let chartData;
    if (ohlcv && ohlcv.length > 0) {
      const firstPrice = ohlcv[0].price;
      const firstDate = ohlcv[0].date;
      const tge = new Date(CFG.tge);
      const daysBetween = Math.max(1, Math.floor((firstDate - tge) / 86400000));
      
      if (daysBetween > 3) {
        const fb = CFG.fallback;
        const synth = [];
        let price = fb.listPrice;
        let seed = 42;
        const rng = () => { seed = (seed * 16807) % 2147483647; return seed / 2147483647; };
        for (let i = 0; i < daysBetween; i++) {
          const d = new Date(tge.getTime() + i * 86400000);
          const noise = (rng() - 0.48) * 0.02 * price;
          if (i < fb.peakDay && fb.peakDay <= daysBetween) {
            price += (fb.listPrice + (fb.peakPrice - fb.listPrice) * (1 - Math.pow(1 - i / fb.peakDay, 1.8)) - price) * 0.12 + noise;
          } else if (fb.peakDay > daysBetween) {
            const pct = i / daysBetween;
            price = fb.listPrice + (firstPrice - fb.listPrice) * Math.pow(pct, 0.6) + noise;
          } else {
            const postPeak = (i - fb.peakDay) / (daysBetween - fb.peakDay);
            price = fb.peakPrice + (firstPrice - fb.peakPrice) * Math.pow(postPeak, 0.5) + noise;
          }
          price = Math.max(fb.floor || 0.01, price);
          synth.push({ date: d, price: parseFloat(price.toFixed(6)) });
        }
        chartData = [...synth, ...ohlcv];
        console.log(`Prepended ${synth.length} synthetic days (${fb.listPrice} → ${firstPrice}) before API data`);
      } else {
        chartData = ohlcv;
      }
    } else {
      chartData = genFallback();
    }
    if (ohlcv && spotOk) {
      const last = chartData[chartData.length - 1];
      if (Math.abs(last.price - CFG.spot) > CFG.spot * 0.01) chartData.push({ date: new Date(), price: CFG.spot });
    }

    document.getElementById('chart-loading')?.remove();
    drawChart(chartData, strike, CFG.realizedVol);

    if (!ohlcv) {
      const notice = document.createElement('div');
      notice.style.cssText = 'text-align:center;font-size:9px;color:#ff8c42;font-family:Inter,sans-serif;padding:6px 0';
      notice.textContent = '⚠ GeckoTerminal API unreachable — showing simulated data.';
      document.getElementById('chart-container').appendChild(notice);
    }

    console.log(`NAVgator ${CFG.ticker} | Live: ${isLive} | OHLCV: ${ohlcv?ohlcv.length+' candles':'fallback'} | Spot: $${CFG.spot} | Treasury: $${CFG.treasuryUSDC.toLocaleString()} | EffSupply: ${(CFG.effectiveSupply||CFG.supply).toLocaleString()} | NAV: $${strike.toFixed(6)}`);
  } catch (err) {
    console.error('NAVgator init error:', err);
    document.getElementById('chart-loading')?.remove();
    const chartData = genFallback();
    drawChart(chartData, strike, CFG.realizedVol);
    const notice = document.createElement('div');
    notice.style.cssText = 'text-align:center;font-size:9px;color:#e84057;font-family:Inter,sans-serif;padding:6px 0';
    notice.textContent = '⚠ Error loading data — showing simulated chart. Check console for details.';
    document.getElementById('chart-container').appendChild(notice);
  }
})();
} // end if (_hasToken)
</script>
</body>
</html>
