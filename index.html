<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NAVgator · Dashboard</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=DM+Serif+Display&family=JetBrains+Mono:wght@300;400;500&display=swap');
  :root {
    --bg: #0c0c10; --bg2: #141418; --bg3: #1a1a20;
    --border: #222228; --border2: #2a2a32;
    --dim: #555560; --muted: #77778a; --text: #a0a0b0; --bright: #d0d0dd; --white: #eeeef2;
    --green: #00e5a0; --green-dim: rgba(0,229,160,0.10);
    --red: #e84057; --orange: #f59e42; --blue: #5b8def; --purple: #9f8cfc;
    --card-bg: #16161c; --card-border: #24242c;
  }
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: 'Inter', -apple-system, system-ui, sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; -webkit-font-smoothing: antialiased; }
  ::selection { background: rgba(0,229,160,0.25); }

  .wrap { max-width: 1200px; margin: 0 auto; padding: 40px 32px 64px; }

  /* Nav bar */
  .nav { display: flex; align-items: center; gap: 16px; margin-bottom: 32px; flex-wrap: wrap; }
  .nav-brand { font-family: 'DM Serif Display', serif; font-size: 18px; font-weight: 400; color: var(--white); text-decoration: none; letter-spacing: -0.3px; display: flex; align-items: center; gap: 8px; }
  .nav-brand span { color: var(--green); }
  .nav-brand-icon { display: inline-flex; align-items: center; justify-content: center; width: 26px; height: 26px; border-radius: 6px; background: linear-gradient(135deg, var(--green), #00b880); font-family: 'DM Serif Display', serif; font-size: 13px; font-weight: 400; color: #0c0c10; flex-shrink: 0; }
  .nav-sep { color: var(--dim); }
  .nav-tokens { display: flex; gap: 6px; flex-wrap: wrap; }
  .nav-tok { font-family: 'Inter', sans-serif; font-size: 10px; font-weight: 500; letter-spacing: 0.8px; text-transform: uppercase; padding: 5px 12px; border-radius: 6px; border: 1px solid var(--border2); color: var(--muted); text-decoration: none; transition: all 0.2s; }
  .nav-tok:hover { border-color: var(--green); color: var(--white); background: rgba(255,255,255,0.03); }
  .nav-tok.active { border-color: var(--green); color: var(--green); background: var(--green-dim); }

  /* Subheader line */
  .sub { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 500; color: var(--muted); letter-spacing: 1.5px; text-transform: uppercase; margin-bottom: 10px; }
  .sub .data-tag { color: var(--green); }

  /* Title */
  h1 { font-family: 'DM Serif Display', serif; font-size: 42px; font-weight: 400; color: var(--white); margin-bottom: 12px; line-height: 1.1; letter-spacing: -0.5px; }

  /* Description */
  .desc { font-family: 'Inter', sans-serif; font-size: 14px; font-weight: 400; color: var(--muted); line-height: 1.7; max-width: 740px; margin-bottom: 32px; }
  .desc b { color: var(--white); font-weight: 600; }
  .desc .hl-orange { color: var(--orange); font-weight: 600; }
  .desc .hl-green { color: var(--green); font-weight: 600; }

  /* 5 metric cards row */
  .cards { display: grid; grid-template-columns: repeat(5, 1fr); gap: 14px; margin-bottom: 24px; }
  @media (max-width: 800px) { .cards { grid-template-columns: repeat(3, 1fr); } }
  @media (max-width: 500px) { .cards { grid-template-columns: repeat(2, 1fr); } h1 { font-size: 30px; } }
  .card { border: 1px solid var(--card-border); border-radius: 12px; padding: 20px 22px; background: var(--card-bg); }
  .card-label { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 500; color: var(--muted); margin-bottom: 10px; }
  .card-value { font-family: 'DM Serif Display', serif; font-size: 32px; font-weight: 400; line-height: 1.1; color: var(--white); }
  .card-sub { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 400; color: var(--dim); margin-top: 6px; }

  /* Params bar */
  .params { display: flex; flex-wrap: wrap; gap: 6px 24px; font-family: 'Inter', sans-serif; font-size: 12px; font-weight: 400; color: var(--dim); padding: 14px 0; border-top: 1px solid var(--border); border-bottom: 1px solid var(--border); margin-bottom: 28px; }
  .params b { color: var(--text); font-weight: 600; }
  .params .hl { color: var(--green); font-weight: 600; }
  .params .spot { color: var(--red); font-weight: 600; }

  /* Chart section */
  .chart-section { background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 14px; padding: 24px 20px 16px; margin-bottom: 28px; position: relative; }
  .chart-title { font-family: 'Inter', sans-serif; font-size: 12px; font-weight: 500; color: var(--muted); margin-bottom: 16px; }
  .chart-title span { color: var(--red); }
  .chart-controls { display: flex; gap: 6px; position: absolute; top: 20px; right: 20px; z-index: 2; align-items: center; }
  .chart-btn-group { display: flex; gap: 4px; }
  .chart-btn-group + .chart-btn-group { margin-left: 8px; padding-left: 10px; border-left: 1px solid var(--border2); }
  .chart-btn { font-family: 'Inter', sans-serif; font-size: 10px; font-weight: 500; padding: 5px 12px; border-radius: 6px; border: 1px solid var(--border2); color: var(--muted); background: transparent; cursor: pointer; transition: all 0.2s; }
  .chart-btn:hover { border-color: var(--green); color: var(--white); }
  .chart-btn.active { border-color: var(--green); color: var(--green); background: var(--green-dim); }
  #chart-container { width: 100%; min-height: 420px; position: relative; }
  .chart-loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); font-size: 12px; color: var(--dim); }

  /* Tooltip */
  .chart-tooltip { position: absolute; display: none; pointer-events: none; background: rgba(12,12,16,0.96); border: 1px solid var(--card-border); border-radius: 10px; padding: 12px 16px; z-index: 10; backdrop-filter: blur(8px); }
  .tt-price { font-family: 'DM Serif Display', serif; font-size: 22px; font-weight: 400; color: var(--white); margin-bottom: 4px; }
  .tt-line { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 400; margin-top: 3px; }
  .tt-date { font-family: 'Inter', sans-serif; font-size: 10px; color: var(--dim); margin-top: 6px; }

  /* Legend */
  .legend { display: flex; flex-wrap: wrap; gap: 18px; padding: 12px 4px 0; font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 400; color: var(--muted); }
  .legend-item { display: flex; align-items: center; gap: 6px; }
  .legend-line { display: inline-block; width: 18px; height: 2.5px; border-radius: 2px; }
  .legend-fill { display: inline-block; width: 12px; height: 12px; border-radius: 2px; }
  .legend-dash { display: inline-block; width: 16px; height: 0; border-top: 2px dashed; }

  /* Address section */
  .nav-stats-bar { display: flex; gap: 0; margin-top: 12px; border-radius: 10px; overflow: hidden; font-family: 'Inter', sans-serif; font-size: 12px; }
  .nav-stats-bar .ns-item { flex: 1; padding: 12px 16px; display: flex; flex-direction: column; gap: 4px; }
  .nav-stats-bar .ns-label { font-size: 10px; font-weight: 600; letter-spacing: 1px; text-transform: uppercase; opacity: 0.7; }
  .nav-stats-bar .ns-value { font-size: 16px; font-weight: 600; }
  .nav-stats-bar .ns-sub { font-size: 10px; opacity: 0.6; }
  .nav-stats-bar .ns-above { background: rgba(0,229,160,0.08); color: #00e5a0; }
  .nav-stats-bar .ns-below { background: rgba(232,64,87,0.08); color: #e84057; }
  .nav-stats-bar .ns-neutral { background: rgba(255,255,255,0.04); color: var(--muted); }
  .nav-stats-bar .ns-progress { height: 4px; border-radius: 2px; margin-top: 6px; background: rgba(255,255,255,0.06); overflow: hidden; }
  .nav-stats-bar .ns-progress-fill { height: 100%; border-radius: 2px; }

  .addr-section { background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 14px; padding: 14px 18px; margin-bottom: 28px; }
  .addr-title { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 600; color: var(--muted); letter-spacing: 1.5px; text-transform: uppercase; margin-bottom: 12px; }
  .addr-row { display: flex; align-items: center; padding: 5px 0; border-bottom: 1px solid var(--border); font-family: 'Inter', sans-serif; font-size: 12px; gap: 12px; flex-wrap: wrap; }
  .addr-row:last-child { border-bottom: none; }
  .addr-label { color: var(--muted); font-weight: 500; min-width: 100px; font-size: 11px; }
  .addr-val { display: flex; align-items: center; gap: 6px; }
  .addr-val a { color: var(--green); text-decoration: none; font-family: 'JetBrains Mono', monospace; font-size: 11px; }
  .addr-val a:hover { text-decoration: underline; }
  .addr-copy { background: none; border: 1px solid var(--border2); border-radius: 4px; color: var(--dim); font-size: 9px; padding: 2px 5px; cursor: pointer; transition: all 0.2s; font-family: 'Inter', sans-serif; }
  .addr-copy:hover { border-color: var(--green); color: var(--green); }
  .addr-copy.copied { border-color: var(--green); color: var(--green); }
  .addr-bals { margin-left: auto; display: flex; align-items: center; gap: 6px; font-family: 'JetBrains Mono', monospace; font-size: 11px; }
  .bal-usdc { color: var(--dim); }
  .bal-sep { color: var(--border2); }
  .bal-token { color: var(--dim); }
  .bal-loading { color: var(--dim); }
  .allowance-section { background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 14px; padding: 20px 22px; margin-bottom: 28px; }
  .allowance-card { background: var(--bg2); border: 1px solid var(--border); border-radius: 10px; padding: 12px 14px; }
  .allowance-card .ac-label { font-size: 9px; color: var(--dim); text-transform: uppercase; letter-spacing: 0.5px; font-family: Inter, sans-serif; margin-bottom: 4px; }
  .allowance-card .ac-value { font-size: 16px; font-weight: 600; color: var(--bright); font-family: 'JetBrains Mono', monospace; }
  .allowance-card .ac-sub { font-size: 9px; color: var(--muted); font-family: Inter, sans-serif; margin-top: 3px; }
  .util-bar { height: 6px; border-radius: 3px; background: var(--border); margin-top: 6px; overflow: hidden; }
  .util-fill { height: 100%; border-radius: 3px; transition: width 0.3s ease; }
  .allowance-month { display: inline-flex; align-items: center; gap: 6px; padding: 4px 0; margin-right: 16px; }
  .allowance-month .am-label { color: var(--muted); }
  .allowance-month .am-bar { width: 60px; height: 4px; border-radius: 2px; background: var(--border); display: inline-block; position: relative; }
  .allowance-month .am-fill { height: 100%; border-radius: 2px; position: absolute; left: 0; top: 0; }
  .allowance-month .am-pct { color: var(--text); min-width: 32px; text-align: right; }
  .addr-title { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 600; color: var(--muted); letter-spacing: 1.5px; text-transform: uppercase; margin-bottom: 14px; }
  .addr-row { display: flex; align-items: center; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid var(--border); font-family: 'Inter', sans-serif; font-size: 12px; }
  .addr-row:last-child { border-bottom: none; }
  .addr-label { color: var(--muted); font-weight: 500; min-width: 100px; }
  .addr-val { display: flex; align-items: center; gap: 8px; }
  .addr-val a { color: var(--green); text-decoration: none; font-family: 'JetBrains Mono', monospace; font-size: 11px; }
  .addr-val a:hover { text-decoration: underline; }
  .addr-copy { background: none; border: 1px solid var(--border2); border-radius: 4px; color: var(--dim); font-size: 10px; padding: 2px 6px; cursor: pointer; transition: all 0.2s; font-family: 'Inter', sans-serif; }
  .addr-copy:hover { border-color: var(--green); color: var(--green); }
  .addr-copy.copied { border-color: var(--green); color: var(--green); }

  .footer { font-family: 'Inter', sans-serif; font-size: 10px; font-weight: 400; color: var(--dim); text-align: center; padding: 24px 0; border-top: 1px solid var(--border); }
  .footer a { color: var(--muted); text-decoration: underline; }

  /* ── Landing page styles ── */
  .landing { display: none; }
  .landing.active { display: block; }
  .dashboard { display: none; }
  .dashboard.active { display: block; }
  .hero { padding: 28px 0 20px; text-align: center; }
  .logo-mark { display: inline-flex; align-items: center; justify-content: center; width: 48px; height: 48px; border-radius: 12px; background: linear-gradient(135deg, var(--green), #00b880); font-family: 'DM Serif Display', serif; font-size: 30px; font-weight: 400; color: #0c0c10; margin-bottom: 14px; box-shadow: 0 0 60px rgba(0,229,160,0.15), 0 0 120px rgba(0,229,160,0.05); animation: float 6s ease-in-out infinite; position: relative; }
  .logo-mark::after { content: ''; position: absolute; inset: -1px; border-radius: 13px; background: linear-gradient(135deg, rgba(0,229,160,0.4), rgba(0,184,128,0.1)); z-index: -1; filter: blur(1px); }
  @keyframes float { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-6px)} }
  .hero h1 { font-family: 'DM Serif Display', serif; font-size: 36px; font-weight: 400; color: var(--white); line-height: 1.1; margin-bottom: 6px; letter-spacing: -1px; }
  .hero h1 span { color: var(--green); }
  .tagline { font-family: 'Inter', sans-serif; font-size: 13px; font-weight: 400; color: var(--muted); line-height: 1.6; max-width: 480px; margin: 0 auto 0; }

  /* Table layout */
  .token-table-wrap { margin: 20px 0 40px; border: 1px solid var(--border); border-radius: 12px; overflow: hidden; background: var(--bg2); }
  .token-table { width: 100%; border-collapse: collapse; font-family: 'Inter', sans-serif; }
  .token-table thead th { font-size: 10px; font-weight: 600; color: var(--dim); text-transform: uppercase; letter-spacing: 0.5px; padding: 12px 18px; text-align: right; border-bottom: 1px solid var(--border); cursor: pointer; white-space: nowrap; user-select: none; }
  .token-table thead th:nth-child(1) { width: 36px; text-align: center; }
  .token-table thead th:nth-child(2) { text-align: left; }
  .token-table thead th:hover { color: var(--green); }
  .token-table thead th.sorted { color: var(--green); }
  .token-table tbody tr { border-bottom: 1px solid var(--border); cursor: pointer; transition: background 0.15s; }
  .token-table tbody tr:last-child { border-bottom: none; }
  .token-table tbody tr:hover { background: rgba(255,255,255,0.02); }
  .token-table td { padding: 18px 18px; font-size: 14px; color: var(--text); text-align: right; white-space: nowrap; }
  .token-table td:nth-child(1) { text-align: center; color: var(--dim); font-size: 13px; font-weight: 500; width: 36px; }
  .token-table td:nth-child(2) { text-align: left; }
  .tt-name-cell { display: flex; align-items: center; gap: 14px; }
  .tt-icon { width: 36px; height: 36px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-family: 'DM Serif Display', serif; font-size: 15px; font-weight: 400; color: #0c0c10; flex-shrink: 0; overflow: hidden; }
  .tt-icon img { width: 100%; height: 100%; object-fit: cover; }
  .tt-name { font-weight: 600; color: var(--white); font-size: 15px; }
  .tt-ticker { color: var(--dim); font-size: 11px; margin-top: 1px; }
  .tt-price { font-weight: 600; color: var(--white); font-family: 'JetBrains Mono', monospace; font-size: 14px; }
  .tt-change { font-size: 11px; font-weight: 500; margin-top: 2px; }
  .tt-change.up { color: var(--green); }
  .tt-change.down { color: #e84057; }
  .tt-sparkline { width: 140px; height: 40px; }
  .tt-coming { font-size: 10px; font-weight: 600; color: var(--muted); letter-spacing: 1px; text-transform: uppercase; opacity: 0.6; }

  @media (max-width: 768px) {
    .token-table td:nth-child(6), .token-table th:nth-child(6),
    .token-table td:nth-child(7), .token-table th:nth-child(7) { display: none; }
    .tt-sparkline { width: 80px; }
  }
  @media (max-width: 500px) {
    .token-table td:nth-child(4), .token-table th:nth-child(4),
    .token-table td:nth-child(5), .token-table th:nth-child(5) { display: none; }
    .hero h1 { font-size: 32px; }
  }

  .how { padding: 36px 0 48px; border-top: 1px solid var(--border); }
  .how h2 { font-family: 'Inter', sans-serif; font-size: 11px; font-weight: 600; letter-spacing: 2px; text-transform: uppercase; color: var(--dim); margin-bottom: 24px; }
  .how-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; }
  @media (max-width: 600px) { .how-grid { grid-template-columns: 1fr; } }
</style>
</head>
<body>

<div class="wrap">

  <!-- ══ LANDING PAGE ══ -->
  <div class="landing" id="landing-view">
    <div class="hero">
      <div class="logo-mark" style="background:transparent;box-shadow:none"><svg width="48" height="30" viewBox="0 0 160 100"><ellipse cx="80" cy="50" rx="55" ry="30" fill="none" stroke="#00e5a0" stroke-width="5"/><ellipse cx="80" cy="50" rx="7" ry="26" fill="#00e5a0"/></svg></div>
      <h1>NAV<span>gator</span></h1>
      <p class="tagline">Real-time NAV analytics for MetaDAO ownership tokens. Treasury tracking, discount/premium metrics, and live on-chain data.</p>
      <a href="submit.html" style="display:inline-block;margin-top:12px;padding:8px 20px;background:transparent;border:1px solid var(--green);color:var(--green);border-radius:8px;font-size:12px;font-weight:600;text-decoration:none;font-family:Inter,sans-serif;transition:all 0.2s" onmouseover="this.style.background='var(--green)';this.style.color='#0c0c10'" onmouseout="this.style.background='transparent';this.style.color='var(--green)'">+ Submit a Token</a>
    </div>

    <div class="token-table-wrap">
      <table class="token-table" id="token-table">
        <thead>
          <tr>
            <th>#</th>
            <th style="text-align:left">Name</th>
            <th>Price</th>
            <th>NAV</th>
            <th>vs NAV</th>
            <th>Treasury</th>
            <th>MCap</th>
            <th>30D Trend</th>
          </tr>
        </thead>
        <tbody id="token-tbody"></tbody>
      </table>
    </div>

    <div class="how">
      <h2>How Treasury Backing Works</h2>
      <div class="how-grid">
        <div class="how-item"><div class="how-num" style="font-size:12px;font-weight:600;color:var(--green);margin-bottom:6px">01</div><div style="font-size:13px;color:var(--white);font-weight:600;margin-bottom:5px">Treasury-backed tokens</div><div style="font-size:12px;color:var(--muted);line-height:1.6">MetaDAO ICOs deposit all raised USDC into an on-chain treasury. The team draws a fixed monthly budget — every dollar is governed by futarchy.</div></div>
        <div class="how-item"><div class="how-num" style="font-size:12px;font-weight:600;color:var(--green);margin-bottom:6px">02</div><div style="font-size:13px;color:var(--white);font-weight:600;margin-bottom:5px">Backing = Treasury ÷ Supply</div><div style="font-size:12px;color:var(--muted);line-height:1.6">Each token has a claim on treasury USDC. When spot trades below backing, you're buying below the treasury floor — dissolution returns more than market price.</div></div>
        <div class="how-item"><div class="how-num" style="font-size:12px;font-weight:600;color:var(--green);margin-bottom:6px">03</div><div style="font-size:13px;color:var(--white);font-weight:600;margin-bottom:5px">Dissolution right</div><div style="font-size:12px;color:var(--muted);line-height:1.6">Any holder can propose dissolution via futarchy. If passed, treasury distributes pro-rata. This creates a soft price floor enforced by rational arbitrage.</div></div>
      </div>
    </div>
    <div class="footer">NAVgator · Treasury analytics for ownership tokens · <a href="https://metadao.fi" target="_blank">MetaDAO</a> · <a href="submit.html">Submit a Token</a> · Data via NAVgator API + Solana RPC · Not financial advice</div>
  </div>

  <!-- ══ DASHBOARD VIEW ══ -->
  <div class="dashboard" id="dashboard-view">

  <!-- Nav -->
  <nav class="nav" id="nav"></nav>

  <div class="sub" id="sub-line">LOADING…</div>
  <h1 id="title">Loading Dashboard…</h1>
  <div class="desc" id="desc">Fetching data…</div>

  <div class="cards" id="cards"></div>
  <div class="params" id="params"></div>

  <div class="chart-section">
    <div class="chart-title" id="chart-label"></div>
    <div class="chart-controls" id="chart-controls">
      <div class="chart-btn-group">
        <button class="chart-btn" data-tf="12H">12H</button>
        <button class="chart-btn active" data-tf="1D">1D</button>
        <button class="chart-btn" data-tf="1W">1W</button>
        <button class="chart-btn" data-tf="1M">1M</button>
      </div>
    </div>
    <div id="chart-container" style="position:relative;cursor:crosshair">
      <canvas id="chart-canvas"></canvas>
      <div class="chart-tooltip" id="chart-tooltip"></div>
      <div class="chart-loading" id="chart-loading">Loading chart…</div>
    </div>
    <div class="legend">
      <span class="legend-item"><span class="legend-line" style="background:#e8e6e3"></span> <span id="leg-spot-label">Price</span></span>
      <span class="legend-item"><span class="legend-line" style="background:rgba(255,255,255,0.6);background-image:repeating-linear-gradient(90deg,rgba(255,255,255,0.6) 0 6px,transparent 6px 10px);background-color:transparent"></span> NAV <span id="leg-strike">…</span></span>
      <span class="legend-item"><span class="legend-fill" style="background:rgba(0,229,160,0.2)"></span> Above NAV</span>
      <span class="legend-item"><span class="legend-fill" style="background:rgba(232,64,87,0.2)"></span> Below NAV</span>
    </div>
    <div class="nav-stats-bar" id="nav-stats-bar"></div>
  </div>

  <!-- Address section -->
  <div class="addr-section" id="addr-section"></div>

  <!-- Allowance section -->
  <div class="allowance-section" id="allowance-section" style="display:none">
    <div class="section-title" style="font-size:13px;font-weight:600;color:var(--bright);margin-bottom:12px;font-family:Inter,sans-serif">Allowance Schedule</div>
    <div class="allowance-cards" id="allowance-cards" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:10px;margin-bottom:14px"></div>
    <div class="allowance-history" id="allowance-history" style="font-size:10px;color:var(--dim);font-family:'JetBrains Mono',monospace"></div>
  </div>

  <div class="footer">
    <a href="index.html">← NAVgator Home</a> · <a href="submit.html">Submit a Token</a> · Treasury analytics for ownership tokens · Not financial advice
  </div>

  </div><!-- /dashboard-view -->
</div><!-- /wrap -->

<script>
// ═══════════════════════════════════════════════════════════════════════
// VIEW ROUTING — landing page vs dashboard
// ═══════════════════════════════════════════════════════════════════════
const _params = new URLSearchParams(window.location.search);
const _hasToken = _params.has('token');

if (_hasToken) {
  document.getElementById('dashboard-view').classList.add('active');
  document.title = 'NAVgator · Dashboard';
} else {
  document.getElementById('landing-view').classList.add('active');
  document.title = 'NAVgator — Treasury Analytics for Ownership Tokens';
}

// ═══════════════════════════════════════════════════════════════════════
// TOKEN CONFIGS
// ═══════════════════════════════════════════════════════════════════════
const TOKENS = {
  solo: { live: true,
    name: 'Solomon', ticker: 'SOLO', pair: 'SOLO/USDC',
    color: '#00e5a0', logo: 'logos/solo.jpg',
    mint: 'SoLo9oxzLDpcq1dpqAgMwgce5WqkRDtNXK7EPnbmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: '98SPcyUZ2rqM2dgjCqqSXS4gJrNTLSNUAAVCF38xYj9u',
    ammWallet: 'DzYtzoNvPbyFCzwZA6cSm9eDEEmxEB9f8AGkJXUXgnSA',
    ammWallet2: '2zsbECzM7roqnDcuv2TNGpfv5PAnuqGmMo5YPtqmUz5p',
    lockWallet: 'Bo24B7DDVtpa9VxZ4LN8FrAT7TM3cgkri41a5GjFg5Dk',
    gtPool: 'o5rJFXSKTsuws58rBMNPG8jdKdnY4Z7ouU29dyohE4g',
    raise: 8_000_000, supply: 10_000_000, icoPrice: 0.80, ath: 1.09,
    monthlyBurn: 100_000, monthlyAllowance: 100_000, realizedVol: 99, tradingDays: 85,
    genesisStrike: 0.62, genesisPut: 0.300,
    spot: 0.55, treasuryUSDC: 7_420_000, ammUSDCFixed: null,
    tge: '2025-11-18',
    draws: [
      { date: '2025-12-01', amount: 100_000, label: 'Draw #1' },
      { date: '2026-01-01', amount: 100_000, label: 'Draw #2' },
      { date: '2026-02-01', amount: 100_000, label: 'Draw #3' },
    ],
  },
  zkfg: { live: true,
    name: 'ZKLSOL', ticker: 'ZKFG', pair: 'ZKFG/USDC',
    color: '#9f8cfc',
    mint: 'ZKFHiLAfAFMTcDAuCtjNW54VzpERvoe7PBF9mYgmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: 'BNvDfXYG2FAyBDYD71Xr9GhKE18MbmhtjsLKsCuXho6z',
    ammWallet: '5FPGRzY9ArJFwY2Hp2y2eqMzVewyWCBox7esmpuZfCvE',
    gtPool: 'JDuK4Wp3MQM6d9QKDNDNgoELHkfAMSqbbqzbmkz19vis',
    raise: 970_000, supply: 10_000_000, icoPrice: 0.097, ath: 0.145,
    monthlyBurn: 50_000, realizedVol: 120, tradingDays: 107,
    genesisStrike: 0.097, genesisPut: 0.055,
    spot: 0.0654, treasuryUSDC: 820_000, ammUSDCFixed: null,
    tge: '2025-10-24',
    draws: [
      { date: '2025-11-24', amount: 50_000, label: 'Draw #1' },
      { date: '2025-12-24', amount: 50_000, label: 'Draw #2' },
      { date: '2026-01-24', amount: 50_000, label: 'Draw #3' },
    ],
  },
  umbra: { live: true,
    name: 'Umbra', ticker: 'UMBRA', pair: 'UMBRA/USDC',
    color: '#00c2ff', logo: 'logos/umbra.jpg',
    mint: 'PRVT6TB7uss3FrUd2D9xs2zqDBsa3GbMJMwCQsgmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: '6VsC8PuKkXm5xo54c2vbrAaSfQipkpGHqNuKTxXFySx6',
    ammWallet: 'BLkBSE96kQys7SrMioKxeMiVbeo4Ckk2Y4n1JphKxYnv',
    ammWallet2: '7dVri3qjYD3uobSZL3Zth8vSCgU6r6R2nvFsh7uVfDte',
    lockWallet: '3kX3EWm9iPB6oxFS2NJ71L6v5wzFZ8rQMEG6HC8QHJtF',
    gtPool: '7dVri3qjYD3uobSZL3Zth8vSCgU6r6R2nvFsh7uVfDte',
    gtPoolLegacy: 'BLkBSE96kQys7SrMioKxeMiVbeo4Ckk2Y4n1JphKxYnv',
    raise: 3_000_000, supply: 10_000_000, icoPrice: 0.30, ath: 2.43,
    monthlyBurn: 34_000, monthlyAllowance: 100_000, realizedVol: 110, tradingDays: 122,
    genesisStrike: 0.24, genesisPut: 0.12,
    spot: 0.76, treasuryUSDC: 3_360_000, ammUSDCFixed: null,
    tge: '2025-10-10',
    draws: [
      { date: '2025-11-10', amount: 34_000, label: 'Draw #1' },
      { date: '2025-12-10', amount: 34_000, label: 'Draw #2' },
      { date: '2026-01-10', amount: 34_000, label: 'Draw #3' },
      { date: '2026-02-10', amount: 34_000, label: 'Draw #4' },
    ],
  },
  avici: { live: true,
    name: 'Avici', ticker: 'AVICI', pair: 'AVICI/USDC',
    color: '#ff6b9d', logo: 'logos/avici.jpg',
    mint: 'BANKJmvhT8tiJRsBSS1n2HryMBPvT5Ze4HU95DUAmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: 'DGgYoUcu1aDZt4GEL5NQiducwHRGbkMWsUzsXh2j622G',
    ammWallet: '3D854kknnQhu9xVaRNV154oZ9oN2WF3tXsq3LDu7fFMn',
    ammWallet2: '5gB4NPgFB3MHFHSeKN4sbaY6t9MB8ikCe9HyiKYid4Td',
    gtPool: '5gB4NPgFB3MHFHSeKN4sbaY6t9MB8ikCe9HyiKYid4Td',
    gtPoolLegacy: '3D854kknnQhu9xVaRNV154oZ9oN2WF3tXsq3LDu7fFMn',
    raise: 3_500_000, supply: 12_900_000, icoPrice: 0.35, ath: 7.57,
    monthlyBurn: 45_000, monthlyAllowance: 100_000, realizedVol: 130, tradingDays: 114,
    genesisStrike: 0.22, genesisPut: 0.11,
    spot: 1.08, treasuryUSDC: 3_300_000, ammUSDCFixed: null,
    tge: '2025-10-18',
    draws: [
      { date: '2025-11-18', amount: 45_000, label: 'Draw #1' },
      { date: '2025-12-18', amount: 45_000, label: 'Draw #2' },
      { date: '2026-01-18', amount: 45_000, label: 'Draw #3' },
    ],
  },
  loyal: { live: true,
    name: 'Loyal', ticker: 'LOYAL', pair: 'LOYAL/USDC',
    color: '#ffd700',
    mint: 'LoyALuiy1mRSpjRBRw3iCp88T7xSD4kxTL6uYdpAmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: 'AQyyTwCKemeeMu8ZPZFxrXMbVwAYTSbBhi1w4PBrhvYE',
    ammWallet: 'GxpJkPEsPmuRCCTNnfZaDKg4X3gf4ZPgmqgFqtibaPtK',
    ammWallet2: 'BGg7WsK98rhqtTp2uSKMa2yETqgwShFAjyf1RmYqCF7n',
    buybackWallet: 'AfGAjj7TQByC2WQtCNRhsyq1WeZqmQ7oNRoGb2JbgoQg',
    gtPool: 'BGg7WsK98rhqtTp2uSKMa2yETqgwShFAjyf1RmYqCF7n',
    gtPoolLegacy: 'GxpJkPEsPmuRCCTNnfZaDKg4X3gf4ZPgmqgFqtibaPtK',
    raise: 500_000, supply: 10_000_000, icoPrice: 0.05, ath: 0.37,
    monthlyBurn: 45_000, realizedVol: 140, tradingDays: 114,
    genesisStrike: 0.038, genesisPut: 0.02,
    spot: 0.13, treasuryUSDC: 420_000, ammUSDCFixed: null,
    tge: '2025-10-23',
    draws: [
      { date: '2025-11-23', amount: 45_000, label: 'Draw #1' },
      { date: '2025-12-23', amount: 45_000, label: 'Draw #2' },
      { date: '2026-01-23', amount: 45_000, label: 'Draw #3' },
    ],
  },
  paystream: { live: false,
    name: 'Paystream', ticker: 'PAY', pair: 'PAY/USDC',
    color: '#44ddaa',
    mint: '',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: 'BpXtB2ASf2Tft97ewTd8PayXCqFQ6Wqod33qrwwfK9Vz',
    ammWallet: '6FRXzTe3HajL8Fwmmkupp8g3y3wn3g3QEjj8sABndre3',
    ammWallet2: '6F88Y6iukU9GuL8CMWnx6YT832vBymNPicJBikQWeYe4',
    buybackWallet: '3BAUsXfhhK2H1KH18GYNhUvLUsPrKWcePEA5N2UKP6VL',
    gtPool: '6F88Y6iukU9GuL8CMWnx6YT832vBymNPicJBikQWeYe4',
    gtPoolLegacy: '6FRXzTe3HajL8Fwmmkupp8g3y3wn3g3QEjj8sABndre3',
    raise: 300_000, supply: 10_000_000, icoPrice: 0.03, ath: 0.04,
    monthlyBurn: 15_000, realizedVol: 100, tradingDays: 100,
    genesisStrike: 0.024, genesisPut: 0.012,
    spot: 0.021, treasuryUSDC: 255_000, ammUSDCFixed: null,
    tge: '2025-10-27',
    draws: [
      { date: '2025-11-27', amount: 15_000, label: 'Draw #1' },
      { date: '2025-12-27', amount: 15_000, label: 'Draw #2' },
      { date: '2026-01-27', amount: 15_000, label: 'Draw #3' },
    ],
  },
  omfg: { live: true,
    name: 'Omnipair', ticker: 'OMFG', pair: 'OMFG/USDC',
    color: '#ff8855', logo: 'logos/omfg.png',
    mint: 'omfgRBnxHsNJh6YeGbGAmWenNkenzsXyBXm3WDhmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: '34rned2SLUcYjUrM9meQkuyJY4QDBcKhkcUPXCgGuXD9',
    ammWallet: '2WNhaB6TPyZ3ynJjAUM4ZZ1Hdeep8FJ3A76FjGjTVjjS',
    ammWallet2: 'BiNnErm2VDkbKGiABj9ZRUjybz879NhH2heeWE7m5M6d',
    gtPool: 'BiNnErm2VDkbKGiABj9ZRUjybz879NhH2heeWE7m5M6d',
    gtPoolLegacy: '2WNhaB6TPyZ3ynJjAUM4ZZ1Hdeep8FJ3A76FjGjTVjjS',
    raise: 500_000, supply: 10_000_000, icoPrice: 0.05, ath: 0.83,
    monthlyBurn: 25_000, monthlyAllowance: 50_000, realizedVol: 120, tradingDays: 130,
    genesisStrike: 0.04, genesisPut: 0.02,
    spot: 0.32, treasuryUSDC: 400_000, ammUSDCFixed: null,
    tge: '2025-07-28',
    draws: [
      { date: '2025-11-02', amount: 25_000, label: 'Draw #1' },
      { date: '2025-12-02', amount: 25_000, label: 'Draw #2' },
      { date: '2026-01-02', amount: 25_000, label: 'Draw #3' },
      { date: '2026-02-02', amount: 25_000, label: 'Draw #4' },
    ],
  },
  meta: { live: false,
    name: 'MetaDAO', ticker: 'META', pair: 'META/USDC',
    color: '#ff5533',
    mint: 'METAwkXcqyXKy1AtsSgJ8JiUHwGCafnZL38n3vYmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: 'BfzJzFUeE54zv6Q2QdAZR4yx7UXuYRsfkeeirrRcxDvk',
    ammWallet: 'CUPoiqkK4hxyCiJcLC4yE9AtJP1MoV1vFV2vx3jqwWeS',
    ammWallet2: 'EXpXkwcWDhjEYyC5pfNfxsu8fUtK4CDCYTZR4ApQNRzo',
    gtPool: 'EXpXkwcWDhjEYyC5pfNfxsu8fUtK4CDCYTZR4ApQNRzo',
    gtPoolLegacy: 'CUPoiqkK4hxyCiJcLC4yE9AtJP1MoV1vFV2vx3jqwWeS',
    raise: 0, supply: 22_080_000, icoPrice: 0.17, ath: 10.69,
    monthlyBurn: 0, realizedVol: 95, tradingDays: 300,
    genesisStrike: 0, genesisPut: 0,
    spot: 3.78, treasuryUSDC: 0, ammUSDCFixed: null,
    tge: '2025-04-09',
    draws: [],
    note: 'Platform token — no ICO treasury structure. Treasury analytics are approximate.',
  },
  rngr: { live: true,
    name: 'Ranger', ticker: 'RNGR', pair: 'RNGR/USDC',
    color: '#22dd88', logo: 'logos/rngr.jpg',
    mint: 'RNGRtJMbCveqCp7AC6U95KmrdKecFckaJZiWbPGmeta',
    usdcMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
    daoWallet: '55H1Q1YrHJQ93uhG4jqrBBHx3a8H7TCM8kvf2UM2g5q3',
    ammWallet: '1PAwyDkWNFCcR96GhEReXHJBv3YEFVazCaQgNicVuKv',
    ammWallet2: '59WuweKV7DAg8aUgRhNytScQxioaFYNJdWnox5FxAXFq',
    lockWallet: 'F35JE1HZMtZXXWdy3koSPRe1gGFQyqd5kpbPw2xNcjR8',
    gtPool: '59WuweKV7DAg8aUgRhNytScQxioaFYNJdWnox5FxAXFq',
    gtPoolLegacy: '1PAwyDkWNFCcR96GhEReXHJBv3YEFVazCaQgNicVuKv',
    raise: 8_000_000, supply: 10_000_000, icoPrice: 0.80, ath: 0.865,
    monthlyBurn: 250_000, monthlyAllowance: 250_000, realizedVol: 90, tradingDays: 32,
    genesisStrike: 0.47, genesisPut: 0.18,
    spot: 0.54, treasuryUSDC: 5_750_000, ammUSDCFixed: null,
    tge: '2026-01-10',
    draws: [
      { date: '2026-02-10', amount: 250_000, label: 'Draw #1' },
    ],
  },
};
// ═══════════════════════════════════════════════════════════════════════
// LANDING PAGE LOGIC
// ═══════════════════════════════════════════════════════════════════════
if (!_hasToken) {
  const landingTokens = Object.entries(TOKENS).map(([key, t]) => ({
    key, ticker: t.ticker, name: t.name, color: t.color, logo: t.logo || null,
    spot: t.spot, strike: t.raise > 0 ? t.treasuryUSDC / t.supply : 0,
    treasury: t.treasuryUSDC, mcap: t.spot * t.supply, live: t.live,
    supply: t.supply, effectiveSupply: t.supply,
    monthlyAllowance: t.monthlyAllowance || 0,
  }));

  const lfmt$ = (n) => n >= 1 ? '$' + n.toFixed(2) : n >= 0.01 ? '$' + n.toFixed(4) : '$' + n.toFixed(6);
  const lfmtK = n => n >= 1e6 ? '$' + (n / 1e6).toFixed(2) + 'M' : n >= 1e3 ? '$' + (n / 1e3).toFixed(0) + 'K' : '$' + n.toFixed(0);
  const iconHtml = (t) => t.logo ? '<div class="tt-icon"><img src="' + t.logo + '" alt="' + t.ticker + '"></div>' : '<div class="tt-icon" style="background:' + t.color + '">' + t.ticker[0] + '</div>';

  function drawSparkline(canvas, priceData, navData) {
    if ((!priceData || priceData.length < 2) && (!navData || navData.length < 2)) return;
    var ctx = canvas.getContext('2d');
    var w = canvas.width = canvas.offsetWidth * 2;
    var h = canvas.height = canvas.offsetHeight * 2;
    ctx.clearRect(0, 0, w, h);

    // Combine all values to get shared min/max
    var allVals = (priceData || []).concat(navData || []);
    var min = Math.min(...allVals), max = Math.max(...allVals);
    var range = max - min || 1;

    // Calculate price change % for glow intensity
    var mainData = priceData && priceData.length >= 2 ? priceData : navData;
    var first = mainData[0], last = mainData[mainData.length - 1];
    var changePct = Math.abs((last - first) / first * 100);
    // Glow intensity: 0 at 0% change, max at 30%+ change
    var glowIntensity = Math.min(changePct / 30, 1);
    var isUp = last >= first;
    var lineColor = isUp ? '#00e5a0' : '#e84057';
    var glowBlur = 4 + glowIntensity * 12; // 4px to 16px blur
    var glowAlpha = 0.2 + glowIntensity * 0.6; // 0.2 to 0.8 opacity

    function getPath(data) {
      var pts = [];
      for (var i = 0; i < data.length; i++) {
        var x = (i / (data.length - 1)) * w;
        var y = h - ((data[i] - min) / range) * (h - 4) - 2;
        pts.push([x, y]);
      }
      return pts;
    }

    function strokePath(pts, color, width, dash) {
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      if (dash) ctx.setLineDash(dash);
      else ctx.setLineDash([]);
      for (var i = 0; i < pts.length; i++) {
        i === 0 ? ctx.moveTo(pts[i][0], pts[i][1]) : ctx.lineTo(pts[i][0], pts[i][1]);
      }
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // NAV line (behind), dashed, dimmer
    if (navData && navData.length >= 2) {
      var navPts = getPath(navData);
      strokePath(navPts, 'rgba(232,64,87,0.5)', 1.5, [4, 3]);
    }

    // Price line with glow
    if (priceData && priceData.length >= 2) {
      var pricePts = getPath(priceData);
      // Glow layer
      if (glowIntensity > 0.05) {
        ctx.save();
        ctx.shadowColor = lineColor;
        ctx.shadowBlur = glowBlur;
        ctx.globalAlpha = glowAlpha;
        strokePath(pricePts, lineColor, 2.5, null);
        // Double pass for stronger glow
        if (glowIntensity > 0.4) strokePath(pricePts, lineColor, 2, null);
        ctx.restore();
      }
      // Crisp line on top
      strokePath(pricePts, lineColor, 2, null);

      // Fill under the line with faint gradient
      if (glowIntensity > 0.1) {
        ctx.beginPath();
        for (var i = 0; i < pricePts.length; i++) {
          i === 0 ? ctx.moveTo(pricePts[i][0], pricePts[i][1]) : ctx.lineTo(pricePts[i][0], pricePts[i][1]);
        }
        ctx.lineTo(pricePts[pricePts.length - 1][0], h);
        ctx.lineTo(pricePts[0][0], h);
        ctx.closePath();
        var grad = ctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, lineColor.replace(')', ',' + (glowAlpha * 0.3) + ')').replace('rgb', 'rgba').replace('#00e5a0', 'rgba(0,229,160,' + (glowAlpha * 0.3) + ')').replace('#e84057', 'rgba(232,64,87,' + (glowAlpha * 0.3) + ')'));
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        // Simpler fill approach
        ctx.fillStyle = isUp ? 'rgba(0,229,160,' + (glowIntensity * 0.15) + ')' : 'rgba(232,64,87,' + (glowIntensity * 0.15) + ')';
        ctx.fill();
      }
    } else if (navData && navData.length >= 2) {
      // Only NAV data — draw plain line, no glow
      var navPts2 = getPath(navData);
      var navFirst = navData[0], navLast = navData[navData.length - 1];
      var navColor = navLast >= navFirst ? '#00e5a0' : '#e84057';
      strokePath(navPts2, navColor, 2, null);
    }
  }

  let currentSort = 'treasury';
  let sortDir = 'desc'; // 'asc' or 'desc'

  const sortKeys = ['', 'name', 'price', 'nav', 'vsNav', 'treasury', 'mcap', ''];
  // Column index: 0=#, 1=Name, 2=Price, 3=NAV, 4=vsNAV, 5=Treasury, 6=MCap, 7=Trend

  function renderTable() {
    const sorted = [...landingTokens].sort((a, b) => {
      let va, vb;
      if (currentSort === 'treasury') { va = a.treasury; vb = b.treasury; }
      else if (currentSort === 'price') { va = a.spot; vb = b.spot; }
      else if (currentSort === 'nav') { va = a.strike; vb = b.strike; }
      else if (currentSort === 'vsNav') {
        va = a.strike > 0 ? (a.spot - a.strike) / a.strike : -999;
        vb = b.strike > 0 ? (b.spot - b.strike) / b.strike : -999;
      }
      else if (currentSort === 'mcap') { va = a.mcap; vb = b.mcap; }
      else if (currentSort === 'name') { return sortDir === 'asc' ? a.name.localeCompare(b.name) : b.name.localeCompare(a.name); }
      else { va = a.mcap; vb = b.mcap; }
      return sortDir === 'asc' ? va - vb : vb - va;
    });

    const tbody = document.getElementById('token-tbody');
    tbody.innerHTML = sorted.map((t, i) => {
      if (!t.live) {
        return '<tr onclick="location.href=\'index.html?token=' + t.key + '\'" style="opacity:0.4">' +
          '<td>' + (i + 1) + '</td>' +
          '<td><div class="tt-name-cell">' + iconHtml(t) + '<div><div class="tt-name">' + t.name + '</div><div class="tt-ticker">' + t.ticker + '</div></div></div></td>' +
          '<td colspan="6"><span class="tt-coming">Coming Soon</span></td></tr>';
      }
      var discPct = t.strike > 0 ? ((t.spot - t.strike) / t.strike * 100) : 0;
      var isDiscount = discPct < 0;
      var discLabel = t.strike === 0 ? '—' : (isDiscount ? '-' + Math.abs(discPct).toFixed(1) + '%' : '+' + discPct.toFixed(1) + '%');
      var discColor = t.strike === 0 ? 'var(--dim)' : (isDiscount ? '#e84057' : 'var(--green)');
      var allowLabel = t.monthlyAllowance > 0 ? lfmtK(t.monthlyAllowance) + '/mo' : '—';

      return '<tr onclick="location.href=\'index.html?token=' + t.key + '\'">' +
        '<td>' + (i + 1) + '</td>' +
        '<td><div class="tt-name-cell">' + iconHtml(t) + '<div><div class="tt-name">' + t.name + '</div><div class="tt-ticker">' + t.ticker + '</div></div></div></td>' +
        '<td><div class="tt-price">' + lfmt$(t.spot) + '</div></td>' +
        '<td style="color:var(--text)">' + (t.strike > 0 ? lfmt$(t.strike) : '—') + '</td>' +
        '<td style="color:' + discColor + ';font-weight:500">' + discLabel + '</td>' +
        '<td style="color:var(--text)">' + lfmtK(t.treasury) + '</td>' +
        '<td style="color:var(--text)">' + lfmtK(t.mcap) + '</td>' +
        '<td><canvas class="tt-sparkline" data-token="' + t.key + '"></canvas></td>' +
        '</tr>';
    }).join('');

    // Sort header highlights and arrows
    document.querySelectorAll('.token-table thead th').forEach((th, idx) => {
      th.classList.remove('sorted');
      var key = sortKeys[idx];
      // Remove old arrow
      var oldArrow = th.querySelector('.sort-arrow');
      if (oldArrow) oldArrow.remove();
      if (key === currentSort) {
        th.classList.add('sorted');
        var arrow = document.createElement('span');
        arrow.className = 'sort-arrow';
        arrow.textContent = sortDir === 'desc' ? ' ▼' : ' ▲';
        arrow.style.cssText = 'font-size:8px;opacity:0.8';
        th.appendChild(arrow);
      }
    });
  }

  renderTable();

  // Column sort click handlers
  document.querySelectorAll('.token-table thead th').forEach((th, idx) => {
    th.addEventListener('click', function() {
      var key = sortKeys[idx];
      if (!key) return; // skip # and Trend columns
      if (currentSort === key) {
        sortDir = sortDir === 'desc' ? 'asc' : 'desc';
      } else {
        currentSort = key;
        sortDir = 'desc';
      }
      renderTable();
      loadSparklines();
    });
  });

  // Fetch live data from backend API
  const API_BASE = 'https://navgator-api.vercel.app';

  async function fetchLandingData() {
    try {
      const res = await fetch(API_BASE + '/api/current');
      const data = await res.json();
      if (!data.tokens) return;
      for (const t of data.tokens) {
        if (t.error) continue;
        const lt = landingTokens.find(x => x.key === t.token);
        if (!lt) continue;
        if (t.spot > 0) { lt.spot = t.spot; lt.mcap = t.spot * (t.effectiveSupply || TOKENS[t.token].supply); }
        if (t.treasuryUSDC > 0 && t.effectiveSupply > 0) { lt.treasury = t.treasuryUSDC; lt.strike = t.treasuryUSDC / t.effectiveSupply; lt.effectiveSupply = t.effectiveSupply; }
      }
      renderTable();
      loadSparklines();
      console.log('NAVgator landing: live data loaded from API');
    } catch (e) { console.warn('API fetch failed:', e.message); }
  }

  // Load sparklines from NAV history (shows both price + NAV)
  async function loadSparklines() {
    for (const t of landingTokens) {
      if (!t.live) continue;
      try {
        const res = await fetch(API_BASE + '/api/history?token=' + t.key + '&days=30');
        const data = await res.json();
        if (data.history && data.history.length > 1) {
          const prices = data.history.map(h => h.spot).filter(s => s > 0);
          const navs = data.history.map(h => h.nav).filter(n => n > 0);
          const canvas = document.querySelector('canvas[data-token="' + t.key + '"]');
          if (canvas) drawSparkline(canvas, prices, navs);
        }
      } catch (e) {}
    }
  }

  fetchLandingData();
  setTimeout(loadSparklines, 500);
}

// ═══════════════════════════════════════════════════════════════════════
// DASHBOARD LOGIC (only when ?token= is present)
// ═══════════════════════════════════════════════════════════════════════
if (_hasToken) {
const params = new URLSearchParams(window.location.search);
const tokenKey = (params.get('token') || 'solo').toLowerCase();
const CFG = TOKENS[tokenKey] || TOKENS.solo;
const API_BASE_DASH = 'https://navgator-api.vercel.app';

document.title = `NAVgator · ${CFG.ticker}/USDC — Treasury Analytics`;

// Build nav — dim non-live tokens
const navEl = document.getElementById('nav');
const LIVE_KEYS = new Set(Object.entries(TOKENS).filter(([k,v]) => v.live).map(([k]) => k));
let navHTML = '<a href="index.html" class="nav-brand"><svg width="22" height="14" viewBox="0 0 160 100" style="flex-shrink:0"><ellipse cx="80" cy="50" rx="55" ry="30" fill="none" stroke="#00e5a0" stroke-width="6"/><ellipse cx="80" cy="50" rx="7" ry="26" fill="#00e5a0"/></svg> NAV<span>gator</span></a><span class="nav-sep">·</span><div class="nav-tokens">';
for (const [key, tok] of Object.entries(TOKENS)) {
  const isLive = LIVE_KEYS.has(key);
  const dimStyle = !isLive ? 'opacity:0.35;pointer-events:none;' : '';
  navHTML += `<a class="nav-tok${key===tokenKey?' active':''}" href="index.html?token=${key}" style="${dimStyle}${key===tokenKey?'border-color:'+tok.color+';color:'+tok.color:''}">${tok.ticker}</a>`;
}
navHTML += '</div>';
navEl.innerHTML = navHTML;

// If token is not live, show coming soon overlay and stop
if (!CFG.live) {
  document.getElementById('sub-line').textContent = 'COMING SOON';
  document.getElementById('title').textContent = CFG.name + ' — Coming Soon';
  document.getElementById('desc').innerHTML = `<b>${CFG.ticker}</b> dashboard is under development. Treasury tracking, price charts, and analytics will be available soon.`;
  document.getElementById('cards').innerHTML = '';
  document.getElementById('params').innerHTML = '';
  document.getElementById('chart-loading').textContent = 'Coming Soon';
  const scs = document.getElementById('strike-chart-section');
  if (scs) scs.style.display = 'none';
}

// ═══════════════════════════════════════════════════════════════════════
// MATH
// ═══════════════════════════════════════════════════════════════════════
const pDec = (v) => v >= 1 ? 2 : v >= 0.01 ? 4 : 6;
const fmt$ = (n,d) => '$'+n.toFixed(d !== undefined ? d : pDec(n));
const fmtM = n => n>=1e6?'$'+(n/1e6).toFixed(1)+'M':n>=1e3?'$'+(n/1e3).toFixed(0)+'K':fmt$(n,2);
const fmtBurn = n => n>=1e6?'$'+(n/1e6).toFixed(1)+'M':n>=1e3?'$'+(n/1e3).toFixed(0)+'K':'$'+n;

// ═══════════════════════════════════════════════════════════════════════
// LIVE DATA FETCHERS
// ═══════════════════════════════════════════════════════════════════════
async function fetchOHLCV() {
  var candles = await fetchCandlesForTF('1D');
  return candles.length > 0 ? candles : null;
}

async function fetchFromAPI() {
  try {
    const res = await fetch(API_BASE_DASH + '/api/current?token=' + tokenKey);
    const data = await res.json();
    if (data.error) return false;
    if (data.spot > 0) CFG.spot = data.spot;
    if (data.treasuryUSDC > 0) CFG.treasuryUSDC = data.treasuryUSDC;
    if (data.effectiveSupply > 0) CFG.effectiveSupply = data.effectiveSupply;
    if (data.onChainSupply > 0) CFG.onChainSupply = data.onChainSupply;
    if (data.lockedTokens > 0) CFG.lockTokenBalance = data.lockedTokens;
    if (data.ammTokens > 0) CFG.ammTokens = data.ammTokens;
    if (data.daoTokens > 0) CFG.daoTokenBalance = data.daoTokens;
    if (data.buybackTokens > 0) CFG.buybackTokenBalance = data.buybackTokens;
    if (data.futAmmTokens >= 0) CFG.futAmmTokens = data.futAmmTokens;
    if (data.metAmmTokens >= 0) CFG.metAmmTokens = data.metAmmTokens;
    if (data.meteoraPoolUSDC >= 0) CFG.metAmmUSDC = data.meteoraPoolUSDC;
    CFG.futAmmUSDC = 0; // TODO: add to API response
    console.log('API data:', data);
    return true;
  } catch (e) { console.warn('API fetch failed:', e.message); return false; }
}

// ═══════════════════════════════════════════════════════════════════════
// FALLBACK SIMULATED DATA
// ═══════════════════════════════════════════════════════════════════════


// ═══════════════════════════════════════════════════════════════════════
// CHART — Custom Canvas
// ═══════════════════════════════════════════════════════════════════════
var _allCandles = {};
var _navPerToken = 0;
var _navHistory = [];
var _chartTF = '1D';
var _allowancePayments = [];

// Chart state
var _chart = {
  canvas: null, ctx: null, tooltip: null,
  priceData: [], navData: [],
  viewStart: 0, viewEnd: 1, // 0-1 range for zoom/pan
  isDragging: false, dragStartX: 0, dragStartView: 0,
  width: 0, height: 420,
  padding: { top: 20, right: 70, bottom: 30, left: 10 },
};

// Fetch historical NAV data from backend
async function fetchNAVHistory() {
  try {
    var res = await fetch(API_BASE_DASH + '/api/history?token=' + tokenKey + '&days=365');
    var json = await res.json();
    if (json.history && json.history.length > 0) {
      _navHistory = json.history.map(function(h) {
        return { time: Math.floor(new Date(h.date).getTime() / 1000), value: h.nav };
      });
      var seen = {};
      _navHistory = _navHistory.filter(function(h) {
        if (seen[h.time]) return false;
        seen[h.time] = true;
        return true;
      });
      _navHistory.sort(function(a, b) { return a.time - b.time; });

      // Insert TGE starting point
      if (CFG.tge && CFG.icoPrice > 0) {
        var tgeTime = Math.floor(new Date(CFG.tge + 'T00:00:00Z').getTime() / 1000);
        if (_navHistory.length === 0 || tgeTime < _navHistory[0].time) {
          _navHistory.unshift({ time: tgeTime, value: CFG.icoPrice });
        }
      }
    }
  } catch (e) { console.error('NAV history fetch error:', e); }
}

async function fetchCandlesForTF(tf) {
  if (_allCandles[tf]) return _allCandles[tf];
  if (!CFG.mint) return [];
  try {
    var tge = new Date(CFG.tge || '2025-01-01');
    var now = new Date();
    var birdeyeTF = { '12H': '12H', '1D': '1D', '1W': '1W', '1M': '1M' }[tf] || '1D';
    var url = API_BASE_DASH + '/api/ohlcv?token=' + tokenKey + '&tf=' + birdeyeTF + '&time_from=' + Math.floor(tge.getTime() / 1000) + '&time_to=' + Math.floor(now.getTime() / 1000);
    var resp = await fetch(url);
    var json = await resp.json();
    if (!json.data || !json.data.items) return [];
    var candles = json.data.items.map(function(c) {
      return { date: new Date(c.unixTime * 1000), time: c.unixTime, open: c.o, high: c.h, low: c.l, close: c.c, price: c.c };
    });
    _allCandles[tf] = candles;
    return candles;
  } catch (e) { return []; }
}

function buildChart(candles, navPerToken) {
  var container = document.getElementById('chart-container');
  var canvas = document.getElementById('chart-canvas');
  var tooltip = document.getElementById('chart-tooltip');
  if (!canvas || !container) { console.error('Chart: no canvas or container'); return; }

  var dpr = window.devicePixelRatio || 1;
  var w = container.clientWidth || 800;
  var h = _chart.height;

  canvas.width = w * dpr;
  canvas.height = h * dpr;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';

  _chart.canvas = canvas;
  _chart.ctx = canvas.getContext('2d');
  _chart.ctx.scale(dpr, dpr);
  _chart.tooltip = tooltip;
  _chart.width = w;

  // Build price data array with TGE start
  var priceData = [];
  if (candles && candles.length > 0) {
    priceData = candles.map(function(c) {
      return { time: c.time || Math.floor(c.date.getTime() / 1000), value: c.close || c.price };
    });
  }

  // Inject TGE point
  if (CFG.tge && CFG.icoPrice > 0) {
    var tgeTs = Math.floor(new Date(CFG.tge + 'T00:00:00Z').getTime() / 1000);
    if (priceData.length > 0 && tgeTs <= priceData[0].time) {
      priceData.unshift({ time: tgeTs, value: CFG.icoPrice });
    } else if (priceData.length === 0) {
      priceData.push({ time: tgeTs, value: CFG.icoPrice });
    }
  }

  _chart.priceData = priceData;

  // Cap NAV history with current live NAV
  var navData = _navHistory.slice();
  if (navPerToken > 0 && navData.length > 0) {
    var nowTs = Math.floor(Date.now() / 1000);
    navData.push({ time: nowTs, value: navPerToken });
  }

  // Deduplicate NAV to only keep points where value changes (clean staircase)
  var cleanNav = [];
  for (var i = 0; i < navData.length; i++) {
    if (i === 0) { cleanNav.push(navData[i]); continue; }
    // Keep if value changed from previous
    if (Math.abs(navData[i].value - navData[i - 1].value) > 0.000001) {
      // Add the last point before the change (end of flat line)
      if (cleanNav[cleanNav.length - 1].time !== navData[i - 1].time) {
        cleanNav.push(navData[i - 1]);
      }
      cleanNav.push(navData[i]);
    }
  }
  // Always include the last point
  if (navData.length > 0 && (cleanNav.length === 0 || cleanNav[cleanNav.length - 1].time !== navData[navData.length - 1].time)) {
    cleanNav.push(navData[navData.length - 1]);
  }

  _chart.navData = cleanNav;
  _chart.viewStart = 0;
  _chart.viewEnd = 1;

  drawChart();
  attachChartEvents(container);
}

function getVisibleData(data) {
  if (data.length === 0) return [];
  var start = Math.floor(_chart.viewStart * data.length);
  var end = Math.ceil(_chart.viewEnd * data.length);
  return data.slice(Math.max(0, start), Math.min(data.length, end));
}

function getTimeRange() {
  var allTimes = [];
  _chart.priceData.forEach(function(d) { allTimes.push(d.time); });
  _chart.navData.forEach(function(d) { allTimes.push(d.time); });
  if (allTimes.length === 0) return { min: 0, max: 1 };
  allTimes.sort(function(a, b) { return a - b; });
  var tMin = allTimes[0];
  var tMax = allTimes[allTimes.length - 1];
  var range = tMax - tMin || 1;
  return {
    min: tMin + range * _chart.viewStart,
    max: tMin + range * _chart.viewEnd,
    fullMin: tMin,
    fullMax: tMax,
  };
}

function drawChart() {
  var ctx = _chart.ctx;
  var w = _chart.width;
  var h = _chart.height;
  var pad = _chart.padding;
  if (!ctx) return;

  ctx.clearRect(0, 0, w, h);

  var tr = getTimeRange();
  var tMin = tr.min, tMax = tr.max;
  var tRange = tMax - tMin || 1;

  // Collect visible values for Y range
  var allVals = [];
  _chart.priceData.forEach(function(d) {
    if (d.time >= tMin && d.time <= tMax) allVals.push(d.value);
  });
  // For NAV, include interpolated value at visible boundaries (staircase has few points)
  _chart.navData.forEach(function(d) {
    if (d.time >= tMin && d.time <= tMax) allVals.push(d.value);
  });
  // Also include the NAV value that's active at the start of the visible range
  for (var ni = _chart.navData.length - 1; ni >= 0; ni--) {
    if (_chart.navData[ni].time <= tMin) { allVals.push(_chart.navData[ni].value); break; }
  }
  // And the NAV value active at the end
  for (var ni = _chart.navData.length - 1; ni >= 0; ni--) {
    if (_chart.navData[ni].time <= tMax) { allVals.push(_chart.navData[ni].value); break; }
  }
  if (allVals.length === 0) {
    ctx.fillStyle = '#555560';
    ctx.font = '12px Inter, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Chart data unavailable', w / 2, h / 2);
    return;
  }

  var vMin = Math.min.apply(null, allVals);
  var vMax = Math.max.apply(null, allVals);
  var vPad = (vMax - vMin) * 0.1 || 0.01;
  vMin -= vPad;
  vMax += vPad;
  var vRange = vMax - vMin || 1;

  var plotW = w - pad.left - pad.right;
  var plotH = h - pad.top - pad.bottom;

  var tx = function(t) { return pad.left + ((t - tMin) / tRange) * plotW; };
  var ty = function(v) { return pad.top + (1 - (v - vMin) / vRange) * plotH; };

  // Grid lines
  ctx.strokeStyle = 'rgba(34,34,40,0.8)';
  ctx.lineWidth = 1;
  var gridSteps = 5;
  for (var i = 0; i <= gridSteps; i++) {
    var gy = pad.top + (i / gridSteps) * plotH;
    ctx.beginPath(); ctx.moveTo(pad.left, gy); ctx.lineTo(w - pad.right, gy); ctx.stroke();
    // Y labels
    var gVal = vMax - (i / gridSteps) * vRange;
    ctx.fillStyle = '#555560';
    ctx.font = '10px Inter, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('$' + gVal.toFixed(gVal >= 1 ? 2 : 4), w - pad.right + 6, gy + 3);
  }

  // Time labels
  ctx.fillStyle = '#555560';
  ctx.font = '10px Inter, sans-serif';
  ctx.textAlign = 'center';
  var tSteps = Math.max(1, Math.min(6, Math.floor(plotW / 100)));
  for (var i = 0; i <= tSteps; i++) {
    var tVal = tMin + (i / tSteps) * tRange;
    var date = new Date(tVal * 1000);
    var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    var label = months[date.getUTCMonth()] + ' ' + date.getUTCDate();
    ctx.fillText(label, tx(tVal), h - 6);
  }

  // Helper: filter data to visible range and convert to pixel coords
  function toPixels(data) {
    var pts = [];
    for (var i = 0; i < data.length; i++) {
      if (data[i].time >= tMin && data[i].time <= tMax) {
        pts.push({ x: tx(data[i].time), y: ty(data[i].value), value: data[i].value, time: data[i].time });
      }
    }
    return pts;
  }

  // For NAV staircase: include the last point before visible range so the line extends in
  function toPixelsNav(data) {
    var pts = [];
    var lastBefore = null;
    for (var i = 0; i < data.length; i++) {
      if (data[i].time < tMin) {
        lastBefore = data[i];
      } else if (data[i].time <= tMax) {
        pts.push({ x: tx(data[i].time), y: ty(data[i].value), value: data[i].value, time: data[i].time });
      }
    }
    // Inject the last point before visible range at the left edge
    if (lastBefore) {
      pts.unshift({ x: tx(tMin), y: ty(lastBefore.value), value: lastBefore.value, time: tMin });
    }
    // Extend the last visible point to the right edge
    if (pts.length > 0) {
      var last = pts[pts.length - 1];
      if (last.time < tMax) {
        pts.push({ x: tx(tMax), y: last.y, value: last.value, time: tMax });
      }
    }
    return pts;
  }

  var pricePts = toPixels(_chart.priceData);
  var navPts = toPixelsNav(_chart.navData);

  // Draw fill between price and NAV lines (gradient: strong at price, fading toward NAV)
  if (pricePts.length > 1 && navPts.length > 1) {
    // Find overall Y bounds for gradient
    var allPriceY = pricePts.map(function(p) { return p.y; });
    var allNavY = navPts.map(function(p) { return p.y; });
    var minPriceY = Math.min.apply(null, allPriceY);
    var maxNavY = Math.max.apply(null, allNavY);
    var maxPriceY = Math.max.apply(null, allPriceY);
    var minNavY = Math.min.apply(null, allNavY);

    // Build the full fill path: price line forward, NAV line backward
    // Then clip and fill with gradient
    ctx.save();

    // Above NAV fill (green) — clip to where price > NAV
    var aboveGrad = ctx.createLinearGradient(0, minPriceY, 0, maxNavY);
    aboveGrad.addColorStop(0, 'rgba(0,229,160,0.30)');
    aboveGrad.addColorStop(1, 'rgba(0,229,160,0.0)');

    // Below NAV fill (red) — clip to where price < NAV  
    var belowGrad = ctx.createLinearGradient(0, maxPriceY, 0, minNavY);
    belowGrad.addColorStop(0, 'rgba(232,64,87,0.30)');
    belowGrad.addColorStop(1, 'rgba(232,64,87,0.0)');

    // Build NAV path points (step function) at same x positions as price
    function navYAtX(xPos) {
      for (var ni = navPts.length - 1; ni >= 0; ni--) {
        if (xPos >= navPts[ni].x) return navPts[ni].y;
      }
      return navPts[0].y;
    }

    // Draw above-NAV fill
    ctx.beginPath();
    for (var i = 0; i < pricePts.length; i++) {
      var navY = navYAtX(pricePts[i].x);
      var clippedY = Math.min(pricePts[i].y, navY); // above NAV means lower Y
      if (i === 0) ctx.moveTo(pricePts[i].x, clippedY);
      else ctx.lineTo(pricePts[i].x, clippedY);
    }
    // Walk back along NAV line
    for (var i = pricePts.length - 1; i >= 0; i--) {
      ctx.lineTo(pricePts[i].x, navYAtX(pricePts[i].x));
    }
    ctx.closePath();
    ctx.fillStyle = aboveGrad;
    ctx.fill();

    // Draw below-NAV fill
    ctx.beginPath();
    for (var i = 0; i < pricePts.length; i++) {
      var navY = navYAtX(pricePts[i].x);
      var clippedY = Math.max(pricePts[i].y, navY); // below NAV means higher Y
      if (i === 0) ctx.moveTo(pricePts[i].x, clippedY);
      else ctx.lineTo(pricePts[i].x, clippedY);
    }
    for (var i = pricePts.length - 1; i >= 0; i--) {
      ctx.lineTo(pricePts[i].x, navYAtX(pricePts[i].x));
    }
    ctx.closePath();
    ctx.fillStyle = belowGrad;
    ctx.fill();

    ctx.restore();
  }

  // Draw price line (white)
  if (pricePts.length > 1) {
    ctx.beginPath();
    ctx.strokeStyle = '#e8e6e3';
    ctx.lineWidth = 2;
    ctx.moveTo(pricePts[0].x, pricePts[0].y);
    for (var i = 1; i < pricePts.length; i++) {
      ctx.lineTo(pricePts[i].x, pricePts[i].y);
    }
    ctx.stroke();
  }

  // Draw fill between NAV and bottom of chart (subtle)
  if (navPts.length > 1) {
    var bottomY = pad.top + plotH;
    ctx.beginPath();
    ctx.moveTo(navPts[0].x, navPts[0].y);
    for (var i = 1; i < navPts.length; i++) {
      ctx.lineTo(navPts[i].x, navPts[i - 1].y);
      ctx.lineTo(navPts[i].x, navPts[i].y);
    }
    ctx.lineTo(navPts[navPts.length - 1].x, bottomY);
    ctx.lineTo(navPts[0].x, bottomY);
    ctx.closePath();
    ctx.fillStyle = 'rgba(255,255,255,0.04)';
    ctx.fill();
  }

  // Draw NAV line (white dashed)
  if (navPts.length > 1) {
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([6, 4]);
    ctx.moveTo(navPts[0].x, navPts[0].y);
    for (var i = 1; i < navPts.length; i++) {
      ctx.lineTo(navPts[i].x, navPts[i - 1].y);
      ctx.lineTo(navPts[i].x, navPts[i].y);
    }
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // TGE circle
  if (CFG.tge && CFG.icoPrice > 0) {
    var tgeTs = Math.floor(new Date(CFG.tge + 'T00:00:00Z').getTime() / 1000);
    if (tgeTs >= tMin && tgeTs <= tMax) {
      var cx = tx(tgeTs), cy = ty(CFG.icoPrice);
      ctx.beginPath();
      ctx.arc(cx, cy, 5, 0, Math.PI * 2);
      ctx.fillStyle = '#ffffff';
      ctx.fill();
      ctx.strokeStyle = '#00e5a0';
      ctx.lineWidth = 2;
      ctx.stroke();
      // Label below
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 10px Inter, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('TGE $' + CFG.icoPrice, cx, cy + 18);
    }
  }

  // Store pixel data for crosshair
  _chart._pricePts = pricePts;
  _chart._navPts = navPts;
  _chart._tx = tx;
  _chart._ty = ty;
  _chart._tMin = tMin;
  _chart._tMax = tMax;
  _chart._vMin = vMin;
  _chart._vMax = vMax;
}

function interpolateNav(navPts, px) {
  if (navPts.length === 0) return null;
  if (px <= navPts[0].x) return navPts[0].y;
  if (px >= navPts[navPts.length - 1].x) return navPts[navPts.length - 1].y;
  for (var i = 0; i < navPts.length - 1; i++) {
    if (px >= navPts[i].x && px <= navPts[i + 1].x) {
      // Step interpolation: use left value
      return navPts[i].y;
    }
  }
  return navPts[navPts.length - 1].y;
}

function attachChartEvents(container) {
  if (container._eventsAttached) return;
  container._eventsAttached = true;
  var canvas = _chart.canvas;

  // Crosshair on mouse move (only when not dragging)
  canvas.addEventListener('mousemove', function(e) {
    if (_chart.isDragging) return;
    var rect = canvas.getBoundingClientRect();
    var mx = e.clientX - rect.left;
    var my = e.clientY - rect.top;
    drawChart();
    drawCrosshair(mx, my);
  });

  canvas.addEventListener('mouseleave', function() {
    if (!_chart.isDragging) drawChart();
    if (_chart.tooltip) _chart.tooltip.style.display = 'none';
  });

  // Zoom with scroll
  canvas.addEventListener('wheel', function(e) {
    e.preventDefault();
    var rect = canvas.getBoundingClientRect();
    var mx = (e.clientX - rect.left) / _chart.width;
    var zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
    var range = _chart.viewEnd - _chart.viewStart;
    var newRange = Math.min(1, Math.max(0.05, range * zoomFactor));
    var center = _chart.viewStart + mx * range;
    _chart.viewStart = Math.max(0, center - mx * newRange);
    _chart.viewEnd = Math.min(1, _chart.viewStart + newRange);
    if (_chart.viewEnd > 1) { _chart.viewEnd = 1; _chart.viewStart = Math.max(0, 1 - newRange); }
    if (_chart.viewStart < 0) { _chart.viewStart = 0; _chart.viewEnd = Math.min(1, newRange); }
    drawChart();
  }, { passive: false });

  // Pan with click-drag
  canvas.addEventListener('mousedown', function(e) {
    _chart.isDragging = true;
    _chart.dragStartX = e.clientX;
    _chart.dragStartViewStart = _chart.viewStart;
    _chart.dragStartViewEnd = _chart.viewEnd;
    _chart.dragRange = _chart.viewEnd - _chart.viewStart;
    canvas.style.cursor = 'grabbing';
    if (_chart.tooltip) _chart.tooltip.style.display = 'none';
  });

  window.addEventListener('mousemove', function(e) {
    if (!_chart.isDragging) return;
    var dx = e.clientX - _chart.dragStartX;
    var shift = -(dx / _chart.width) * _chart.dragRange;
    var newStart = _chart.dragStartViewStart + shift;
    // Clamp: allow panning to edges but not past them
    if (newStart < 0) newStart = 0;
    if (newStart + _chart.dragRange > 1) newStart = 1 - _chart.dragRange;
    _chart.viewStart = newStart;
    _chart.viewEnd = newStart + _chart.dragRange;
    drawChart();
  });

  window.addEventListener('mouseup', function() {
    if (_chart.isDragging) {
      _chart.isDragging = false;
      canvas.style.cursor = 'crosshair';
    }
  });

  // Double click to reset zoom
  canvas.addEventListener('dblclick', function() {
    _chart.viewStart = 0;
    _chart.viewEnd = 1;
    drawChart();
  });

  // Resize
  if (!container._resizeObserver) {
    container._resizeObserver = new ResizeObserver(function() {
      var dpr = window.devicePixelRatio || 1;
      var w = container.clientWidth;
      canvas.width = w * dpr;
      canvas.style.width = w + 'px';
      _chart.width = w;
      _chart.ctx = canvas.getContext('2d');
      _chart.ctx.scale(dpr, dpr);
      drawChart();
    });
    container._resizeObserver.observe(container);
  }
}

function drawCrosshair(mx, my) {
  var ctx = _chart.ctx;
  var w = _chart.width, h = _chart.height;
  var pad = _chart.padding;
  if (!ctx || mx < pad.left || mx > w - pad.right || my < pad.top || my > h - pad.bottom) {
    if (_chart.tooltip) _chart.tooltip.style.display = 'none';
    return;
  }

  // Vertical crosshair
  ctx.beginPath();
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1;
  ctx.setLineDash([4, 4]);
  ctx.moveTo(mx, pad.top);
  ctx.lineTo(mx, h - pad.bottom);
  ctx.stroke();
  // Horizontal
  ctx.beginPath();
  ctx.moveTo(pad.left, my);
  ctx.lineTo(w - pad.right, my);
  ctx.stroke();
  ctx.setLineDash([]);

  // Find closest NAV point
  var closest = null, closestDist = Infinity;
  var navPts = _chart._navPts || [];
  for (var i = 0; i < navPts.length; i++) {
    var d = Math.abs(navPts[i].x - mx);
    if (d < closestDist) { closestDist = d; closest = navPts[i]; }
  }

  // For step-style, use the interpolated NAV value at cursor position
  var navY = interpolateNav(_chart._navPts || [], mx);
  var navVal = null;
  if (navY !== null && _chart._vMin !== undefined) {
    var plotH = h - pad.top - pad.bottom;
    var vRange = _chart._vMax - _chart._vMin;
    navVal = _chart._vMax - ((navY - pad.top) / plotH) * vRange;
  }

  if (closest && closestDist < 50 && navVal !== null) {
    // Dot on NAV line
    ctx.beginPath();
    ctx.arc(mx, navY, 4, 0, Math.PI * 2);
    ctx.fillStyle = '#ffffff';
    ctx.fill();

    // Tooltip
    var tooltip = _chart.tooltip;
    if (tooltip) {
      // Find the time at cursor
      var tRange = _chart._tMax - _chart._tMin || 1;
      var plotW = w - pad.left - pad.right;
      var cursorTime = _chart._tMin + ((mx - pad.left) / plotW) * tRange;
      var date = new Date(cursorTime * 1000);
      var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      var dateStr = months[date.getUTCMonth()] + ' ' + date.getUTCDate() + ', ' + date.getUTCFullYear();
      var fmt = function(v) { return '$' + (v >= 1 ? v.toFixed(2) : v.toFixed(4)); };
      var html = '<div class="tt-price">' + fmt(navVal) + '</div>';
      html += '<div class="tt-line" style="color:#ffffff">NAV per token</div>';
      html += '<div class="tt-date">' + dateStr + '</div>';
      tooltip.innerHTML = html;
      tooltip.style.display = 'block';
      var ttLeft = mx + 16;
      if (ttLeft + 170 > w) ttLeft = mx - 170;
      tooltip.style.left = ttLeft + 'px';
      tooltip.style.top = (navY - 30) + 'px';
    }
  }
}

function initChart(rawCandles, navPerToken) {
  _allCandles['1D'] = rawCandles;
  _navPerToken = navPerToken;
  _chartTF = '1D';

  buildChart(rawCandles, navPerToken);

  var controls = document.getElementById('chart-controls');
  if (controls) {
    controls.addEventListener('click', async function(e) {
      var btn = e.target.closest('.chart-btn');
      if (!btn || !btn.dataset.tf) return;

      controls.querySelectorAll('[data-tf]').forEach(function(b) { b.classList.remove('active'); });
      btn.classList.add('active');
      _chartTF = btn.dataset.tf;
      var candles = await fetchCandlesForTF(_chartTF);
      if (candles.length === 0) candles = rawCandles;
      buildChart(candles, _navPerToken);
      renderNAVStats(candles, _navPerToken);
    });
  }
}

// ═══════════════════════════════════════════════════════════════════════
// RENDER UI
// ═══════════════════════════════════════════════════════════════════════
function renderUI(isLive) {
  const supplyForNAV = CFG.effectiveSupply || CFG.supply;
  const strike = CFG.treasuryUSDC / supplyForNAV;
  const itm = CFG.spot < strike;
  const monthsLeft = CFG.monthlyBurn > 0 ? Math.floor(CFG.treasuryUSDC / CFG.monthlyBurn) : '\u221e';
  const discPct = strike > 0 ? ((CFG.spot - strike) / strike * 100) : 0;
  const isDiscount = discPct < 0;

  document.getElementById('sub-line').innerHTML = CFG.pair + ' \u00b7 FUTARCHY CPMM \u00b7 <span class="data-tag">' + (isLive ? 'LIVE' : 'SNAPSHOT') + '</span>';
  document.getElementById('title').textContent = CFG.ticker + ' \u2014 ' + (itm ? 'Trading Below Treasury Floor' : 'Trading Above Treasury Floor');
  document.getElementById('desc').innerHTML =
    CFG.ticker + ' is trading at <b>' + fmt$(CFG.spot) + '</b>, ' + (itm ? 'below' : 'above') + ' the <b>' + fmt$(strike) + '</b> treasury floor (treasury/token). ' +
    'Token holders can vote for dissolution and claim their pro-rata share of the treasury. ' +
    (itm ? 'Currently trading at a <span class="hl-orange">' + Math.abs(discPct).toFixed(1) + '%</span> discount \u2014 each token is backed by more than its market price.' : '');

  document.getElementById('cards').innerHTML =
    '<div class="card"><div class="card-label">Treasury</div><div class="card-value" style="color:var(--green)">' + fmtM(CFG.treasuryUSDC) + '</div><div class="card-sub">' + fmtM(CFG.monthlyBurn) + '/mo burn</div></div>' +
    '<div class="card"><div class="card-label">Spot Price</div><div class="card-value" style="color:var(--white)">' + fmt$(CFG.spot) + '</div><div class="card-sub">current market price</div></div>' +
    '<div class="card"><div class="card-label">Backing / Token</div><div class="card-value" style="color:var(--white)">' + fmt$(strike) + '</div><div class="card-sub">treasury \u00f7 holder supply</div></div>' +
    '<div class="card"><div class="card-label">' + (isDiscount ? 'Discount' : 'Premium') + '</div><div class="card-value" style="color:' + (isDiscount ? 'var(--red)' : 'var(--green)') + '">' + (isDiscount ? Math.abs(discPct).toFixed(1) + '%' : '+' + discPct.toFixed(0) + '%') + '</div><div class="card-sub">' + (isDiscount ? 'below treasury floor' : 'above treasury floor') + '</div></div>' +
    '<div class="card"><div class="card-label">Runway</div><div class="card-value" style="color:var(--orange)">' + monthsLeft + ' mo</div><div class="card-sub">at current burn rate</div></div>';

  document.getElementById('params').innerHTML =
    '<span>Raise <b>' + fmtM(CFG.raise) + '</b></span>' +
    '<span>Supply <b>' + (supplyForNAV / 1e6).toFixed(1) + 'M</b></span>' +
    '<span>S\u2080 <b>' + fmt$(CFG.icoPrice) + '</b></span>' +
    '<span>NAV <span class="hl">' + fmt$(strike) + '</span></span>' +
    '<span>Spot now <span class="spot">' + fmt$(CFG.spot) + '</span></span>' +
    '<span>ATH <b>' + fmt$(CFG.ath) + '</b></span>' +
    '<span>Burn <b>' + fmtBurn(CFG.monthlyBurn) + '/mo</b></span>';

  document.getElementById('chart-label').innerHTML = CFG.ticker + ' Price vs NAV';
  document.getElementById('leg-spot-label').textContent = CFG.ticker + ' Price';
  document.getElementById('leg-strike').textContent = fmt$(strike);

  return strike;
}

// ═══════════════════════════════════════════════════════════════════════
// NAV STATS BAR
// ═══════════════════════════════════════════════════════════════════════
function renderNAVStats(candles, navPerToken) {
  var bar = document.getElementById('nav-stats-bar');
  if (!bar || !candles || candles.length === 0 || !navPerToken) { if (bar) bar.innerHTML = ''; return; }

  var aboveDays = 0, belowDays = 0;
  var currentStreak = 0, currentAbove = false;
  var maxAboveStreak = 0, maxBelowStreak = 0;
  var tempAbove = 0, tempBelow = 0;
  var avgAbovePct = 0, avgBelowPct = 0;
  var abovePctSum = 0, belowPctSum = 0;

  for (var i = 0; i < candles.length; i++) {
    var p = candles[i].close || candles[i].price;
    var pct = (p - navPerToken) / navPerToken * 100;
    if (p >= navPerToken) {
      aboveDays++;
      abovePctSum += pct;
      tempAbove++;
      if (tempAbove > maxAboveStreak) maxAboveStreak = tempAbove;
      tempBelow = 0;
    } else {
      belowDays++;
      belowPctSum += Math.abs(pct);
      tempBelow++;
      if (tempBelow > maxBelowStreak) maxBelowStreak = tempBelow;
      tempAbove = 0;
    }
  }

  var total = aboveDays + belowDays;
  var abovePct = total > 0 ? (aboveDays / total * 100) : 0;
  var belowPct = total > 0 ? (belowDays / total * 100) : 0;
  var avgAbove = aboveDays > 0 ? (abovePctSum / aboveDays) : 0;
  var avgBelow = belowDays > 0 ? (belowPctSum / belowDays) : 0;

  // Current streak
  var lastP = candles[candles.length - 1].close || candles[candles.length - 1].price;
  var isAboveNow = lastP >= navPerToken;
  currentStreak = 0;
  for (var j = candles.length - 1; j >= 0; j--) {
    var jp = candles[j].close || candles[j].price;
    if ((jp >= navPerToken) === isAboveNow) currentStreak++;
    else break;
  }

  bar.innerHTML =
    '<div class="ns-item ns-above">' +
      '<div class="ns-label">Time Above NAV</div>' +
      '<div class="ns-value">' + abovePct.toFixed(1) + '%</div>' +
      '<div class="ns-sub">' + aboveDays + ' of ' + total + ' periods · avg +' + avgAbove.toFixed(1) + '%</div>' +
      '<div class="ns-progress"><div class="ns-progress-fill" style="width:' + abovePct + '%;background:#00e5a0"></div></div>' +
    '</div>' +
    '<div class="ns-item ns-below">' +
      '<div class="ns-label">Time Below NAV</div>' +
      '<div class="ns-value">' + belowPct.toFixed(1) + '%</div>' +
      '<div class="ns-sub">' + belowDays + ' of ' + total + ' periods · avg -' + avgBelow.toFixed(1) + '%</div>' +
      '<div class="ns-progress"><div class="ns-progress-fill" style="width:' + belowPct + '%;background:#e84057"></div></div>' +
    '</div>' +
    '<div class="ns-item ns-neutral">' +
      '<div class="ns-label">Current Streak</div>' +
      '<div class="ns-value" style="color:' + (isAboveNow ? '#00e5a0' : '#e84057') + '">' + currentStreak + ' periods</div>' +
      '<div class="ns-sub">' + (isAboveNow ? 'above' : 'below') + ' NAV · longest ' + (isAboveNow ? maxAboveStreak + ' above' : maxBelowStreak + ' below') + '</div>' +
    '</div>';
}

// ═══════════════════════════════════════════════════════════════════════
// ADDRESS SECTION
// ═══════════════════════════════════════════════════════════════════════
function renderAddresses() {
  const section = document.getElementById('addr-section');
  if (!section) return;
  const truncAddr = a => a.slice(0, 6) + '…' + a.slice(-4);
  const solscanUrl = (addr, type) => 'https://solscan.io/' + type + '/' + addr;
  const copyBtn = (addr) => '<button class="addr-copy" onclick="navigator.clipboard.writeText(\'' + addr + '\');this.textContent=\'Copied!\';this.classList.add(\'copied\');setTimeout(function(){this.textContent=\'Copy\';this.classList.remove(\'copied\')}.bind(this),1500)">Copy</button>';

  const addrs = [];
  if (CFG.mint) addrs.push({ label: 'Token CA', addr: CFG.mint, type: 'token', balKey: null });
  if (CFG.daoWallet) addrs.push({ label: 'DAO Treasury', addr: CFG.daoWallet, type: 'account', balKey: 'dao' });
  if (CFG.ammWallet) addrs.push({ label: 'Fut AMM', addr: CFG.ammWallet, type: 'account', balKey: 'futamm' });
  if (CFG.ammWallet2) addrs.push({ label: 'Met AMM', addr: CFG.ammWallet2, type: 'account', balKey: 'metamm' });
  if (CFG.lockWallet) addrs.push({ label: 'Team Locked', addr: CFG.lockWallet, type: 'account', balKey: 'lock' });
  if (CFG.buybackWallet) addrs.push({ label: 'Buyback Wallet', addr: CFG.buybackWallet, type: 'account', balKey: 'buyback' });

  section.innerHTML = '<div class="addr-title">Relevant Wallets</div>' +
    '<div id="addr-table">' +
    addrs.map(function(a) {
      return '<div class="addr-row">' +
        '<span class="addr-label">' + a.label + '</span>' +
        '<div class="addr-val">' +
          '<a href="' + solscanUrl(a.addr, a.type) + '" target="_blank" title="View on Solscan">' + truncAddr(a.addr) + '</a>' +
          copyBtn(a.addr) +
        '</div>' +
        '<div class="addr-bals" data-bal="' + (a.balKey || '') + '"><span class="bal-loading">—</span></div>' +
      '</div>';
    }).join('') +
    '</div>';
}

function renderBalances() {
  var ticker = CFG.ticker || '';
  var fmtUsdc = function(n) {
    if (n === undefined || n === null) return '';
    if (n >= 1e6) return (n / 1e6).toFixed(2) + 'M USDC';
    if (n >= 1e3) return (n / 1e3).toFixed(1) + 'K USDC';
    if (n >= 100) return n.toFixed(0) + ' USDC';
    return '<$100 USDC';
  };
  var fmtTokens = function(n) {
    if (n === undefined || n === null || n === 0) return '0 ' + ticker;
    if (n >= 1e6) return (n / 1e6).toFixed(2) + 'M ' + ticker;
    if (n >= 1e3) return (n / 1e3).toFixed(0) + 'K ' + ticker;
    return n.toLocaleString() + ' ' + ticker;
  };

  // Map balance keys to actual data
  var balData = {
    dao: { usdc: CFG.treasuryUSDC || 0, tokens: CFG.daoTokenBalance || 0 },
    futamm: { usdc: CFG.futAmmUSDC || 0, tokens: CFG.futAmmTokens || 0 },
    metamm: { usdc: CFG.metAmmUSDC || 0, tokens: CFG.metAmmTokens || 0 },
    lock: { usdc: 0, tokens: CFG.lockTokenBalance || 0 },
    buyback: { usdc: 0, tokens: CFG.buybackTokenBalance || 0 },
  };

  document.querySelectorAll('.addr-bals').forEach(function(el) {
    var key = el.dataset.bal;
    if (!key) { el.innerHTML = '<span class="bal-token">—</span>'; return; }
    var d = balData[key] || { usdc: 0, tokens: 0 };
    var usdcStr = fmtUsdc(d.usdc);
    var tokenStr = fmtTokens(d.tokens);
    if (usdcStr) {
      el.innerHTML = '<span class="bal-usdc">' + usdcStr + '</span>' +
        '<span class="bal-sep">·</span>' +
        '<span class="bal-token">' + tokenStr + '</span>';
    } else {
      el.innerHTML = '<span class="bal-token">' + tokenStr + '</span>';
    }
  });
}

// ═══════════════════════════════════════════════════════════════════════
// ALLOWANCE SCHEDULE
// ═══════════════════════════════════════════════════════════════════════
async function fetchAllowance() {
  try {
    var res = await fetch(API_BASE_DASH + '/api/allowance?token=' + tokenKey);
    var data = await res.json();
    if (data && !data.message) renderAllowance(data);
    else if (data && data.utilization && data.utilization.length > 0) renderAllowance(data);
  } catch (e) { console.error('Allowance fetch error:', e); }
}

function renderAllowance(data) {
  var section = document.getElementById('allowance-section');
  var cards = document.getElementById('allowance-cards');
  var history = document.getElementById('allowance-history');
  if (!section || !cards) return;

  section.style.display = 'block';

  var fmtK = function(v) {
    if (v >= 1000000) return '$' + (v / 1000000).toFixed(1) + 'M';
    if (v >= 1000) return '$' + (v / 1000).toFixed(0) + 'K';
    return '$' + v.toLocaleString();
  };

  var fmtDate = function(d) {
    var parts = d.split('-');
    var months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    return months[parseInt(parts[1]) - 1] + ' ' + parseInt(parts[2]);
  };

  // Build cards
  var html = '';

  // Card 1: Monthly Allowance Cap
  if (data.monthlyAllowance) {
    html += '<div class="allowance-card"><div class="ac-label">Monthly Allowance</div><div class="ac-value">' + fmtK(data.monthlyAllowance) + '</div><div class="ac-sub">' + (data.schedule ? data.schedule.frequency : '') + ' schedule</div></div>';
  }

  // Card 2: Avg Utilization
  if (data.avgUtilization !== null && data.avgUtilization !== undefined) {
    var utilColor = data.avgUtilization > 100 ? '#e84057' : data.avgUtilization > 80 ? '#ff8c42' : '#00e5a0';
    html += '<div class="allowance-card"><div class="ac-label">Avg Utilization</div><div class="ac-value" style="color:' + utilColor + '">' + data.avgUtilization + '%</div>';
    html += '<div class="util-bar"><div class="util-fill" style="width:' + Math.min(100, data.avgUtilization) + '%;background:' + utilColor + '"></div></div></div>';
  }

  // Card 3: Total Paid Out
  if (data.summary) {
    html += '<div class="allowance-card"><div class="ac-label">Total Paid Out</div><div class="ac-value">' + fmtK(data.summary.totalPaidOut) + '</div><div class="ac-sub">' + data.summary.monthsLive + ' months live</div></div>';
  }

  // Card 4: Next Payment
  if (data.nextPredicted) {
    var np = data.nextPredicted;
    var statusText = np.overdue ? '<span style="color:#e84057">' + Math.abs(np.daysUntil) + 'd overdue</span>' : '<span style="color:#00e5a0">in ' + np.daysUntil + ' days</span>';
    html += '<div class="allowance-card"><div class="ac-label">Next Predicted</div><div class="ac-value">' + fmtDate(np.date) + '</div><div class="ac-sub">' + statusText + ' · ~' + fmtK(np.estimatedAmount) + '</div></div>';
  }

  // Card 5: Last Payment
  if (data.lastPayment) {
    var lp = data.lastPayment;
    html += '<div class="allowance-card"><div class="ac-label">Last Payment</div><div class="ac-value">' + fmtDate(lp.date) + '</div><div class="ac-sub">' + lp.daysAgo + ' days ago · ' + fmtK(lp.amount) + '</div></div>';
  }

  cards.innerHTML = html;

  // Monthly utilization bars
  if (data.utilization && data.utilization.length > 0 && data.monthlyAllowance) {
    var utilHtml = '<div style="margin-top:8px;font-size:9px;color:var(--dim);font-family:Inter,sans-serif;text-transform:uppercase;letter-spacing:0.5px;margin-bottom:6px">Monthly Breakdown</div>';
    data.utilization.forEach(function(u) {
      var pct = u.utilization || 0;
      var barColor = pct > 100 ? '#e84057' : pct > 80 ? '#ff8c42' : '#00e5a0';
      var barWidth = Math.min(100, pct);
      utilHtml += '<div class="allowance-month">';
      utilHtml += '<span class="am-label" style="min-width:48px">' + u.month + '</span>';
      utilHtml += '<span class="am-bar"><span class="am-fill" style="width:' + barWidth + '%;background:' + barColor + '"></span></span>';
      utilHtml += '<span class="am-pct">' + pct + '%</span>';
      utilHtml += '<span style="color:var(--muted);margin-left:4px">' + fmtK(u.spent) + '</span>';
      utilHtml += '</div>';
    });
    history.innerHTML = utilHtml;
  }

  // Show special payments if any
  if (data.specialPayments && data.specialPayments.length > 0) {
    var spHtml = '<div style="margin-top:10px;font-size:9px;color:var(--dim);font-family:Inter,sans-serif;text-transform:uppercase;letter-spacing:0.5px;margin-bottom:4px">Special Payments (governance)</div>';
    data.specialPayments.forEach(function(sp) {
      spHtml += '<div style="font-size:10px;color:var(--muted);padding:2px 0">' + fmtDate(sp.date) + ' — ' + fmtK(sp.amount) + '</div>';
    });
    history.innerHTML += spHtml;
  }
}

// ═══════════════════════════════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════════════════════════════
(async function main() {
  if (!CFG.live) return;
  CFG.effectiveSupply = CFG.supply;
  var navPerToken = renderUI(false);
  renderAddresses();

  try {
    // Fetch allowance data for chart markers
    var allowancePromise = fetch(API_BASE_DASH + '/api/allowance?token=' + tokenKey)
      .then(function(r) { return r.json(); })
      .then(function(d) {
        if (d && d.cycles) {
          _allowancePayments = d.cycles.map(function(c) { return { date: c.startDate, amount: c.amount }; });
        }
      }).catch(function() {});

    var results = await Promise.all([fetchOHLCV(), fetchFromAPI(), fetchNAVHistory(), allowancePromise]);
    var ohlcv = results[0], apiOk = results[1];
    var isLive = !!(ohlcv || apiOk);
    navPerToken = renderUI(isLive);
    renderBalances();

    var chartData = (ohlcv && ohlcv.length > 0) ? ohlcv : [];

    if (apiOk && chartData.length > 0) {
      var lastCandle = chartData[chartData.length - 1];
      if (Math.abs(lastCandle.price - CFG.spot) > CFG.spot * 0.01) {
        chartData.push({ date: new Date(), open: lastCandle.price, high: Math.max(lastCandle.price, CFG.spot), low: Math.min(lastCandle.price, CFG.spot), close: CFG.spot, price: CFG.spot });
      }
    }

    var loadEl = document.getElementById('chart-loading');
    if (loadEl) loadEl.style.display = 'none';
    try {
      initChart(chartData, navPerToken);
    } catch(chartErr) {
      console.error('Chart init error:', chartErr);
    }
    renderNAVStats(chartData, navPerToken);

    if (!ohlcv) {
      var notice = document.createElement('div');
      notice.style.cssText = 'text-align:center;font-size:9px;color:#ff8c42;font-family:Inter,sans-serif;padding:6px 0';
      notice.textContent = '\u26a0 Chart data unavailable — price data could not be loaded.';
      var chartContainer = document.getElementById('chart-container');
      chartContainer.parentNode.insertBefore(notice, chartContainer.nextSibling);
    }

    console.log('NAVgator ' + CFG.ticker + ' | Live: ' + isLive + ' | OHLCV: ' + (ohlcv ? ohlcv.length + ' candles' : 'none') + ' | Spot: $' + CFG.spot + ' | Treasury: $' + CFG.treasuryUSDC.toLocaleString() + ' | EffSupply: ' + (CFG.effectiveSupply || CFG.supply).toLocaleString() + ' | NAV: $' + navPerToken.toFixed(6));

    // Fetch and render allowance data
    fetchAllowance();
  } catch (err) {
    console.error('NAVgator init error:', err);
    var loadEl2 = document.getElementById('chart-loading');
    if (loadEl2) loadEl2.remove();
    initChart([], navPerToken);
    var notice2 = document.createElement('div');
    notice2.style.cssText = 'text-align:center;font-size:9px;color:#e84057;font-family:Inter,sans-serif;padding:6px 0';
    notice2.textContent = '\u26a0 Error loading data — chart unavailable.';
    var cc2 = document.getElementById('chart-container');
    cc2.parentNode.insertBefore(notice2, cc2.nextSibling);
  }
})();
} // end if (_hasToken)
</script>
</body>
</html>
